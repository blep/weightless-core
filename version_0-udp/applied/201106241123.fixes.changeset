Changeset created on Fri Jun 24 11:23:25 CEST 2011 by Seek You Too

Description: This adds the test/core module previously ignored by svn

    This adds the test/core module previously ignored by svn.

Baseline version: https://weightless.svn.sourceforge.net/svnroot/weightless/weightless-core/workingsets/0.6-seecr/version_0

diff --unidirectional-new-file '--exclude=*.so' '--exclude=*.o' '--exclude=.svn' '--exclude=*.pyc' '--exclude=deps.d' '--exclude=applied' --recursive --unified version_0/test/core/composetest.py version_0-fixes/test/core/composetest.py
--- version_0/test/core/composetest.py	1970-01-01 01:00:00.000000000 +0100
+++ version_0-fixes/test/core/composetest.py	2011-06-24 11:10:53.000000000 +0200
@@ -0,0 +1,1106 @@
+## begin license ##
+#
+#    Weightless is a High Performance Asynchronous Networking Library
+#    See http://weightless.io
+#    Copyright (C) 2006-2011 Seek You Too (CQ2) http://www.cq2.nl
+#
+#    This file is part of Weightless
+#
+#    Weightless is free software; you can redistribute it and/or modify
+#    it under the terms of the GNU General Public License as published by
+#    the Free Software Foundation; either version 2 of the License, or
+#    (at your option) any later version.
+#
+#    Weightless is distributed in the hope that it will be useful,
+#    but WITHOUT ANY WARRANTY; without even the implied warranty of
+#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+#    GNU General Public License for more details.
+#
+#    You should have received a copy of the GNU General Public License
+#    along with Weightless; if not, write to the Free Software
+#    Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+#
+## end license ##
+
+from unittest import TestCase
+from sys import stdout, exc_info, getrecursionlimit, version_info
+import gc
+from weakref import ref
+from types import GeneratorType
+from weightless.core import autostart
+from weightless.core.compose._local_py import local as pyLocal
+from weightless.core.compose._compose_py import compose as pyCompose
+from weightless.core.compose._tostring_py import tostring as pyTostring
+from weightless.core.compose._compose_c import local as cLocal, compose as cCompose
+from weightless.core.compose._compose_c import tostring as cTostring
+
+class ATrackedObj(object):
+    def __init__(self):
+        self.l = []
+        
+class _ComposeTest(TestCase):
+
+    def testCallCompose(self):
+        try:
+            compose()
+            self.fail()
+        except TypeError, e:
+            self.assertTrue(
+                    "compose() takes at least 1 argument (0 given)" in str(e)
+                    or # (python 2.5/2.6 C-API differences)
+                    "Required argument 'initial' (pos 1) not found" in str(e))
+        self.assertRaises(TypeError, compose, 's')
+        self.assertRaises(TypeError, compose, 0)
+
+    def testGC(self):
+        c = compose((x for x in []))
+        gc.collect()
+        del c
+        gc.collect()
+
+    def assertComposeImpl(self, impl):
+        self.assertEquals(impl, compose)
+
+    def testCreateSinglecompose(self):
+        def multplyBy2(number): yield number * 2
+        g = multplyBy2(2)
+        wlt = compose(g)
+        response = wlt.next()
+        self.assertEquals(4, response)
+
+    def testRunCompletely(self):
+        wlt = compose(x for x in range(3))
+        results = list(wlt)
+        self.assertEquals([0,1,2], results)
+
+    def testCreateNestedcompose(self):
+        def multplyBy2(number): yield number * 2
+        def delegate(number): yield multplyBy2(number * 2)
+        wlt = compose(delegate(2))
+        response = wlt.next()
+        self.assertEquals(8, response)
+
+    def testCreateTripleNextedcompose(self):
+        def multplyBy2(number): yield number * 2
+        def delegate(number): yield multplyBy2(number * 2)
+        def master(number): yield delegate(number * 2)
+        wlt = compose(master(2))
+        response = wlt.next()
+        self.assertEquals(16, response)
+
+    def testResumecompose(self):
+        def thread():
+            yield 'A'
+            yield 'B'
+        wlt = compose(thread())
+        response = wlt.next()
+        self.assertEquals('A', response)
+        response = wlt.next()
+        self.assertEquals('B', response)
+
+    def testResumeNestedcompose(self):
+        def threadA():
+            yield 'A'
+            yield 'B'
+        def threadB():
+            yield 'C'
+            yield threadA()
+            yield 'D'
+        wlt = compose(threadB())
+        results = list(wlt)
+        self.assertEquals(['C','A','B','D'], results)
+
+    def testPassValueToRecursivecompose(self):
+        def threadA():
+            r = yield threadB()     # <= C
+            yield r * 3                     # <= D
+        def threadB():
+            yield 7                     # <= A
+            r = yield
+            raise StopIteration(r * 2)     # <= B
+        t = compose(threadA())
+        self.assertEquals(7, t.next())              # 7 yielded at A
+        t.next() # adhere to 'send on None' protocol
+        self.assertEquals(18, t.send(3))        # 3 send to A, 6 yielded at B, as return value to C, then yielded at D
+
+    def testReturnOne(self):
+        data = []
+        def child():
+            raise StopIteration('result')
+            yield
+        def parent():
+            result = yield child()
+            data.append(result)
+        g = compose(parent())
+        list(g)
+        self.assertEquals('result', data[0])
+
+    def testReturnThree(self):
+        data = []
+        def child():
+            raise StopIteration('result', 'remainingData1', 'other2')
+            yield
+        def parent():
+            result = yield child()
+            data.append(result)
+            remainingData = yield None
+            data.append(remainingData)
+            other2 = yield None
+            data.append(other2)
+        g = compose(parent())
+        list(g)
+        self.assertEquals('result', data[0])
+        self.assertEquals('remainingData1', data[1])
+        self.assertEquals('other2', data[2])
+
+    def testReturnAndCatchRemainingDataInNextGenerator(self):
+        messages = []
+        responses = []
+        def child1():
+            raise StopIteration('result', 'remainingData0', 'remainingData1')
+            yield
+        def child2():
+            messages.append((yield 'A'))                # I want to 'send' and do not accept data
+            messages.append((yield))                     # now accept 'remainingData0'
+            messages.append((yield))                     # append 'remainingData1'
+            messages.append((yield 'C'))               # append None (I want to send)
+        def parent():
+            messages.append((yield child1()))   # append 'result'
+            messages.append((yield child2()))   # what does 'yield child2()' return???
+        g = compose(parent())
+        responses.append(g.send(None))
+        responses.append(g.send(None))
+        #responses.append(g.send(None))
+        try:
+            responses.append(g.send(None))
+            self.fail()
+        except StopIteration:
+            pass
+        self.assertEquals(['result', None, 'remainingData0', 'remainingData1', None, None], messages)
+        self.assertEquals(['A', 'C'], responses)
+
+    def testStopIterationWithReturnValue(self):
+        def f():
+            raise StopIteration('return value')
+            yield 'something'
+        def g():
+            self.retval = yield f()
+        list(compose(g()))
+        self.assertEquals('return value', self.retval)
+
+    def testReturnInNestedGeneratorQuiteTricky(self):
+        r = []
+        def ding1():
+            dataIn = yield None     # receive 'dataIn'
+            self.assertEquals('dataIn', dataIn)
+            raise StopIteration('ding1retval', 'rest('+dataIn+')')
+        def ding2():
+            dataIn = yield None     # receive 'rest(dataIn)'
+            #retval = RETURN, 'ding2retval', 'rest('+dataIn+')'
+            raise StopIteration('ding2retval', 'rest('+dataIn+')')
+        def child():
+            ding1retval = yield ding1()
+            r.append('child-1:' + str(ding1retval))
+            ding2retval = yield ding2()
+            r.append('child-2:' + str(ding2retval))
+            raise StopIteration('childretval')
+        def parent():
+            childRetVal = yield child()
+            self.assertEquals('childretval', childRetVal)
+            rest = yield
+            r.append('parent:'+rest)
+        g = compose(parent())
+        g.next()
+        try:
+            g.send('dataIn')
+            self.fail()
+        except StopIteration:
+            pass
+        self.assertEquals(['child-1:ding1retval', 'child-2:ding2retval', 'parent:rest(rest(dataIn))'], r)
+
+    def testCheckForFreshGenerator(self):
+        def sub():
+            yield
+            yield
+        def main():
+            s = sub()
+            s.next() # start it already
+            yield s
+        c = compose(main())
+        try:
+            c.next()
+            self.fail('must raise')
+        except Exception, e:
+            self.assertEquals('Generator already used.', str(e))
+
+    def testForExhaustedGenerator(self):
+        def sub():
+            yield
+        def main():
+            s = sub()
+            s.next()
+            try:
+                s.next()
+                self.fail('must raise StopIteration')
+            except StopIteration: pass
+            yield s
+        c = compose(main())
+        try:
+            c.next()
+            self.fail('must not come here')
+        except Exception, e:
+            self.assertEquals('Generator is exhausted.', str(e))
+
+    def testPassThrowCorrectly(self):
+        class MyException(Exception): pass
+        def child():
+            try:
+                yield 1
+            except Exception, e:
+                self.e = e
+            yield 2
+        g = compose(child())
+        g.next()
+        g.throw(MyException('aap'))
+        self.assertEquals('aap', str(self.e))
+
+    def testThrowWithLocalCorrectly(self):
+        class MyException(Exception): pass
+        def child(x):
+            try:
+                yield 1
+            except Exception, e:
+                yield f2()
+        def f2():
+            self.e = local("x")
+            yield 2
+        a = compose(child("test"))
+        g = compose(child("aap"))
+        g.next()
+        g.throw(MyException())
+        self.assertEquals('aap', str(self.e))
+
+    def testHandleAllDataAndDoAvoidSuperfluousSendCalls(self):
+        data = []
+        def f():
+            x = yield
+            data.append(x)
+            raise StopIteration(*tuple(x))
+        def g():
+            r = yield f()
+            data.append(r)
+            while True:
+                data.append((yield None))
+        program = compose(g())
+        program.next() # init
+        program.send('mies')
+        #program.next() # this is what we don't want and what we're testing here
+        #program.next()
+        #program.next()
+        self.assertEquals('mies', data[0])
+        self.assertEquals('m', data[1])
+        self.assertEquals('i', data[2])
+        self.assertEquals('e', data[3])
+        self.assertEquals('s', data[4])
+        program.close()
+
+    def testHandleClose(self):
+        r = []
+        def f():
+            try:
+                yield None
+            except BaseException, e:
+                r.append(e)
+                raise
+        g = compose(f())
+        g.next()
+        g.close()
+        self.assertEquals(GeneratorExit, type(r[0]))
+
+    def testCloseWithLocalCorrectly(self):
+        class MyException(Exception): pass
+        def child(x):
+            yield f2()
+        def f2():
+            try:
+                yield 1
+            except BaseException, e:
+                self.e = local("x")
+                raise
+        g = compose(child("aap"))
+        g.next()
+        g.close()
+        self.assertEquals('aap', str(self.e))
+
+    def testHandleStop(self):
+        r = []
+        def f():
+            try:
+                yield None
+            except Exception, e:
+                r.append(e)
+                raise
+        g = compose(f())
+        g.next()
+        try:
+            g.throw(StopIteration)
+        except:
+            pass
+        self.assertEquals(StopIteration, type(r[0]))
+
+    def testPassException1(self):
+        class MyException(Exception): pass
+        class WrappedException(Exception): pass
+        def child():
+            raise MyException('abc')
+            yield None
+        def parent():
+            try:
+                yield child()
+            except MyException, e:
+                raise WrappedException(e)
+        g = compose(parent())
+        try:
+            g.next()
+            self.fail()
+        except WrappedException, e:
+            self.assertEquals('abc', str(e))
+
+    def testDealloc(self):
+        def f():
+            yield 'A'
+            yield (1,2,3,4)
+            yield 'B'
+            yield 'C'
+            yield 'D'
+        g = compose(f())
+        g.next()
+        g.next()
+        del g
+
+    def testPassException2(self):
+        class MyException(Exception): pass
+        class WrappedException(Exception): pass
+        def child():
+            yield None
+            raise MyException('abc')
+        def parent():
+            try:
+                yield child()
+            except MyException, e:
+                raise WrappedException(e)
+        g = compose(parent())
+        g.next()
+        try:
+            g.next()
+            self.fail()
+        except WrappedException, e:
+            self.assertEquals('abc', str(e))
+
+    def xtestPerformance(self):
+        def f1(arg):
+            r = yield None
+            yield arg
+            raise StopIteration('aap', 'rest')
+        def f2(arg):
+            r1 = yield f1('noot')
+            r2 = yield f1('mies')
+        def f3(arg):
+            yield 'A'
+            r = yield None
+            yield 'B'
+            a = yield f2('C')
+            b = yield f2('D')
+            yield a
+            yield b
+        # name, creates, runs
+        #       f3          1           1
+        #       f2          2           2
+        #       f1          4           4
+        #   total       7           7
+        def baseline():
+            list(f3('A'))   # 3     1
+            list(f2('B'))   # 3     1
+            list(f1('C'))   # 1     1
+            list(f1('C'))   # 1     1
+                                # 8     4  (versus 7        7)
+        from time import time
+        tg = tb = 0.0
+        for i in range(10):
+            stdout.write('*')
+            stdout.flush()
+            t0 = time()
+            [list(compose(f3('begin'))) for i in xrange(100)]
+            t1 = time()
+            tg = tg + t1 - t0
+            [baseline() for i in xrange(100)]
+            t2 = time()
+            tb = tb + t2 - t1
+        print 'Overhead compose compared to list(): %2.2f %%' % ((tg/tb - 1) * 100.0)
+
+    def testMemLeaks(self):
+        def f1(arg):
+            r = yield arg                       # None
+            raise Exception()
+        def f2(arg):
+            r1 = yield None                 # 'A'
+            try:
+                r2 = yield f1(r1)
+            except GeneratorExit:
+                raise
+            except Exception, e:
+                raise StopIteration(e, 'more')
+        def f3(arg):
+            e = yield f2('aa')
+            more = yield None
+            try:
+                yield more                      #   'X'
+            except Exception:
+                raise
+        # runs this a zillion times and watch 'top'
+        for i in xrange(1):
+            g = compose(f3('noot'))
+            g.next()
+            g.send('A')
+            g.send(None)
+            try:
+                g.throw(Exception('X'))
+            except:
+                pass
+
+    def testNestedExceptionHandling(self):
+        def f():
+            yield 'A'
+        def g():
+            try:
+                yield f()
+            except Exception, e:
+                raise Exception(e)
+        c = compose(g())
+        r = c.next()
+        self.assertEquals('A', r)
+        try:
+            c.throw(Exception('wrong'))
+            self.fail('must raise wrapped exception')
+        except Exception, e:
+            self.assertEquals("Exception(Exception('wrong',),)", repr(e))
+
+    def testNestedClose(self):
+        def f():
+            yield 'A'
+        def g():
+            try:
+                yield f()
+            except BaseException, e:
+                raise Exception(e)
+        c = compose(g())
+        r = c.next()
+        self.assertEquals('A', r)
+        try:
+            c.close()
+            self.fail('must raise wrapped CLOSE exception')
+        except Exception, e:
+            self.assertEquals("Exception(GeneratorExit(),)", repr(e))
+
+    def testMaskException(self):
+        def f():
+            try:
+                yield 'a'
+            except:
+                pass
+        c = compose(f())
+        c.next()
+        try:
+            c.throw(Exception('aap'))
+        except StopIteration:
+            pass
+        except Exception, e:
+            self.fail(str(e))
+
+    def testThrowWithExceptionCaughtDoesNotDitchResponse(self):
+        def f():
+            try:
+                yield 'response'
+            except StopIteration:
+                pass
+            yield 'is this ditched?'
+        c = compose(f())
+        response = c.next()
+        self.assertEquals('response', response)
+        response = c.throw(StopIteration())
+        self.assertEquals('is this ditched?', response)
+
+    def testThrowWithExceptionCaughtDoesNotDitchResponseWhileInSubGenerator(self):
+        def sub():
+            try:
+                yield 'response'
+            except StopIteration:
+                raise StopIteration('return')
+        def f():
+            ret = yield sub()
+            self.assertEquals('return', ret)
+            yield 'is this ditched?'
+        c = compose(f())
+        response = c.next()
+        self.assertEquals('response', response)
+        response = c.throw(StopIteration())
+        self.assertEquals('is this ditched?', response)
+
+    def testAdhereToYieldNoneMeansReadAndYieldValueMeansWriteWhenMessagesAreBuffered(self):
+        done = []
+        def bufferSome():
+            raise StopIteration('retval', 'rest1', 'rest2')
+            yield
+        def writeSome():
+            yield 'write this'
+        def g():
+            yield bufferSome()
+            yield writeSome()
+            data = yield 'write'
+            self.assertEquals(None, data)
+            data = yield
+            self.assertEquals('rest1', data)
+            done.append(True)
+        g = compose(g())
+        results = list(g)
+        self.assertEquals([True], done)
+        self.assertEquals(['write this', 'write'], results)
+
+    def testAdhereToYieldNoneMeansReadAndYieldValueMeansWriteWhenMessagesAreBuffered2(self):
+        done = []
+        def bufferSome():
+            raise StopIteration('retval', 'rest1', 'rest2')
+            yield
+        def writeSome():
+            data = yield 'write this'
+            self.assertEquals(None, data)
+        def g():
+            yield bufferSome()
+            yield writeSome()
+            data = yield
+            self.assertEquals('rest1', data)
+            done.append(True)
+        g = compose(g())
+        results = list(g)
+        self.assertEquals([True], done)
+        self.assertEquals(['write this'], results)
+
+    def testDoNotSendSuperfluousNonesOrAdhereToNoneProtocol(self):
+        def sub():
+            jack = yield None
+            none = yield 'hello ' + jack
+            peter = yield None
+            none = yield 'hello ' + peter
+        c = compose(sub())
+        self.assertEquals(None, c.send(None))           # 1 init with None, oh, it accepts data
+        self.assertEquals('hello jack', c.send('jack')) # 2 send data, oh it has data
+        self.assertEquals(None, c.send(None))           # 3 it had data, so send None to see what it wants next, oh, it accepts data
+        self.assertEquals('hello peter', c.send('peter')) # 4 send data, oh, it has data
+
+    def testUserAdheresToProtocol(self):
+        def sub():
+            yield 'response'
+            yield 'response'
+        c = compose(sub())
+        self.assertEquals('response', c.next())
+        try:
+            c.send('message')
+            self.fail('must raise exception')
+        except AssertionError, e:
+            self.assertEquals('Cannot accept data. First send None.', str(e))
+
+    def testExceptionsHaveGeneratorCallStackAsBackTrace(self):
+        def f():
+            yield
+        def g():
+            yield f()
+        c = compose(g())
+        c.next()
+        try:
+            c.throw(Exception, Exception('ABC'))
+            self.fail()
+        except Exception:
+            exType, exValue, exTraceback = exc_info()
+            self.assertEquals('testExceptionsHaveGeneratorCallStackAsBackTrace', exTraceback.tb_frame.f_code.co_name)
+            self.assertEquals('g', exTraceback.tb_next.tb_frame.f_code.co_name)
+            self.assertEquals('f', exTraceback.tb_next.tb_next.tb_frame.f_code.co_name)
+    
+    def testToStringForSimpleGenerator(self):
+        def f():
+            yield
+        g = f()
+        soll = """  File "%s", line 629, in f
+    def f():""" % __file__.replace('pyc', 'py')
+        self.assertEquals(soll, tostring(g))
+        g.next()
+        soll = """  File "%s", line 630, in f
+    yield""" % __file__.replace('pyc', 'py')
+        self.assertEquals(soll, tostring(g))
+
+
+    def testToStringGivesStackOfGeneratorsAKAcallStack(self):
+        def f1():
+            yield
+        def f2():
+            yield f1()
+        c = compose(f2())
+        result = """  File "%s", line 645, in f2
+    yield f1()
+  File "%s", line 643, in f1
+    yield""" % (2*(__file__.replace('pyc', 'py'),))
+        c.next()
+        self.assertEquals(result, tostring(c), "\n%s\n!=\n%s\n" % (result, tostring(c)))
+
+    def testToStringForUnstartedGenerator(self):
+        def f1():
+            yield
+        def f2():
+            yield f1()
+        c = compose(f2())
+        result = """  File "%s", line 657, in f2
+    def f2():""" % __file__.replace('pyc', 'py')
+        self.assertEquals(result, tostring(c))
+
+    def testWrongArgToToString(self):
+        try:
+            tostring('x')
+            self.fail('must raise TypeError')
+        except TypeError, e:
+            self.assertEquals("tostring() expects generator", str(e))
+
+    def testFindLocalNotThere(self):
+        def f1():
+            yield f2()
+        def f2():
+            try:
+                l = local('doesnotexist')
+            except AttributeError, e:
+                yield e
+        f = compose(f1())
+        result = f.next()
+        self.assertEquals('doesnotexist', str(result))
+
+    def testFindLocal(self):
+        def f1():
+            someLocal = 'f1'
+            yield f3()
+        def f2():
+            someLocal = 'f2'
+            yield f3()
+        def f3():
+            l = local('someLocal')
+            yield l
+        f = compose(f1())
+        result = f.next()
+        self.assertEquals('f1', str(result))
+        self.assertEquals('f2', str(compose(f2()).next()))
+
+    def testFindLocalWithComposeUnassignedToVariable(self):
+        def f1():
+            f1local = 'f1'
+            yield f2()
+        def f2():
+            l = local('f1local')
+            yield l
+        self.assertEquals('f1', compose(f1()).next())
+
+    def testFindClosestLocal(self):
+        def f1():
+            myLocal = 'f1'
+            yield f2()
+        def f2():
+            myLocal = 'f2'
+            yield f3()
+        def f3():
+            l = local('myLocal')
+            yield l
+        f = compose(f1())
+        result = f.next()
+        self.assertEquals('f2', str(result))
+
+    def testOneFromPEP380(self):
+        """
+        Exceptions other than GeneratorExit thrown into the delegating
+     generator are passed to the ``throw()`` method of the iterator.
+     If the call raises StopIteration, the delegating generator is resumed.
+     Any other exception is propagated to the delegating generator.
+     (EG: rationale is that normally SystemExit is not catched, but it must
+     trigger finally's to clean up.)
+        """
+        msg = []
+        def f():
+            try:
+                yield g()
+            except SystemExit, e:
+                msg.append('see me')
+            yield
+        def g():
+            try:
+                yield
+            except KeyboardInterrupt:
+                msg.append('KeyboardInterrupt')
+            try:
+                yield
+            except SystemExit:
+                msg.append('SystemExit')
+            try:
+                yield
+            except BaseException:
+                msg.append('BaseException')
+                raise SystemExit('see me')
+            yield
+        c = compose(f())
+        c.next()
+        c.throw(KeyboardInterrupt())
+        self.assertEquals(['KeyboardInterrupt'], msg)
+        c.throw(SystemExit())
+        self.assertEquals(['KeyboardInterrupt', 'SystemExit'], msg)
+        c.throw(SystemExit()) # second time
+        self.assertEquals(['KeyboardInterrupt', 'SystemExit', 'BaseException', 'see me'], msg)
+
+    def testTwoFromPEP380(self):
+        """
+        If a GeneratorExit exception is thrown into the delegating generator,
+     or the ``close()`` method of the delegating generator is called, then
+     the ``close()`` method of the iterator is called if it has one. If this
+     call results in an exception, it is propagated to the delegating generator.
+     Otherwise, GeneratorExit is raised in the delegating generator.
+        """
+
+        # First test some assumptions about close()
+
+        @autostart
+        def f1():
+            try:
+                yield
+            except GeneratorExit:
+                raise ValueError('1')
+            yield
+        g1 = f1()
+        try:
+            g1.close()
+            self.fail('must raise ValueError')
+        except ValueError, e:
+            self.assertEquals('1', str(e))
+
+        @autostart
+        def f2():
+            try:
+                yield
+            except GeneratorExit:
+                pass
+            # implicit raise StopIteration here
+
+        g2 = f2()
+        try:
+            g2.close()
+        except BaseException:
+            self.fail('must not raise an exception')
+
+        @autostart
+        def f3():
+            try:
+                yield
+            except GeneratorExit:
+                pass
+            yield  # does not raise an exception but yields None
+
+        g3 = f3()
+        try:
+            g3.close()
+            self.fail('must not raise an exception')
+        except RuntimeError, e:
+            self.assertEquals('generator ignored GeneratorExit', str(e))
+
+
+        @autostart
+        def f4():
+            yield
+            yield
+
+        g4 = f4()
+        try:
+            g4.close()
+        except BaseException, e:
+            self.fail('must not raise an exception')
+
+        # This is test one
+
+        msg = []
+        def f5():
+            yield f6()
+        def f6():
+            try:
+                yield
+            except GeneratorExit:
+                msg.append('GeneratorExit turned into StopIteration')
+                raise StopIteration  # <= this is the clue, see next test
+        g5 = compose(f5())
+        g5.next()
+        try:
+            g5.throw(GeneratorExit())
+            self.fail('must reraise GeneratorExit if no exception by g1()')
+        except GeneratorExit:
+            pass
+        self.assertEquals(['GeneratorExit turned into StopIteration'], msg)
+
+        msg = []
+        def f7():
+            yield f8()
+        def f8():
+            try:
+                yield
+            except GeneratorExit:
+                msg.append('GeneratorExit ignored')
+            yield # <= this is the clue, see previous test
+        g7 = compose(f7())
+        g7.next()
+        try:
+            g7.throw(GeneratorExit)
+            self.fail('must reraise RuntimeError(generator ignored GeneratorExit)')
+        except RuntimeError:
+            pass
+        self.assertEquals(['GeneratorExit ignored'], msg)
+
+
+        # Second case
+
+        msg = []
+        def f8():
+            try:
+                yield f9()
+            #except RuntimeError, e:
+            except ValueError, e:
+                msg.append(str(e))
+                raise StopIteration()
+        def f9():
+            try:
+                yield
+            except GeneratorExit:
+                msg.append('GeneratorExit turned into ValueError')
+                #raise RuntimeError('stop here')
+                raise ValueError('stop here')
+            yield
+
+        g8 = compose(f8())
+        g8.next()
+        try:
+            g8.throw(GeneratorExit())
+            self.fail('must raise StopIteration')
+        except StopIteration:
+            pass
+        self.assertEquals(['GeneratorExit turned into ValueError', 'stop here'], msg)
+
+    def testYieldCompose(self):
+        def f():
+            yield "f"
+        def g():
+            yield compose(f())
+        c = compose(g())
+        self.assertEquals(['f'], list(c))
+
+    def testComposeCompose(self):
+        def f():
+            yield
+        c = compose(compose(f()))
+        self.assertTrue(c)
+
+    def testYieldComposeCloseAndThrow(self):
+        def f():
+            try:
+                yield 42
+            except Exception, e:
+                yield 84
+
+        c = compose(f())
+        self.assertEquals(42, c.send(None))
+        self.assertEquals(84, c.throw(Exception()))
+        self.assertEquals(None, c.close())
+
+    def testMessagesAndResponseAreFreed(self):
+        def f():
+            v = yield ATrackedObj() # some that is tracked
+        self.assertTrue('ATrackedObj' in str(compose(f()).next()))
+
+    def testDecorator(self):
+        from weightless.core import compose
+        @compose
+        def f():
+            yield "a"
+        self.assertEquals(["a"], list(f()))
+
+    def testEmptyArgsInStopIteration(self):
+        def f1():
+            si = StopIteration()
+            si.args = () # empty tuple
+            raise si
+            yield
+        def f2():
+            x = yield f1()
+            yield x
+        g = compose(f2())
+        self.assertEquals([None], list(g))
+
+    def testArgsIsNoIterable(self):
+        # because the Python VM checks this, we test the assumtion only
+        si = StopIteration()
+        try:
+            si.args = 9 # not a tuple. Actually checked by StopIteration itself!
+        except TypeError, e:
+            self.assertEquals("'int' object is not iterable", str(e))
+
+    def testArgsIsNoTuple(self):
+        # because the Python VM turns the args into a tuple, we only test this
+        si = StopIteration()
+        si.args = [2] # not a tuple. VM turns this into tuple
+        self.assertEquals((2,), si.args)
+
+    def testComposeType(self):
+        from weightless.core.compose import ComposeType
+        self.assertEquals(type, type(ComposeType))
+        self.assertEquals(ComposeType, type(compose((n for n in []))))
+
+    def testRaiseStopIterationWithRemainingMessages(self):
+        def f0():
+            raise StopIteration()
+            yield
+        def f1():
+            raise StopIteration(1)
+            yield
+        def f2():
+            raise StopIteration(2,3)
+            yield
+        def f3():
+            raise StopIteration(4,5,6)
+            yield
+        try: f0().next()
+        except StopIteration, e: self.assertEquals((), e.args)
+        try: f1().next()
+        except StopIteration, e: self.assertEquals((1,), e.args)
+        try: f2().next()
+        except StopIteration, e: self.assertEquals((2,3), e.args)
+        try: f3().next()
+        except StopIteration, e: self.assertEquals((4,5,6), e.args)
+
+    def testConcurrentFlow(self):
+        def f():
+            first_msg = yield
+            raise StopIteration(*first_msg.split())
+        def g():
+            first = yield f()
+            yield "response" # in between receiving msgs
+            msg = yield
+            second_msg = yield
+            yield second_msg
+        p = compose(g())
+        p.next()
+        p.send("first msg")
+        p.send(None)
+        x = p.send("second msg")
+        self.assertEquals('second msg', x)
+
+    def get_tracked_objects(self):
+        return [o for o in gc.get_objects() if type(o) in 
+                (compose, GeneratorType, Exception, StopIteration, ATrackedObj)]
+
+    def setUp(self):
+        gc.collect()
+        self._baseline = self.get_tracked_objects()
+
+    def tearDown(self):
+        def tostr(o):
+            try:
+                return tostring(o)
+            except:
+                return repr(o)
+        gc.collect()
+        for obj in self.get_tracked_objects():
+            self.assertTrue(obj in self._baseline, obj) #tostr(obj))
+        del self._baseline
+        gc.collect()
+
+class ComposePyTest(_ComposeTest):
+    def setUp(self):
+        global local, tostring, compose
+        local = pyLocal
+        tostring = pyTostring
+        compose = pyCompose
+        _ComposeTest.setUp(self)
+
+class ComposeCTest(_ComposeTest):
+    def setUp(self):
+        global local, tostring, compose
+        local = cLocal
+        tostring = cTostring
+        compose = cCompose
+        _ComposeTest.setUp(self)
+
+    def testQueueSize(self):
+        testrange = 9 #QUEUE SIZE = 10
+        def f():
+            raise StopIteration(*xrange(testrange))
+            yield 'f done'
+        def g():
+            results = []
+            x = yield f()
+            results.append(x)
+            for i in xrange(testrange-1):
+                results.append((yield))
+            yield results
+        c = compose(g())
+        self.assertEquals([range(testrange)], list(c))
+
+    def testQueueSizeExceeded(self):
+        testrange = 10 #QUEUE SIZE = 10
+        def f():
+            raise StopIteration(*xrange(testrange))
+            yield
+        def g():
+            x = yield f()
+        self.assertRaises(RuntimeError, compose(g()).next)
+
+    def testStackOverflow(self):
+        max_recursion_depth = getrecursionlimit()
+        def f(recursion_depth=1):
+            if recursion_depth < max_recursion_depth:
+                yield f(recursion_depth + 1)
+        c = compose(f())
+        try:
+            list(c)
+        except RuntimeError, e:
+            self.fail('must not raise %s' % e)
+
+        max_recursion_depth += 1 # <== 
+        c = compose(f())
+        try:
+            list(c)
+            self.fail('must raise runtimeerror')
+        except RuntimeError, e:
+            self.assertEquals('maximum recursion depth exceeded (compose)', str(e))
+
+    def testDECREF_in_compose_clear(self):
+        """A bit strange, but this triggers a bug with 
+        DECREF(<temporary>) in compose_clear()"""
+        def f():
+            msg = yield
+            raise StopIteration(*msg.split())
+
+        r = compose(f())
+        r.next()
+        try:
+            r.send("ab an")
+        except StopIteration, e:
+            self.assertEquals(('ab', 'an'), e.args)
+
+    def testSelftest(self):
+        from weightless.core.compose._compose_c import _selftest
+        _selftest()
+
+
+def gettypeerrormsg():
+    def compose(initial, arg1 = None): pass
+    try:
+        compose()
+    except TypeError, e:
+        return str(e)
+ 
diff --unidirectional-new-file '--exclude=*.so' '--exclude=*.o' '--exclude=.svn' '--exclude=*.pyc' '--exclude=deps.d' '--exclude=applied' --recursive --unified version_0/test/core/localtest.py version_0-fixes/test/core/localtest.py
--- version_0/test/core/localtest.py	1970-01-01 01:00:00.000000000 +0100
+++ version_0-fixes/test/core/localtest.py	2011-06-24 11:10:53.000000000 +0200
@@ -0,0 +1,107 @@
+## begin license ##
+#
+#    Weightless is a High Performance Asynchronous Networking Library
+#    See http://weightless.io
+#    Copyright (C) 2009-2011 Seek You Too (CQ2) http://www.cq2.nl
+#
+#    This file is part of Weightless
+#
+#    Weightless is free software; you can redistribute it and/or modify
+#    it under the terms of the GNU General Public License as published by
+#    the Free Software Foundation; either version 2 of the License, or
+#    (at your option) any later version.
+#
+#    Weightless is distributed in the hope that it will be useful,
+#    but WITHOUT ANY WARRANTY; without even the implied warranty of
+#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+#    GNU General Public License for more details.
+#
+#    You should have received a copy of the GNU General Public License
+#    along with Weightless; if not, write to the Free Software
+#    Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+#
+## end license ##
+
+from unittest import TestCase
+from weightless.core import local
+
+class LocalTest(TestCase):
+
+    def testScope(self):
+        _some_var_on_the_callstack_ = 'aap'
+        v = local('_some_var_on_the_callstack_')
+        self.assertEquals('aap', v)
+
+    def testNone(self):
+        var = None
+        self.assertEquals(None, local('var'))
+
+    def testNotFound(self):
+        try:
+            v = local('no_such_thing')
+            print "V", v
+            self.fail()
+        except AttributeError:
+            pass
+
+    def testVariousTypes(self):
+        strArgument = 'string'
+        self.assertEquals('string', local('strArgument'))
+        intArgument = 1
+        self.assertEquals(1, local('intArgument'))
+
+        class MyObject(object):
+            pass
+        objArgument = MyObject()
+        self.assertEquals(objArgument, local('objArgument'))
+
+    def testScoping(self):
+        class MyObject(object):
+            pass
+        refs = []
+        def function():
+            toplevel=MyObject()
+            refs.append(local('toplevel'))
+        function()
+        self.assertEquals(1, len(refs))
+        self.assertEquals(MyObject, type(refs[0]))
+
+    def testOne(self):
+        a=1
+        b=2
+        c=3
+        def f1():
+            d=4
+            a=10
+            b=6
+            self.assertEquals(4, local('d'))
+            self.assertEquals(10, local('a'))
+        f1()
+        self.assertEquals(2, local('b'))
+        self.assertEquals(1, local('a'))
+
+    def testWithGenerator(self):
+        results = []
+        _z_ = 9
+        def e():
+            yield
+            results.append(local('_x_'))
+            yield
+            results.append(local('_y_'))
+            yield
+            results.append(local('_z_'))
+        def f():
+            _x_ = 10
+            yield
+            _y_ = 11
+            list(e())
+        list(f())
+        self.assertEquals([10,11,9], results)
+
+    def testLookupSelfWhileBeingInitialized(self):
+        try:
+            tx = local('tx')
+            self.fail()
+        except AttributeError:
+            pass
+
diff --unidirectional-new-file '--exclude=*.so' '--exclude=*.o' '--exclude=.svn' '--exclude=*.pyc' '--exclude=deps.d' '--exclude=applied' --recursive --unified version_0/test/core/observabledirectedmessagingtest.py version_0-fixes/test/core/observabledirectedmessagingtest.py
--- version_0/test/core/observabledirectedmessagingtest.py	1970-01-01 01:00:00.000000000 +0100
+++ version_0-fixes/test/core/observabledirectedmessagingtest.py	2011-06-24 11:10:53.000000000 +0200
@@ -0,0 +1,98 @@
+from unittest import TestCase
+
+from weightless.core import Observable
+
+class ObservableDirectedMessagingTest(TestCase):
+
+    def testDirectedObserverMessagingDoesNotBreakUndirectedCall(self):
+        observable = Observable()
+        called = []
+        class A(Observable):
+            def method(this):
+                called.append("A")
+        observable.addObserver(A("name"))
+
+        list(observable.all["name"].method())
+        
+        self.assertEquals(["A"], called)
+
+    def testDirectedObserverMessagingIgnoresNonObservableObservers(self):
+        observable = Observable()
+        called = []
+        class Z(object):
+            def method(this):
+                called.append("Z")
+        observable.addObserver(Z())
+
+        list(observable.all["name"].method())
+        
+        self.assertEquals([], called)
+
+        list(observable.all.method())
+
+        self.assertEquals(["Z"], called)
+
+    def testDirectedMessagesCanAlsoBeAcceptedByObjects(self):
+        observable = Observable()
+        called = []
+        class Y(object):
+            def method(this):
+                called.append("Y")
+            def observable_name(this):
+                return 'name'
+        class Z(object):
+            def method(this):
+                called.append("Z")
+        observable.addObserver(Y())
+        observable.addObserver(Z())
+
+        list(observable.all["name"].method())
+        
+        self.assertEquals(['Y'], called)
+
+        del called[:]
+
+        list(observable.all.method())
+
+        self.assertEquals(['Y', "Z"], called)
+
+        del called[:]
+
+        list(observable.all["other"].method())
+
+        self.assertEquals([], called)
+
+
+    def testUndirectedObserverMessagingIsUnaffectedByObserverName(self):
+        observable = Observable()
+        called = []
+        class A(Observable):
+            def method(this):
+                called.append(("A", this.observable_name()))
+        
+        class B(Observable):
+            def method(this):
+                called.append(("B", this.observable_name()))
+
+        observable.addObserver(A("name"))
+        observable.addObserver(A().observable_setName("anothername"))
+        observable.addObserver(B("anothername"))
+        observable.addObserver(B())
+
+        list(observable.all.method())
+        
+        self.assertEquals([("A", "name"), 
+            ("A", "anothername"), 
+            ("B", "anothername"), 
+            ("B", None)], called)
+        del called[:]
+
+        list(observable.all["name"].method())
+        self.assertEquals([("A", "name")], called)
+
+    def testSetName(self):
+        observable = Observable().observable_setName('name')
+        self.assertEquals('name', observable.observable_name())
+
+
+    # observable_setName('name')
diff --unidirectional-new-file '--exclude=*.so' '--exclude=*.o' '--exclude=.svn' '--exclude=*.pyc' '--exclude=deps.d' '--exclude=applied' --recursive --unified version_0/test/core/observabletest.py version_0-fixes/test/core/observabletest.py
--- version_0/test/core/observabletest.py	1970-01-01 01:00:00.000000000 +0100
+++ version_0-fixes/test/core/observabletest.py	2011-06-24 11:10:53.000000000 +0200
@@ -0,0 +1,686 @@
+# -*- coding: utf-8 -*-
+## begin license ##
+#
+#    Meresco Core is an open-source library containing components to build
+#    searchengines, repositories and archives.
+#    Copyright (C) 2007-2011 Seek You Too (CQ2) http://www.cq2.nl
+#    Copyright (C) 2007-2009 SURF Foundation. http://www.surf.nl
+#    Copyright (C) 2007-2009 Stichting Kennisnet Ict op school.
+#       http://www.kennisnetictopschool.nl
+#    Copyright (C) 2007 SURFnet. http://www.surfnet.nl
+#    Copyright (C) 2010 Stichting Kennisnet http://www.kennisnet.nl
+#
+#    This file is part of Meresco Core.
+#
+#    Meresco Core is free software; you can redistribute it and/or modify
+#    it under the terms of the GNU General Public License as published by
+#    the Free Software Foundation; either version 2 of the License, or
+#    (at your option) any later version.
+#
+#    Meresco Core is distributed in the hope that it will be useful,
+#    but WITHOUT ANY WARRANTY; without even the implied warranty of
+#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+#    GNU General Public License for more details.
+#
+#    You should have received a copy of the GNU General Public License
+#    along with Meresco Core; if not, write to the Free Software
+#    Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+#
+## end license ##
+
+import gc
+from sys import exc_info
+from traceback import format_tb
+from inspect import isframe, getframeinfo
+from types import GeneratorType
+from weightless.core import compose, Observable, Transparant, be, tostring
+from weightless.core._observable import AllMessage, AnyMessage, DoMessage, OnceMessage, DeferredMessage, AsyncanyMessage, AsyncdoMessage
+from calltrace import CallTrace
+from unittest import TestCase
+
+class Interceptor(Observable):
+    def unknown(self, message, *args, **kwargs):
+        self.message = message
+        self.args = args
+        self.kwargs = kwargs
+
+class ObservableTest(TestCase):
+
+    def testTransparentUnknownWithAny(self):
+        class A(Observable):
+            def a(self):
+                return self.any.c()
+        class B1(Observable):
+            def unknown(self, message, *args, **kwargs):
+                return self.all.unknown(message, *args, **kwargs)
+        class B2(Observable):
+            def unknown(self, message, *args, **kwargs):
+                return self.all.unknown(message, *args, **kwargs)
+        class C(object):
+            def c(self):
+                return (ch for ch in 'see')
+        a = A()
+        b1 = B1()
+        b2 = B2()
+        c = C()
+        a.addObserver(b1)
+        b1.addObserver(b2)
+        b2.addObserver(c)
+        self.assertEquals('see', ''.join(a.a()))
+        del a, b1, b2, c
+
+    def testObserverInit(self):
+        initcalled = [0]
+        class MyObserver(object):
+            def observer_init(self):
+                initcalled[0] += 1
+        root = be((Observable(), (MyObserver(),)))
+        root.once.observer_init()
+        self.assertEquals([1], initcalled)
+
+    def testAllWithoutImplementers(self):
+        observable = Observable()
+        responses = observable.all.someMethodNobodyIsListeningTo()
+        self.assertEquals(GeneratorType, type(responses))
+
+    def testAllWithMoreImplementers(self):
+        observable = Observable()
+        observerOne = CallTrace(returnValues={'aMethod': 'one'})
+        observerTwo = CallTrace(returnValues={'aMethod': 'two'})
+        root = be((observable, (observerOne,), (observerTwo,)))
+        responses = root.all.aMethod()
+        self.assertEquals(GeneratorType, type(responses))
+        self.assertEquals(['one', 'two'], list(responses))
+
+    def testAnyCallsFirstImplementer(self):
+        observable = Observable()
+        observerA = ObserverA()
+        observerAB = ObserverAB()
+        root = be((observable, (observerA,), (observerAB,)))
+        resultA = root.any.methodA(0)
+        resultB = root.any.methodB(1, 2)
+        self.assertEquals([("Method A", (0,))], observerA.notifications)
+        self.assertEquals([("Method B", (1, 2))], observerAB.notifications)
+        self.assertEquals("A.methodA", resultA)
+        self.assertEquals("AB.methodB", resultB)
+
+    def testAnyCallsFirstImplementerNotReturningNone(self):
+        class A(object):
+            def do(self, x):
+                if x == 1: return 'A'
+        class B(object):
+            def do(self, x):
+                if x == 2: return 'B'
+        root = be((Observable(), (A(),), (B(),)))
+        result = root.any.do(1)
+        self.assertEquals('A', result)
+        result = root.any.do(2)
+        self.assertEquals('B', result)
+
+    def testAllException(self):
+        observable = Observable()
+        class ExceptionRaiser(MockObserver):
+            def mayRaiseException(self, *args):
+                raise TestException
+        class Safe(MockObserver):
+            def mayRaiseException(self, *args):
+                self.notifications.append(("mayRaiseException", args))
+        observable.addObserver(ExceptionRaiser())
+        safe = Safe()
+        observable.addObserver(safe)
+        try:
+            list(observable.all.mayRaiseException())
+            self.fail()
+        except TestException:
+            pass
+        self.assertEquals([], safe.notifications)
+
+    def testDo(self):
+        observable = Observable()
+        retvalIsAlwaysNone = observable.do.oneWayMethodWithoutReturnValue()
+        self.assertEquals(None, retvalIsAlwaysNone)
+        observer = CallTrace("Observer")
+        observer.something = lambda x,y: x.append(y)
+        observable.addObserver(observer)
+        value = []
+        observable.do.something(value, 1)
+        self.assertEquals([1], value)
+
+    def testAsyncdoReturnsGenerator(self):
+        observable = Observable()
+        retval = observable.asyncdo.oneWayMethodWithoutReturnValue()
+        self.assertRaises(StopIteration, retval.next)
+
+    def testAsyncdoEmptyGenerator(self):
+        observable = Observable()
+        called=[]
+        class Listener(object):
+            def message(this):
+                yield 'a'
+                called.append(True)
+                yield 'b'
+        observable.addObserver(Listener())
+        retval = observable.asyncdo.message()
+        self.assertRaises(StopIteration, retval.next)
+        self.assertEquals([True], called)
+
+    def testAsyncdoYieldsCallables(self):
+        observable = Observable()
+        called=[]
+        def callable():
+            pass
+        class Listener(object):
+            def message(this):
+                yield 'a'
+                yield callable
+                yield 'b'
+                called.append(True)
+        observable.addObserver(Listener())
+        retval = observable.asyncdo.message()
+        self.assertEquals(callable, retval.next())
+        self.assertRaises(StopIteration, retval.next)
+        self.assertEquals([True], called)
+
+    def testAsyncAnyNoSuchMessage(self):
+        observable = Observable()
+        try:
+            observable.asyncany.notExisting().next()
+            self.fail('fail')
+        except AttributeError, e:
+            self.assertEquals('None of the 0 observers responds to asyncany.notExisting(...)', str(e))
+
+    def testAsyncAny2(self):
+        observable = Observable()
+        done = []
+        def callable():
+            pass
+        class Caller(Observable):
+            def useasyncany(this):
+                result = yield this.asyncany.message()
+                self.assertEquals("the answer", result)
+                yield
+        class Listener(object):
+            def message(this):
+                yield callable
+                done.append(0)
+                raise StopIteration("the answer")
+        caller = Caller()
+        caller.addObserver(Listener())
+        observable.addObserver(caller)
+        generator = compose(observable.all.useasyncany())
+        self.assertEquals(callable, generator.next())
+        retval = generator.next()
+        self.assertEquals([0], done)
+ 
+    def testAddStrandEmptyList(self):
+        observable = Observable()
+        observable.addStrand((), [])
+        self.assertEquals([], observable._observers)
+
+    def testBeOne(self):
+        observer = CallTrace()
+        root = be((observer,))
+        self.assertEquals(root, observer)
+
+    def testBeTwo(self):
+        observable = Observable()
+        child0 = Observable()
+        child1 = Observable()
+        root = be((observable, (child0,), (child1,)))
+        self.assertEquals([child0, child1], observable._observers)
+
+    def testBeTree(self):
+        observable = Observable()
+        child0 = Observable(name='child0')
+        child1 = Observable(name='child1')
+        strand = (observable, (child0, (child1,)))
+        root = be(strand)
+        self.assertEquals([child0], root._observers)
+        self.assertEquals([child1], child0._observers)
+
+    def testBeToExplainTheIdeaWhithoutTestingSomethingNew(self):
+        observable = Observable()
+        child0 = Observable(name='child0')
+        child1 = Observable(name='child1')
+        child2 = Observable(name='child2')
+        tree = (observable, (child0, (child1, (child2,))))
+        root = be(tree)
+        self.assertEquals([child0], observable._observers)
+        self.assertEquals([child1], child0._observers)
+        self.assertEquals([child2], child1._observers)
+
+    def testAny(self):
+        class A(Observable):
+            def myThing(self):
+                return self.any.myThing()
+        class B(Observable):
+            def myThing(self):
+                yield "data"
+        a = A()
+        b = B()
+        a.addObserver(b)
+        self.assertEquals(GeneratorType, type(a.any.myThing()))
+        self.assertEquals(["data"], list(a.any.myThing()))
+
+    def testAllUnknown(self):
+        class Interceptor(Observable):
+            def unknown(self, message, *args, **kwargs):
+                self.message = message
+                self.args = args
+                self.kwargs = kwargs
+        interceptor = Interceptor()
+        root = Observable()
+        root.addObserver(interceptor)
+        list(root.all.anUnknownMessage('with', unknown='arguments'))
+
+        self.assertEquals('anUnknownMessage', interceptor.message)
+        self.assertEquals(('with',), interceptor.args)
+        self.assertEquals({'unknown': 'arguments'}, interceptor.kwargs)
+
+    def testUnknownDispatchingNoImplementation(self):
+        observable = Observable()
+        class Listener(object):
+            pass
+        observable.addObserver(Listener())
+        retval = observable.all.unknown('non_existing_method', 'one')
+        self.assertEquals([], list(retval))
+
+    def testUnknownDispatching(self):
+        observable = Observable()
+        class Listener(object):
+            def method(inner, one):
+                return one + " another"
+        observable.addObserver(Listener())
+        retval = observable.any.unknown('method', 'one')
+        self.assertEquals('one another', retval)
+
+    def testUnknownDispatchingBackToUnknown(self):
+        observable = Observable()
+        class Listener(object):
+            def unknown(self, methodName, one):
+                return ("via unknown " + one for x in [1])
+        observable.addObserver(Listener())
+        retval = observable.any.unknown('non_existing_method', 'one')
+        self.assertEquals("via unknown one", retval)
+
+    def testUnknownIsEquivalentToNormalCall(self):
+        observable = Observable()
+        class Listener(object):
+            def normal(self):
+                return 'normal'
+            def unknown(self, message, *args, **kwargs):
+                yield self.normal()
+        observable.addObserver(Listener())
+        result1 = observable.any.unknown('normal')
+        result2 = observable.any.unknown('other')
+        self.assertEquals(result1, result2)
+
+    def testSyntacticSugarIsPreserved(self):
+        class WithUnknown(Observable):
+            def unknown(self, methodName, *args):
+                return self.all.unknown(methodName, "extra arg", *args)
+
+        observer = CallTrace("Observer")
+
+        withUnknown = WithUnknown()
+        withUnknown.addObserver(observer)
+
+        source = Observable()
+        source.addObserver(withUnknown)
+        source.do.someMethod("original arg")
+        #if syntactic sugar (i.e. "do") is preseverd, it would force the call self.all.unknown directly
+        self.assertEquals(1, len(observer.calledMethods))
+        self.assertEquals("someMethod('extra arg', 'original arg')", str(observer.calledMethods[0]))
+
+    def testProperErrorMessage(self):
+        observable = Observable()
+        try:
+            answer = observable.any.gimmeAnswer('please')
+            self.fail('shoud raise AttributeError')
+        except AttributeError, e:
+            self.assertEquals('None of the 0 observers responds to any.gimmeAnswer(...)', str(e))
+
+    def testProperErrorMessageWhenArgsDoNotMatch(self):
+        from traceback import print_exc
+        observable = Observable()
+        class YesObserver:
+            def yes(self, oneArg): pass
+        observable.addObserver(YesObserver())
+        try:
+            answer = observable.any.yes()
+            self.fail('shoud raise AttributeError')
+        except TypeError, e:
+            self.assertEquals('yes() takes exactly 2 arguments (1 given)', str(e))
+
+    def testNestedAllWithDoOnlyExecutesTheHighestLevelCalls(self):
+        done = []
+        class A(Observable):
+            def a(this):
+                done.append('A')
+                return this.all.a()
+        class B(Observable):
+            def a(this):
+                done.append('B')
+                return this.all.a()
+        class C(Observable):
+            def a(this):
+                done.append('C')
+                self.done = True
+        t = be((Observable(),
+                    (A(),
+                        (B(),
+                            (C(),)
+                        )
+                    )
+                ))
+        result = t.do.a()
+        self.assertEquals(None, result)
+        self.assertEquals(['A'], done)
+
+    def testFixUpExceptionTraceBack(self):
+        class A:
+            def a(self):
+                raise Exception('A.a')
+            def unknown(self, msg, *args, **kwargs):
+                yield self.a()
+        observable = Observable()
+        observable.addObserver(A())
+        try:
+            observable.any.a()
+        except Exception:
+            self.assertFunctionsOnTraceback("testFixUpExceptionTraceBack", "a")
+        try:
+            list(observable.all.a())
+        except Exception:
+            self.assertFunctionsOnTraceback("testFixUpExceptionTraceBack", "a")
+
+        try:
+            observable.do.a()
+        except Exception:
+            self.assertFunctionsOnTraceback("testFixUpExceptionTraceBack", "a")
+
+        try:
+            list(observable.asyncdo.a())
+        except Exception:
+            self.assertFunctionsOnTraceback("testFixUpExceptionTraceBack", "a")
+
+        try:
+            observable.any.unknown('a')
+        except Exception:
+            self.assertFunctionsOnTraceback("testFixUpExceptionTraceBack", "a")
+
+        try:
+            observable.any.somethingNotThereButHandledByUnknown('a')
+        except Exception:
+            self.assertFunctionsOnTraceback("testFixUpExceptionTraceBack", "unknown", "a")
+
+    def assertFunctionsOnTraceback(self, *args):
+        na, na, tb = exc_info()
+        for functionName in args:
+            self.assertEquals(functionName, tb.tb_frame.f_code.co_name)
+            tb = tb.tb_next
+        self.assertEquals(None, tb)
+
+    def testMoreElaborateExceptionCleaning(self):
+        class A(Observable):
+            def a(self): return self.any.b()
+        class B(Observable):
+            def b(self): return self.any.c()
+        class C(Observable):
+            def c(self): return self.any.d()
+        class D:
+            def d(self): raise Exception('D.d')
+        a = A()
+        b = B()
+        c = C()
+        a.addObserver(b)
+        b.addObserver(c)
+        c.addObserver(D())
+        try:
+            a.a()
+            self.fail('should raise exception')
+        except:
+            self.assertFunctionsOnTraceback("testMoreElaborateExceptionCleaning", "a", "b", "c", "d")
+
+    def testAddObserversOnce(self):
+        class  MyObservable(Observable):
+            pass
+        o1 = MyObservable(name='O1')
+        o2 = MyObservable(name='O2')
+        o3 = MyObservable(name='O3')
+        o4 = MyObservable(name='O4')
+        o5 = MyObservable(name='O5')
+        helix = \
+            (o1,
+                (o2, )
+            )
+        dna =   (o3,
+                    helix,
+                    (o4,),
+                    (o5, helix)
+                 )
+        root = be(dna)
+        self.assertEquals([o2], o1._observers)
+        self.assertEquals([], o2._observers)
+        self.assertEquals([o1, o4, o5], o3._observers)
+        self.assertEquals([], o4._observers)
+        self.assertEquals([o1], o5._observers)
+
+    def testResolveCallStackVariables(self):
+        class StackVarHolder(Observable):
+            def unknown(self, name, *args, **kwargs):
+                __callstack_var_myvar__ = []
+                for result in self.all.unknown(name, *args, **kwargs):
+                    pass
+                yield __callstack_var_myvar__
+
+        class StackVarUser(Observable):
+            def useVariable(self):
+                self.ctx.myvar.append('Thingy')
+
+        dna = \
+            (Observable(),
+                (StackVarHolder(),
+                    (StackVarUser(),)
+                )
+            )
+        root = be(dna)
+        self.assertEquals(['Thingy'], root.any.useVariable())
+
+    def testOnceAndOnlyOnce(self):
+        class MyObserver(Observable):
+            def methodOnlyCalledOnce(self, aList):
+                aList.append('once')
+        once = MyObserver()
+        dna = \
+            (Observable(),
+                (once,),
+                (once,)
+            )
+        root = be(dna)
+        collector = []
+        root.once.methodOnlyCalledOnce(collector)
+        self.assertEquals(['once'], collector)
+
+    def testOnceInDiamondWithTransparant(self):
+        class MyObserver(Observable):
+            def methodOnlyCalledOnce(self, aList):
+                aList.append('once')
+        once = MyObserver()
+        diamond = \
+            (Transparant(),
+                (Transparant(),
+                    (once,)
+                ),
+                (Transparant(),
+                    (once,)
+                )
+            )
+        root = be(diamond)
+        collector = []
+        root.once.methodOnlyCalledOnce(collector)
+        self.assertEquals(['once'], collector)
+
+    def testPropagateThroughAllObservablesInDiamondWithNONTransparantObservablesWithoutUnknownMethodDelegatingUnknownCalls(self):
+        class MyObserver(Observable):
+            def methodOnlyCalledOnce(self, aList):
+                aList.append('once')
+        once = MyObserver()
+        diamond = \
+            (Observable(),
+                (Observable(),
+                    (once,)
+                ),
+                (Observable(),
+                    (once,)
+                )
+            )
+        root = be(diamond)
+        collector = []
+        root.once.methodOnlyCalledOnce(collector)
+        self.assertEquals(['once'], collector)
+
+    def testNonObservableInTreeWithOnce(self):
+        class MyObserver(object):
+            def methodOnNonObservableSubclass(self, aList):
+                aList.append('once')
+        once = MyObserver()
+        dna =   (Observable(),
+                    (once,)
+                )
+        root = be(dna)
+        collector = []
+        root.once.methodOnNonObservableSubclass(collector)
+        self.assertEquals(['once'], collector)
+
+    def testOnceAndOnlyOnceForMutuallyObservingObservables(self):
+        class MyObserver(Observable):
+            def methodOnlyCalledOnce(self, aList):
+                aList.append(self)
+        ownobserverobserver = MyObserver()
+        dna = \
+            (Observable(),
+                (ownobserverobserver,
+                    (Observable("observer"),
+                        (ownobserverobserver,),
+                    )
+                )
+            )
+        root = be(dna)
+        collector = []
+        root.once.methodOnlyCalledOnce(collector)
+        self.assertEquals([ownobserverobserver], collector)
+
+    def testNoLeakingGeneratorsInCycle(self):
+
+        class Responder(Observable):
+            def message(self):
+                return 'response'
+        obs = Observable()
+        obs.addObserver(Responder())
+        result = obs.all.message().next()
+        self.assertEquals('response',result)
+        del obs
+
+    def testNoLeakingGeneratorsInMultiTransparants(self):
+        class Responder(Observable):
+            def message(self):
+                return 'response'
+        obs = Observable()
+        t1 = Transparant()
+        t2 = Transparant()
+        obs.addObserver(t1)
+        t1.addObserver(t2)
+        t2.addObserver(Responder())
+        result = obs.any.message()
+        self.assertEquals('response', result)
+        del obs, t1, t2, result
+
+    def testMatchingBasedOnDefaultArgs(self):
+        class A(object):
+            def a(x, y=10, z=11):
+                p = 1
+                q = 2
+                yield
+        a = A()
+        func = a.a
+        code = func.func_code
+        func_defaults = func.func_defaults
+        self.assertEquals((10,11), func_defaults)
+        argcount = code.co_argcount
+        self.assertEquals(3, argcount)
+        varnames = code.co_varnames
+        self.assertEquals(('x', 'y', 'z', 'p', 'q'), varnames)
+        argnames = varnames[:argcount]
+        self.assertEquals(('x','y','z'), argnames)
+        kwargsnames = argnames[-len(func_defaults):]
+        self.assertEquals(('y','z'), kwargsnames)
+        kwargdefaults = dict(zip(kwargsnames, func_defaults))
+        self.assertEquals({'y':10, 'z':11}, kwargdefaults)
+        self.assertEquals({'z':11, 'y':10}, kwargdefaults)
+        func.__dict__['kwargdefaults'] = kwargdefaults
+        self.assertEquals({'z':11, 'y':10}, func.kwargdefaults)
+
+        class Wildcard(object):
+            def __eq__(self, other):
+                return True
+        self.assertTrue({'z':11, 'y':10} == {'z':11, 'y': Wildcard()})
+
+    def get_tracked_objects(self):
+        return [o for o in gc.get_objects() if type(o) in 
+                (compose, GeneratorType, Exception,
+                    AllMessage, AnyMessage, DoMessage, OnceMessage, DeferredMessage,
+                    AsyncdoMessage, AsyncanyMessage)]
+ 
+    def setUp(self):
+        gc.collect()
+        self._baseline = self.get_tracked_objects()
+
+    def tearDown(self):
+        def tostr(o):
+            if isframe(o):
+                return getframeinfo(o)
+            try:
+                return tostring(o)
+            except:
+                return repr(o)
+        gc.collect()
+        diff = set(self.get_tracked_objects()) - set(self._baseline)
+        #self.assertEquals(set(), diff)
+        #for obj in diff:
+        #    print "Leak:"
+        #    print tostr(obj)
+        #    print "Referrers:"
+        #    for o in  gc.get_referrers(obj):
+        #        print tostr(o)
+        del self._baseline
+
+
+class TestException(Exception):
+    pass
+
+class MockObserver:
+
+    def __init__(self):
+        self.notifications = []
+
+class ObserverA(MockObserver):
+
+    def methodA(self, *args):
+        self.notifications.append(("Method A", args))
+        return "A.methodA"
+
+class ObserverAB(MockObserver):
+
+    def methodA(self, *args):
+        self.notifications.append(("Method A", args))
+        return "AB.methodA"
+
+    def methodB(self, *args):
+        self.notifications.append(("Method B", args))
+        return "AB.methodB"
+
+class DoesNotReturn(MockObserver):
+
+    def methodA(self, *args):
+        self.notifications.append(("Method A", args))
diff --unidirectional-new-file '--exclude=*.so' '--exclude=*.o' '--exclude=.svn' '--exclude=*.pyc' '--exclude=deps.d' '--exclude=applied' --recursive --unified version_0/test/core/sidekicktest.py version_0-fixes/test/core/sidekicktest.py
--- version_0/test/core/sidekicktest.py	1970-01-01 01:00:00.000000000 +0100
+++ version_0-fixes/test/core/sidekicktest.py	2011-06-24 11:10:53.000000000 +0200
@@ -0,0 +1,104 @@
+## begin license ##
+#
+#    Weightless is a High Performance Asynchronous Networking Library
+#    See http://weightless.io
+#    Copyright (C) 2010-2011 Seek You Too (CQ2) http://www.cq2.nl
+#
+#    This file is part of Weightless
+#
+#    Weightless is free software; you can redistribute it and/or modify
+#    it under the terms of the GNU General Public License as published by
+#    the Free Software Foundation; either version 2 of the License, or
+#    (at your option) any later version.
+#
+#    Weightless is distributed in the hope that it will be useful,
+#    but WITHOUT ANY WARRANTY; without even the implied warranty of
+#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+#    GNU General Public License for more details.
+#
+#    You should have received a copy of the GNU General Public License
+#    along with Weightless; if not, write to the Free Software
+#    Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+#
+## end license ##
+from unittest import TestCase
+from weightless.core import compose
+from sys import exc_info
+
+class SidekickTest(TestCase):
+
+    def testCallCallableWithSidekick(self):
+        called = []
+        def command(sidekick):
+            called.append(sidekick)
+        def f():
+            yield 'a'
+            yield command
+            yield 'b'
+
+        c = compose(f(), sidekick="sidekick")
+        result = list(c)
+        self.assertEquals(['a', 'b'], result)
+        self.assertEquals(["sidekick"], called)
+
+
+    def testCallableIsTransparent(self):
+        data = []
+        called = []
+        def command(sidekick):
+            called.append(sidekick)
+        def f():
+            a = yield None
+            data.append(a)
+            yield command
+            b = yield None
+            data.append(b)
+            yield
+
+        c = compose(f(), sidekick="sidekick")
+        none = c.send(None)
+        self.assertEquals(None, none)
+        none = c.send('a')
+        self.assertEquals(None, none)
+        none = c.send('b')
+        self.assertEquals(None, none)
+        self.assertEquals(['a', 'b'], data)
+        self.assertEquals(['sidekick'], called)
+
+    def testCallableRaisesException(self):
+        def command(sidekick):
+            raise RuntimeError("runtimeError")
+        def f():
+            yield command
+        c = compose(f(), sidekick="sidekick")
+        try:
+            c.next()
+            self.fail()
+        except RuntimeError, e:
+            self.assertEquals("runtimeError", str(e))
+
+    def testCallableRaisesExceptionWhichIsCatchableByGenerators(self):
+        def command(sidekick):
+            raise RuntimeError("runtimeError")
+        def f():
+            try:
+                yield command
+            except RuntimeError, e:
+                yield str(e)
+        c = compose(f(), sidekick="sidekick")
+        self.assertEquals("runtimeError", c.next())
+
+    def testProperTracebackForCallable(self):
+        def command(sidekick):
+            raise RuntimeError("runtimeError")
+        def f():
+            yield command
+        c = compose(f(), sidekick="sidekick")
+        try:
+            c.next()
+            self.fail()
+        except RuntimeError, e:
+            exType, exValue, exTraceback = exc_info()
+            self.assertEquals('testProperTracebackForCallable', exTraceback.tb_frame.f_code.co_name)
+            self.assertEquals('f', exTraceback.tb_next.tb_frame.f_code.co_name)
+            self.assertEquals('command', exTraceback.tb_next.tb_next.tb_frame.f_code.co_name)
