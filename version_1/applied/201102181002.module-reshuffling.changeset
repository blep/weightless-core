Changeset created on Fri Feb 18 10:02:59 CET 2011 by Seek You Too

Description: Splits Weightless 0.4.x into core, io and http modules. Adds C-extension.

    Extracts the more stable components like core as to enable independend development. Also adds the C-extension to improve performance.

Baseline version: https://weightless.svn.sourceforge.net/svnroot/weightless/weightless-core/workingsets/0.5-CQ2/version_0

diff --unidirectional-new-file '--exclude=*.so' '--exclude=*.o' '--exclude=.svn' '--exclude=*.pyc' '--exclude=deps.d' '--exclude=applied' --recursive --unified version_0/doc/make_ssl_cert.sh version_1/doc/make_ssl_cert.sh
--- version_0/doc/make_ssl_cert.sh	2011-02-12 11:50:45.000000000 +0100
+++ version_1/doc/make_ssl_cert.sh	2011-02-15 08:48:29.000000000 +0100
@@ -1,5 +1,27 @@
 #!/bin/bash
-
+## begin license ##
+#
+#    Weightless is a High Performance Asynchronous Networking Library
+#    See http://weightless.io
+#    Copyright (C) 2009-2011 Seek You Too (CQ2) http://www.cq2.nl
+#
+#    This file is part of Weightless
+#
+#    Weightless is free software; you can redistribute it and/or modify
+#    it under the terms of the GNU General Public License as published by
+#    the Free Software Foundation; either version 2 of the License, or
+#    (at your option) any later version.
+#
+#    Weightless is distributed in the hope that it will be useful,
+#    but WITHOUT ANY WARRANTY; without even the implied warranty of
+#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+#    GNU General Public License for more details.
+#
+#    You should have received a copy of the GNU General Public License
+#    along with Weightless; if not, write to the Free Software
+#    Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+#
+## end license ##
 
 if [ "$1" != "" ];
 then
diff --unidirectional-new-file '--exclude=*.so' '--exclude=*.o' '--exclude=.svn' '--exclude=*.pyc' '--exclude=deps.d' '--exclude=applied' --recursive --unified version_0/setup.py version_1/setup.py
--- version_0/setup.py	2011-02-12 11:50:45.000000000 +0100
+++ version_1/setup.py	2011-02-15 08:48:32.000000000 +0100
@@ -1,7 +1,9 @@
+#!/usr/bin/env python2.5
 ## begin license ##
 #
 #    Weightless is a High Performance Asynchronous Networking Library
-#    Copyright (C) 2006-2009 Seek You Too (CQ2) http://www.cq2.nl
+#    See http://weightless.io
+#    Copyright (C) 2006-2011 Seek You Too (CQ2) http://www.cq2.nl
 #
 #    This file is part of Weightless
 #
@@ -21,29 +23,31 @@
 #
 ## end license ##
 from distutils.core import setup
-from platform import python_version
+from distutils.extension import Extension
 
-setupArgs = {
-    'name': 'weightless',
-    'version': '%VERSION%',
-    'url': 'http://www.weightless.io',
-    'author': 'Seek You Too',
-    'author_email': 'info@cq2.nl',
-    'description': 'Weightless is a High Performance Asynchronous Networking Library.',
-    'long_description': 'Weightless is a High Performance Asynchronous Networking Library.',
-    'license': 'GNU Public License',
-    'platforms': 'all'
-}
-
-if python_version() >= '2.5':
-    setup(
-        packages=['weightless', 'weightless.python2_5', 'weightless.http', 'weightless.utils'],
-        **setupArgs
-    )
-
-else:
-    setup(
-        packages=['weightless', 'weightless.http'],
-        **setupArgs
-    )
+setup(
+    name='weightless-core',
+    version='%VERSION%',
+    packages=[
+        'weightless', 
+        'weightless.core', 
+        'weightless.core.compose', 
+        'weightless.core.utils',
+        'weightless.http', 
+        'weightless.io',
+    ],
+    url='http://www.weightless.io',
+    author='Seek You Too',
+    author_email='info@cq2.nl',
+    description='Weightless is a High Performance Asynchronous Networking Library.',
+    long_description='Weightless is a High Performance Asynchronous Networking Library.',
+    license='GNU Public License',
+    platforms=['linux'],
+    ext_modules=[
+        Extension("weightless.core.compose._compose_c", [
+            "weightless/core/compose/_compose.c"
+            ]
+        )
+    ]
+)
 
Only in version_0/test: acceptortest.py
diff --unidirectional-new-file '--exclude=*.so' '--exclude=*.o' '--exclude=.svn' '--exclude=*.pyc' '--exclude=deps.d' '--exclude=applied' --recursive --unified version_0/test/_alltests.py version_1/test/_alltests.py
--- version_0/test/_alltests.py	1970-01-01 01:00:00.000000000 +0100
+++ version_1/test/_alltests.py	2011-02-15 08:48:29.000000000 +0100
@@ -0,0 +1,57 @@
+#!/usr/bin/env python2.5
+## begin license ##
+#
+#    Weightless is a High Performance Asynchronous Networking Library
+#    See http://weightless.io
+#    Copyright (C) 2006-2011 Seek You Too (CQ2) http://www.cq2.nl
+#
+#    This file is part of Weightless
+#
+#    Weightless is free software; you can redistribute it and/or modify
+#    it under the terms of the GNU General Public License as published by
+#    the Free Software Foundation; either version 2 of the License, or
+#    (at your option) any later version.
+#
+#    Weightless is distributed in the hope that it will be useful,
+#    but WITHOUT ANY WARRANTY; without even the implied warranty of
+#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+#    GNU General Public License for more details.
+#
+#    You should have received a copy of the GNU General Public License
+#    along with Weightless; if not, write to the Free Software
+#    Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+#
+## end license ##
+
+from os import getuid
+assert getuid() != 0, "Do not run tests as 'root'"
+
+from os import system                             #DO_NOT_DISTRIBUTE
+from sys import path as sysPath                   #DO_NOT_DISTRIBUTE
+system('find .. -name "*.pyc" | xargs rm -f')     #DO_NOT_DISTRIBUTE
+                                                  #DO_NOT_DISTRIBUTE
+from glob import glob                             #DO_NOT_DISTRIBUTE
+for path in glob('../deps.d/*'):                  #DO_NOT_DISTRIBUTE
+    sysPath.insert(0, path)                       #DO_NOT_DISTRIBUTE
+sysPath.insert(0,'..')                            #DO_NOT_DISTRIBUTE
+
+from unittest import main
+
+from composetest import ComposePyTest
+from composetest import ComposeCTest
+from localtest import LocalTest
+from sidekicktest import SidekickTest
+from reactortest import ReactorTest
+from servertestcasetest import ServerTestCaseTest
+from snaketest import SnakeTest
+
+from http.acceptortest import AcceptorTest
+from http.httpreadertest import HttpReaderTest
+from http.httpservertest import HttpServerTest
+from http.httpspectest import HttpSpecTest
+from http.httpsservertest import HttpsServerTest
+from http.suspendtest import SuspendTest
+from http.asyncreadertest import AsyncReaderTest
+
+if __name__ == '__main__':
+    main()
Only in version_0/test: alltests.py
diff --unidirectional-new-file '--exclude=*.so' '--exclude=*.o' '--exclude=.svn' '--exclude=*.pyc' '--exclude=deps.d' '--exclude=applied' --recursive --unified version_0/test/alltests.sh version_1/test/alltests.sh
--- version_0/test/alltests.sh	1970-01-01 01:00:00.000000000 +0100
+++ version_1/test/alltests.sh	2011-02-15 08:48:29.000000000 +0100
@@ -0,0 +1,38 @@
+#!/bin/bash
+## begin license ##
+#
+#    Weightless is a High Performance Asynchronous Networking Library
+#    See http://weightless.io
+#    Copyright (C) 2011 Seek You Too (CQ2) http://www.cq2.nl
+#
+#    This file is part of Weightless
+#
+#    Weightless is free software; you can redistribute it and/or modify
+#    it under the terms of the GNU General Public License as published by
+#    the Free Software Foundation; either version 2 of the License, or
+#    (at your option) any later version.
+#
+#    Weightless is distributed in the hope that it will be useful,
+#    but WITHOUT ANY WARRANTY; without even the implied warranty of
+#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+#    GNU General Public License for more details.
+#
+#    You should have received a copy of the GNU General Public License
+#    along with Weightless; if not, write to the Free Software
+#    Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+#
+## end license ##
+
+export LANG=en_US.UTF-8
+export PYTHONPATH=.:"$PYTHONPATH"
+option=$1                                                  #DO_NOT_DISTRIBUTE
+if [ "$option" == "--python" ]; then                       #DO_NOT_DISTRIBUTE
+    shift                                                  #DO_NOT_DISTRIBUTE
+WEIGHTLESS_COMPOSE_TEST=PYTHON python2.5 _alltests.py "$@" #DO_NOT_DISTRIBUTE
+elif [ "$option" == "--c" ]; then                          #DO_NOT_DISTRIBUTE
+    shift                                                  #DO_NOT_DISTRIBUTE
+python2.5 _alltests.py "$@"                                #DO_NOT_DISTRIBUTE
+else                                                       #DO_NOT_DISTRIBUTE
+WEIGHTLESS_COMPOSE_TEST=PYTHON python2.5 _alltests.py "$@" #DO_NOT_DISTRIBUTE
+python2.5 _alltests.py "$@"
+fi                                                         #DO_NOT_DISTRIBUTE
Only in version_0/test: asyncreadertest.py
diff --unidirectional-new-file '--exclude=*.so' '--exclude=*.o' '--exclude=.svn' '--exclude=*.pyc' '--exclude=deps.d' '--exclude=applied' --recursive --unified version_0/test/composetest.py version_1/test/composetest.py
--- version_0/test/composetest.py	2011-02-12 11:50:45.000000000 +0100
+++ version_1/test/composetest.py	2011-02-15 08:48:29.000000000 +0100
@@ -1,6 +1,7 @@
 ## begin license ##
 #
 #    Weightless is a High Performance Asynchronous Networking Library
+#    See http://weightless.io
 #    Copyright (C) 2006-2011 Seek You Too (CQ2) http://www.cq2.nl
 #
 #    This file is part of Weightless
@@ -24,13 +25,16 @@
 from unittest import TestCase
 from sys import stdout, exc_info, getrecursionlimit
 
-from weightless import autostart
-from weightless import local
-from weightless import compose
-from weightless import tostring
+from weightless.core import autostart
+from weightless.core.compose._local_py import local as pyLocal
+from weightless.core.compose._compose_py import compose as pyCompose
+from weightless.core.compose._tostring_py import tostring as pyTostring
+from weightless.core.compose._compose_c import local as cLocal
+from weightless.core.compose._compose_c import compose as cCompose
+from weightless.core.compose._compose_c import tostring as cTostring
 from gc import collect
 
-class ComposeTest(TestCase):
+class _ComposeTest(TestCase):
 
     def testCallCompose(self):
         try:
@@ -587,11 +591,11 @@
         def f():
             yield
         g = f()
-        soll = """  File "%s", line 587, in f
+        soll = """  File "%s", line 591, in f
     def f():""" % __file__.replace('pyc', 'py')
         self.assertEquals(soll, tostring(g))
         g.next()
-        soll = """  File "%s", line 588, in f
+        soll = """  File "%s", line 592, in f
     yield""" % __file__.replace('pyc', 'py')
         self.assertEquals(soll, tostring(g))
 
@@ -602,9 +606,9 @@
         def f2():
             yield f1()
         c = compose(f2())
-        result = """  File "%s", line 603, in f2
+        result = """  File "%s", line 607, in f2
     yield f1()
-  File "%s", line 601, in f1
+  File "%s", line 605, in f1
     yield""" % (2*(__file__.replace('pyc', 'py'),))
         c.next()
         self.assertEquals(result, tostring(c), "\n%s\n!=\n%s\n" % (result, tostring(c)))
@@ -615,7 +619,7 @@
         def f2():
             yield f1()
         c = compose(f2())
-        result = """  File "%s", line 615, in f2
+        result = """  File "%s", line 619, in f2
     def f2():""" % __file__.replace('pyc', 'py')
         self.assertEquals(result, tostring(c))
 
@@ -836,3 +840,92 @@
             pass
         self.assertEquals(['GeneratorExit turned into ValueError', 'stop here'], msg)
 
+    def testYieldCompose(self):
+        def f():
+            yield "f"
+        def g():
+            yield compose(f())
+        c = compose(g())
+        self.assertEquals(['f'], list(c))
+
+    def testComposeCompose(self):
+        def f():
+            yield
+        c = compose(compose(f()))
+        self.assertTrue(c)
+
+    def testYieldComposeCloseAndThrow(self):
+        def f():
+            try:
+                yield 42
+            except Exception, e:
+                yield 84
+
+        c = compose(f())
+        self.assertEquals(42, c.send(None))
+        self.assertEquals(84, c.throw(Exception()))
+        self.assertEquals(None, c.close())
+
+
+class ComposePyTest(_ComposeTest):
+    def setUp(self):
+        _ComposeTest.setUp(self)
+        global local, tostring, compose
+        local = pyLocal
+        tostring = pyTostring
+        compose = pyCompose
+
+class ComposeCTest(_ComposeTest):
+    def setUp(self):
+        _ComposeTest.setUp(self)
+        global local, tostring, compose
+        local = cLocal
+        tostring = cTostring
+        compose = cCompose
+
+    def testQueueSize(self):
+        testrange = 9 #QUEUE SIZE = 10
+        def f():
+            raise StopIteration(*xrange(testrange))
+            yield 'f done'
+        def g():
+            results = []
+            x = yield f()
+            results.append(x)
+            for i in xrange(testrange-1):
+                results.append((yield))
+            yield results
+        c = compose(g())
+        self.assertEquals([range(testrange)], list(c))
+
+    def testQueueSizeExceeded(self):
+        testrange = 10 #QUEUE SIZE = 10
+        def f():
+            raise StopIteration(*xrange(testrange))
+            yield
+        def g():
+            x = yield f()
+        self.assertRaises(RuntimeError, compose(g()).next)
+
+    def testStackOverflow(self):
+        max_recursion_depth = getrecursionlimit()
+        def f(recursion_depth=1):
+            if recursion_depth < max_recursion_depth:
+                yield f(recursion_depth + 1)
+        c = compose(f())
+        try:
+            list(c)
+        except RuntimeError, e:
+            self.fail('must not raise %s' % e)
+
+        max_recursion_depth += 1 # <== 
+        c = compose(f())
+        try:
+            list(c)
+            self.fail('must raise runtimeerror')
+        except RuntimeError, e:
+            self.assertEquals('maximum recursion depth exceeded (compose)', e.message)
+
+    def testSelftest(self):
+        from weightless.core.compose._compose_c import _selftest
+        _selftest()
Only in version_0/test: data
diff --unidirectional-new-file '--exclude=*.so' '--exclude=*.o' '--exclude=.svn' '--exclude=*.pyc' '--exclude=deps.d' '--exclude=applied' --recursive --unified version_0/test/http/acceptortest.py version_1/test/http/acceptortest.py
--- version_0/test/http/acceptortest.py	1970-01-01 01:00:00.000000000 +0100
+++ version_1/test/http/acceptortest.py	2011-02-15 08:48:27.000000000 +0100
@@ -0,0 +1,112 @@
+## begin license ##
+#
+#    Weightless is a High Performance Asynchronous Networking Library
+#    See http://weightless.io
+#    Copyright (C) 2006-2011 Seek You Too (CQ2) http://www.cq2.nl
+#
+#    This file is part of Weightless
+#
+#    Weightless is free software; you can redistribute it and/or modify
+#    it under the terms of the GNU General Public License as published by
+#    the Free Software Foundation; either version 2 of the License, or
+#    (at your option) any later version.
+#
+#    Weightless is distributed in the hope that it will be useful,
+#    but WITHOUT ANY WARRANTY; without even the implied warranty of
+#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+#    GNU General Public License for more details.
+#
+#    You should have received a copy of the GNU General Public License
+#    along with Weightless; if not, write to the Free Software
+#    Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+#
+## end license ##
+from unittest import TestCase
+from socket import socket
+from cq2utils import CallTrace
+from random import randint
+from os import system
+from subprocess import Popen, PIPE
+
+from weightless.http import Acceptor
+
+class AcceptorTest(TestCase):
+
+    def testStartListening(self):
+        reactor = CallTrace()
+        port = randint(2**10, 2**16)
+        acceptor = Acceptor(reactor, port, None)
+        self.assertEquals('addReader', reactor.calledMethods[0].name)
+        sok = reactor.calledMethods[0].args[0]
+        out = Popen(['netstat', '--numeric', '--listening', '--tcp'], stdout=PIPE, stderr=PIPE).communicate()[0]
+        self.assertTrue(str(port) in out, out)
+        sok.close()
+        callback = reactor.calledMethods[0].args[1]
+        self.assertTrue(callable(callback))
+
+    def testConnect(self):
+        reactor = CallTrace()
+        port = randint(2**10, 2**16)
+        acceptor = Acceptor(reactor, port, lambda sok: None)
+        self.assertEquals('addReader', reactor.calledMethods[0].name)
+        acceptCallback = reactor.calledMethods[0].args[1]
+        sok = socket()
+        sok.connect(('localhost', port))
+        acceptCallback()
+        self.assertEquals('addReader', reactor.calledMethods[1].name)
+        self.assertEquals(socket, type(reactor.calledMethods[1].args[0]))
+        reactor.calledMethods[0].args[0].close()
+        sok.close()
+
+    def testCreateSink(self):
+        reactor = CallTrace('reactor')
+        port = randint(2**10, 2**16)
+        class sinkFactory(object):
+            def __init__(inner, *args, **kwargs): self.args, self.kwargs = args, kwargs
+        acceptor = Acceptor(reactor, port, sinkFactory)
+        acceptCallback = reactor.calledMethods[0].args[1]
+        sok = socket()
+        sok.connect(('localhost', port))
+        acceptCallback()
+        self.assertEquals('addReader', reactor.calledMethods[1].name)
+        sink = reactor.calledMethods[1].args[1]
+        self.assertEquals(socket, type(self.args[0]))
+        reactor.calledMethods[0].args[0].close()
+
+    def testReadData(self):
+        reactor = CallTrace('reactor')
+        port = randint(2**10, 2**16)
+        class sinkFactory(object):
+            def __init__(inner, *args, **kwargs):
+                self.args, self.kwargs = args, kwargs
+            def next(inner):
+                self.next = True
+        acceptor = Acceptor(reactor, port, sinkFactory)
+        acceptCallback = reactor.calledMethods[0].args[1]
+        sok = socket()
+        sok.connect(('localhost', port))
+        acceptCallback()
+        sink = reactor.calledMethods[1].args[1]
+        self.next = False
+        sink.next()
+        self.assertTrue(self.next)
+        reactor.calledMethods[0].args[0].close()
+
+    def testReuseAddress(self):
+        reactor = CallTrace()
+        port = randint(2**10, 2**16)
+        acceptor = Acceptor(reactor, port, lambda sok: None)
+        client = socket()
+        client.connect(('127.0.0.1', port))
+        acceptor._accept()
+        acceptor.close()
+        acceptor = Acceptor(reactor, port, lambda sok: None)
+
+    def testAcceptorWithPrio(self):
+        reactor = CallTrace()
+        port = randint(2**10, 2**16)
+        acceptor = Acceptor(reactor, port, lambda sok: None, prio=5)
+        client = socket()
+        client.connect(('127.0.0.1', port))
+        acceptor._accept()
+        self.assertEquals(5, reactor.calledMethods[0].kwargs['prio'])
diff --unidirectional-new-file '--exclude=*.so' '--exclude=*.o' '--exclude=.svn' '--exclude=*.pyc' '--exclude=deps.d' '--exclude=applied' --recursive --unified version_0/test/http/asyncreadertest.py version_1/test/http/asyncreadertest.py
--- version_0/test/http/asyncreadertest.py	1970-01-01 01:00:00.000000000 +0100
+++ version_1/test/http/asyncreadertest.py	2011-02-15 08:48:27.000000000 +0100
@@ -0,0 +1,204 @@
+## begin license ##
+#
+#    Weightless is a High Performance Asynchronous Networking Library
+#    See http://weightless.io
+#    Copyright (C) 2010-2011 Seek You Too (CQ2) http://www.cq2.nl
+#
+#    This file is part of Weightless
+#
+#    Weightless is free software; you can redistribute it and/or modify
+#    it under the terms of the GNU General Public License as published by
+#    the Free Software Foundation; either version 2 of the License, or
+#    (at your option) any later version.
+#
+#    Weightless is distributed in the hope that it will be useful,
+#    but WITHOUT ANY WARRANTY; without even the implied warranty of
+#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+#    GNU General Public License for more details.
+#
+#    You should have received a copy of the GNU General Public License
+#    along with Weightless; if not, write to the Free Software
+#    Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+#
+## end license ##
+
+from cq2utils import CQ2TestCase
+
+from re import sub
+from sys import exc_info
+import sys
+from StringIO import StringIO
+from traceback import format_exception
+from socket import socket, gaierror as SocketGaiError
+from random import randint
+from httpreadertest import server as testserver
+from weightless.http import HttpServer, httpget, Suspend
+from weightless.io import Reactor
+from weightless.core import compose
+
+from weightless.http._httpget import _httpRequest
+from weightless.http import _httpget as httpGetModule
+
+def clientget(host, port, path):
+    client = socket()
+    client.connect((host,  port))
+    client.send('GET %s HTTP/1.1\r\n\r\n' % path)
+    return client
+
+fileDict = {
+    '__file__': clientget.func_code.co_filename,
+    'suspend.py': Suspend.__call__.func_code.co_filename,
+    'httpget.py': httpget.func_code.co_filename,
+}
+ 
+class AsyncReaderTest(CQ2TestCase):
+
+    def dispatch(self, *args, **kwargs):
+        return compose(self.handler(*args, **kwargs))
+
+    def setUp(self):
+        CQ2TestCase.setUp(self)
+        self.reactor = Reactor()
+        self.port = randint(2**10, 2**16)
+        self.httpserver = HttpServer(self.reactor, self.port, self.dispatch)
+        self.httpserver.listen()
+    
+    def testHttpRequest(self):
+        self.assertEquals('GET / HTTP/1.0\r\n', _httpRequest('/'))
+        self.assertEquals('GET / HTTP/1.1\r\nHost: weightless.io\r\n', _httpRequest('/', vhost="weightless.io"))
+
+
+    def testPassRequestThruToBackOfficeServer(self):
+        done = [False]
+        backofficeport = self.port + 1
+        def passthruhandler(*args, **kwargs):
+            request = kwargs['RequestURI']
+            response = yield httpget('localhost', backofficeport, request)
+            yield response
+            done[0] = True
+        self.handler = passthruhandler
+        expectedrequest = "GET /depot?arg=1&arg=2 HTTP/1.0\r\n\r\n"
+        responses = (i for i in ['hel', 'lo!'])
+        backofficeserver = testserver(backofficeport, responses, expectedrequest)
+        client = clientget('localhost', self.port, '/depot?arg=1&arg=2')
+        while not done[0]:
+            self.reactor.step()
+        response = client.recv(99)
+        self.assertEquals('hello!', response)
+
+    def testConnectFails(self):
+        exceptions = []
+        def failingserver(*args, **kwarg):
+            try:
+                response = yield httpget(*target)
+            except Exception, e:
+                exceptions.append(exc_info())
+        self.handler = failingserver
+
+        clientget('localhost', self.port, '/')
+        target = ('localhost', 'port', '/') # non-numeric port
+        while not exceptions:
+            orgout = sys.stderr
+            sys.stderr = StringIO()
+            try:
+                self.reactor.step()
+            finally:
+                sys.stderr = orgout
+
+        expectedTraceback = ignoreLineNumbers("""Traceback (most recent call last):
+  File "%(__file__)s", line 85, in failingserver
+    response = yield httpget(*target)
+  File "%(httpget.py)s", line 78, in httpget
+    result = s.getResult()
+  File "%(suspend.py)s", line 34, in __call__
+    self._doNext(self)
+  File "%(httpget.py)s", line 35, in doGet
+    sok.connect((host, port))
+  File "<string>", line 1, in connect
+TypeError: an integer is required
+       """ % fileDict)
+        self.assertEquals(TypeError, exceptions[0][0])
+        self.assertEqualsWS(expectedTraceback, ignoreLineNumbers(''.join(format_exception(*exceptions[0]))))
+
+        target = ('localhost', 87, '/') # invalid port
+        clientget('localhost', self.port, '/')
+        exceptions = []
+        while not exceptions:
+            orgout = sys.stderr
+            sys.stderr = StringIO()
+            try:
+                self.reactor.step()
+            finally:
+                sys.stderr = orgout
+        self.assertEquals(IOError, exceptions[0][0])
+
+        target = ('UEYR^$*FD(#>NDJ.khfd9.(*njnd', 9876, '/') # invalid host
+        clientget('localhost', self.port, '/')
+        exceptions = []
+        while not exceptions:
+            orgout = sys.stderr
+            sys.stderr = StringIO()
+            try:
+                self.reactor.step()
+            finally:
+                sys.stderr = orgout
+        self.assertEquals(SocketGaiError, exceptions[0][0])
+
+        target = ('127.0.0.255', 9876, '/')
+        clientget('localhost', self.port, '/')
+        exceptions = []
+        while not exceptions:
+            orgout = sys.stderr
+            sys.stderr = StringIO()
+            try:
+                self.reactor.step()
+            finally:
+                sys.stderr = orgout
+        self.assertEquals(IOError, exceptions[0][0])
+        self.assertEquals(111, exceptions[0][1].message)
+
+    def testTracebackPreservedAcrossSuspend(self):
+        backofficeport = self.port + 1
+        expectedrequest = ''
+        testserver(backofficeport, [], expectedrequest)
+        target = ('localhost', backofficeport, '/')
+
+        exceptions = []
+        def failingserver(*args, **kwarg):
+            try:
+                response = yield httpget(*target)
+            except Exception, e:
+                exceptions.append(exc_info())
+        self.handler = failingserver
+
+        def httpRequest(self, *args, **kwargs):
+            raise RuntimeError("Boom!")
+
+        try:
+            originalHttpRequest = httpGetModule._httpRequest
+            httpGetModule._httpRequest = httpRequest
+
+            clientget('localhost', self.port, '/')
+            while not exceptions:
+                self.reactor.step()
+
+            expectedTraceback = ignoreLineNumbers("""Traceback (most recent call last):
+  File "%(__file__)s", line 144, in failingserver
+    response = yield httpget(*target)
+  File "%(httpget.py)s", line 80, in httpget
+    result = s.getResult()
+  File "%(httpget.py)s", line 51, in doGet
+    sok.send('%%s\\r\\n' %% _httpRequest(request, vhost=vhost))
+  File "%(__file__)s", line 150, in httpRequest
+    raise RuntimeError("Boom!")
+RuntimeError: Boom!""" % fileDict)
+            resultingTraceback = ''.join(format_exception(*exceptions[0]))
+            self.assertEqualsWS(expectedTraceback, ignoreLineNumbers(resultingTraceback))
+
+        finally:
+            httpGetModule._httpRequest = originalHttpRequest
+
+
+def ignoreLineNumbers(s):
+    return sub("line \d+,", "line [#],", s)
+
Binary files version_0/test/http/data/multipart-data-01 and version_1/test/http/data/multipart-data-01 differ
Binary files version_0/test/http/data/multipart-data-02 and version_1/test/http/data/multipart-data-02 differ
diff --unidirectional-new-file '--exclude=*.so' '--exclude=*.o' '--exclude=.svn' '--exclude=*.pyc' '--exclude=deps.d' '--exclude=applied' --recursive --unified version_0/test/http/data/multipart-data-03 version_1/test/http/data/multipart-data-03
--- version_0/test/http/data/multipart-data-03	1970-01-01 01:00:00.000000000 +0100
+++ version_1/test/http/data/multipart-data-03	2011-02-15 08:48:27.000000000 +0100
@@ -0,0 +1,31 @@
+POST / HTTP/1.1
+Accept: image/gif, image/x-xbitmap, image/jpeg, image/pjpeg, application/x-shockwave-flash, */*
+Referer: http://192.168.1.38/form.html
+Accept-Language: en-us
+Content-Type: multipart/form-data; boundary=---------------------------7d8b7db01ea
+Accept-Encoding: gzip, deflate
+User-Agent: Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1; .NET CLR 1.1.4322)
+Host: 192.168.1.38:8000
+Content-Length: 36482
+Connection: Keep-Alive
+
+-----------------------------7d8b7db01ea
+Content-Disposition: form-data; name="id"
+
+SOME ID
+-----------------------------7d8b7db01ea
+Content-Disposition: form-data; name="field1"
+
+value1
+-----------------------------7d8b7db01ea
+Content-Disposition: form-data; name="field2"
+
+value2
+-----------------------------7d8b7db01ea
+Content-Disposition: form-data; name="somename"; filename="hello.bas"
+Content-Type: text/plain
+
+10 REM *** HELLO WORLD EXAMPLE ***
+20 PRINT "HELLO WORLD"
+30 GOTO 20
+-----------------------------7d8b7db01ea--
diff --unidirectional-new-file '--exclude=*.so' '--exclude=*.o' '--exclude=.svn' '--exclude=*.pyc' '--exclude=deps.d' '--exclude=applied' --recursive --unified version_0/test/http/data/multipart-data-04 version_1/test/http/data/multipart-data-04
--- version_0/test/http/data/multipart-data-04	1970-01-01 01:00:00.000000000 +0100
+++ version_1/test/http/data/multipart-data-04	2011-02-15 08:48:27.000000000 +0100
@@ -0,0 +1,16 @@
+POST / HTTP/1.1
+Accept: image/gif, image/x-xbitmap, image/jpeg, image/pjpeg, application/x-shockwave-flash, */*
+Referer: http://192.168.1.38/form.html
+Accept-Language: en-us
+Content-Type: multipart/form-data; boundary=---------------------------7d8b7db01ea
+Accept-Encoding: gzip, deflate
+User-Agent: Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1; .NET CLR 1.1.4322)
+Host: 192.168.1.38:8000
+Content-Length: 36482
+Connection: Keep-Alive
+
+-----------------------------7d8b7db01ea
+Content-Disposition: form-data; name="id"
+
+XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
+-----------------------------7d8b7db01ea--
Binary files version_0/test/http/data/testdata5kb and version_1/test/http/data/testdata5kb differ
Binary files version_0/test/http/data/testdata8kb and version_1/test/http/data/testdata8kb differ
diff --unidirectional-new-file '--exclude=*.so' '--exclude=*.o' '--exclude=.svn' '--exclude=*.pyc' '--exclude=deps.d' '--exclude=applied' --recursive --unified version_0/test/http/data/testdata_asc_5kb version_1/test/http/data/testdata_asc_5kb
--- version_0/test/http/data/testdata_asc_5kb	1970-01-01 01:00:00.000000000 +0100
+++ version_1/test/http/data/testdata_asc_5kb	2011-02-15 08:48:27.000000000 +0100
@@ -0,0 +1 @@
+0123456789abcdefghijklmnopqrstuvwxyzaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa
\ No newline at end of file
diff --unidirectional-new-file '--exclude=*.so' '--exclude=*.o' '--exclude=.svn' '--exclude=*.pyc' '--exclude=deps.d' '--exclude=applied' --recursive --unified version_0/test/http/data/testdata_asc_8kb version_1/test/http/data/testdata_asc_8kb
--- version_0/test/http/data/testdata_asc_8kb	1970-01-01 01:00:00.000000000 +0100
+++ version_1/test/http/data/testdata_asc_8kb	2011-02-15 08:48:27.000000000 +0100
@@ -0,0 +1 @@
+aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa
\ No newline at end of file
diff --unidirectional-new-file '--exclude=*.so' '--exclude=*.o' '--exclude=.svn' '--exclude=*.pyc' '--exclude=deps.d' '--exclude=applied' --recursive --unified version_0/test/http/httpreadertest.py version_1/test/http/httpreadertest.py
--- version_0/test/http/httpreadertest.py	1970-01-01 01:00:00.000000000 +0100
+++ version_1/test/http/httpreadertest.py	2011-02-15 08:48:27.000000000 +0100
@@ -0,0 +1,317 @@
+## begin license ##
+#
+#    Weightless is a High Performance Asynchronous Networking Library
+#    See http://weightless.io
+#    Copyright (C) 2006-2011 Seek You Too (CQ2) http://www.cq2.nl
+#
+#    This file is part of Weightless
+#
+#    Weightless is free software; you can redistribute it and/or modify
+#    it under the terms of the GNU General Public License as published by
+#    the Free Software Foundation; either version 2 of the License, or
+#    (at your option) any later version.
+#
+#    Weightless is distributed in the hope that it will be useful,
+#    but WITHOUT ANY WARRANTY; without even the implied warranty of
+#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+#    GNU General Public License for more details.
+#
+#    You should have received a copy of the GNU General Public License
+#    along with Weightless; if not, write to the Free Software
+#    Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+#
+## end license ##
+from unittest import TestCase
+from random import randint
+from time import sleep
+from socket import socket, timeout
+from threading import Thread, Event
+
+
+from weightless.io import Reactor
+from weightless.http import HttpReader
+from weightless.core import VERSION as WlVersion
+from weightless.http._httpreader import HttpReaderFacade, Connector, HandlerFacade, _httpParseUrl
+import sys
+from StringIO import StringIO
+from cq2utils import CallTrace
+from cq2utils.cq2testcase import MatchAll
+
+def server(port, response, expectedrequest, delay=0, loop=50):
+    isListening = Event()
+    def serverProcess():
+        serverSok = socket()
+        serverSok.bind(('0.0.0.0', port))
+        serverSok.listen(1)
+        isListening.set()
+        newSok, addr = serverSok.accept()
+        newSok.settimeout(1)
+
+        msg = ''
+        for i in xrange(loop):
+            if expectedrequest:
+                try:
+                    msg += newSok.recv(4096)
+                    if msg == expectedrequest:
+                        break
+                    if len(msg) >= len(expectedrequest):
+                        print "hihi"
+                        raise timeout
+                except timeout:
+                    print "Received:", repr(msg)
+                    print "expected:", repr(expectedrequest)
+                    return
+        if response:
+            if hasattr(response, 'next'):
+                for r in response:
+                    newSok.send(r)
+            else:
+                newSok.send(response)
+            sleep(delay)
+            newSok.close()
+        else:
+            sleep(0.5)
+        serverSok.close()
+
+    thread=Thread(None, serverProcess)
+    thread.start()
+    isListening.wait()
+    return thread
+
+class HttpReaderTest(TestCase):
+
+    def testRequestAndHeaders(self):
+        port = randint(2**10, 2**16)
+        expectedrequest = "GET /aap/noot/mies HTTP/1.1\r\nHost: localhost\r\nUser-Agent: Weightless/v0.4.x\r\n\r\n"
+        dataReceived = []
+        serverThread = server(port, "HTTP/1.1 200 OK\r\ncOnteNt-type: text/html\r\n\r\nHello World!", expectedrequest)
+        class Generator(object):
+            def __init__(self):
+                self.throw = None
+                self.next = None
+            def send(self, data):
+                dataReceived.append(data)
+        reactor = Reactor()
+        connection = Connector(reactor, 'localhost', port)
+        reader = HttpReader(reactor, connection, Generator(), 'GET', 'localhost', '/aap/noot/mies', recvSize=7)
+        reactor.addTimer(0.1, lambda: self.fail("Test Stuck"))
+        while 'Hello World!' != "".join((x for x in dataReceived[1:] if x)):
+            reactor.step()
+        serverThread.join()
+        self.assertEquals({'HTTPVersion': '1.1', 'StatusCode': '200', 'ReasonPhrase': 'OK', 'Headers': {'Content-Type': 'text/html'}, 'Client': ('127.0.0.1', MatchAll())}, dataReceived[0])
+
+    def testHttpUrlParse(self):
+        host, port, path = _httpParseUrl('http://www.cq2.org')
+        self.assertEquals('www.cq2.org', host)
+        self.assertEquals(80, port)
+        self.assertEquals('/', path)
+
+        host, port, path = _httpParseUrl('http://www.cq2.org:5000/page#anchor')
+        self.assertEquals('www.cq2.org', host)
+        self.assertEquals(5000, port)
+        self.assertEquals('/page#anchor', path)
+
+        host, port, path = _httpParseUrl('http://www.cq2.org:5000/page?x=1')
+        self.assertEquals('www.cq2.org', host)
+        self.assertEquals(5000, port)
+        self.assertEquals('/page?x=1', path)
+
+
+    def testEmptyPath(self):
+        port = randint(2**10, 2**16)
+        reactor = Reactor()
+        request = "GET / HTTP/1.1\r\nHost: localhost\r\nUser-Agent: Weightless/v0.4.x\r\n\r\n"
+        serverThread = server(port, "HTTP/1.1 200 OK\r\n\r\n", request)
+        reader = HttpReaderFacade(reactor, "http://localhost:%s" % port, lambda data: 'a')
+        reactor.step()
+        reactor.step()
+        serverThread.join()
+        #self.assertTrue(request[0].startswith('GET / HTTP/1.1\r\n'), request[0])
+
+    def testTimeoutOnInvalidRequest(self):
+        port = randint(2**10, 2**16)
+        reactor = Reactor()
+        expectedrequest = "GET / HTTP/1.1\r\nHost: localhost\r\nUser-Agent: Weightless/v0.4.x\r\n\r\n"
+        serverThread = server(port, "HTTP/1.1 *invalid reponse* 200 OK\r\n\r\n", expectedrequest)
+        errorArgs = []
+        def error(exception):
+            errorArgs.append(exception)
+        reader = HttpReaderFacade(reactor, "http://localhost:%s" % port, None, error, timeout=0.01)
+        while not errorArgs:
+            reactor.step()
+        serverThread.join()
+        self.assertEquals('timeout while receiving data', str(errorArgs[0]))
+
+    def testTimeoutOnSilentServer(self):
+        port = randint(2**10, 2**16)
+        reactor = Reactor()
+        expectedrequest = "GET / HTTP/1.1\r\nHost: localhost\r\nUser-Agent: Weightless/v0.4.x\r\n\r\n"
+        serverThread = server(port, "", expectedrequest)
+        errorArgs = []
+        class Handler:
+            def throw(self, exception):
+                errorArgs.append(exception)
+        def error(exception):
+            errorArgs.append(exception)
+        reader = HttpReader(reactor, Connector(reactor, 'localhost', port), Handler(), "GET", "localhost", "/", timeout=0.01)
+        reactor.addTimer(0.2, lambda: self.fail("Test Stuck"))
+        while not errorArgs:
+            reactor.step()
+        serverThread.join()
+        self.assertEquals('timeout while receiving data', str(errorArgs[0]))
+
+    def testTimeoutOnServerGoingSilentAfterHeaders(self):
+        port = randint(2**10, 2**16)
+        reactor = Reactor()
+        expectedrequest = "GET / HTTP/1.1\r\nHost: localhost\r\nUser-Agent: Weightless/v0.4.x\r\n\r\n"
+        serverThread = server(port, "HTTP/1.1 200 OK\r\n\r\n", expectedrequest, delay=1)
+        errorArgs = []
+        class Handler:
+            def send(self, data):
+                pass
+            def throw(self, exception):
+                errorArgs.append(exception)
+        def error(exception):
+            errorArgs.append(exception)
+        reader = HttpReader(reactor, Connector(reactor, 'localhost', port), Handler(), "GET", "localhost", "/", timeout=0.01)
+        reactor.addTimer(0.2, lambda: self.fail("Test Stuck"))
+        while not errorArgs:
+            reactor.step()
+        serverThread.join()
+        self.assertEquals('timeout while receiving data', str(errorArgs[0]))
+
+    def testClearTimer(self):
+        port = randint(2**10, 2**16)
+        reactor = Reactor()
+        expectedrequest = "GET / HTTP/1.1\r\nHost: localhost\r\nUser-Agent: Weightless/v0.4.x\r\n\r\n"
+        serverThread = server(port, "HTTP/1.1 200 OK\r\n\r\nresponse", expectedrequest)
+        self.exception = None
+        sentData = []
+        def send(data):
+            sentData.append(data)
+        def throw(exception):
+            self.exception = exception
+        reader = HttpReaderFacade(reactor, "http://localhost:%s" % port, send, throw, timeout=0.01, recvSize=3)
+        while not self.exception:
+            reactor.step()
+        sleep(0.02) # 2 * timeout, just to be sure
+
+        self.assertTrue(isinstance(self.exception, StopIteration))
+
+    def testPost(self):
+        port = randint(2048, 4096)
+        reactor = Reactor()
+        request = "POST / HTTP/1.1\r\nHost: localhost\r\nTransfer-Encoding: chunked\r\nSOAPAction: blah\r\nUser-Agent: Weightless/v0.4.x\r\n\r\n1\r\nA\r\n1\r\nB\r\n1\r\nC\r\n0\r\n\r\n"
+        serverThread = server(port, "HTTP/1.1 200 OK\r\n\r\nresponse", request, loop=9)
+        sentData = []
+        done = []
+        def send(data):
+            sentData.append(data)
+        def throw(exception):
+            if isinstance(exception, StopIteration):
+                done.append(True)
+        def next():
+            yield "A"
+            yield "B"
+            yield "C"
+            yield None
+
+        reader = HttpReaderFacade(reactor, "http://localhost:%s" % port, send, errorHandler=throw, timeout=0.5, headers={'SOAPAction': 'blah'}, bodyHandler=next)
+
+        reactor.addTimer(3.0, lambda: self.fail("Test Stuck"))
+        while not done:
+            reactor.step()
+
+        self.assertEquals(['response'], sentData[1:])
+        self.assertEquals('200', sentData[0]['StatusCode'])
+        expected = 'POST / HTTP/1.1\r\nHost: localhost\r\nTransfer-Encoding: chunked\r\nSOAPAction: blah\r\nUser-Agent: Weightless/v%s\r\n\r\n' % WlVersion + '1\r\nA\r\n' + '1\r\nB\r\n' + '1\r\nC\r\n' + '0\r\n\r\n'
+        self.assertEquals(expected, "".join(request))
+
+    def testWriteChunks(self):
+        reader  = HttpReader(CallTrace("reactor"), CallTrace("socket"), HandlerFacade(None, None, None), '', '', '')
+        self.assertEquals('1\r\nA\r\n', reader._createChunk('A'))
+        self.assertEquals('A\r\n' + 10*'B' + '\r\n', reader._createChunk(10*'B'))
+
+    def testDealWithChunkedResponse(self):
+        port = randint(2048, 4096)
+        reactor = Reactor()
+        sentData = []
+        done = []
+        expectedrequest = "GET / HTTP/1.1\r\nHost: localhost\r\nUser-Agent: Weightless/v0.4.x\r\n\r\n"
+        serverThread = server(port, "\r\n".join("""HTTP/1.1 302 Found
+Date: Fri, 26 Oct 2007 07:23:26 GMT
+Server: Apache/2.2.3 (Debian) mod_python/3.2.10 Python/2.4.4 mod_ssl/2.2.3 OpenSSL/0.9.8c
+Location: /page/softwarestudio.page/show
+Transfer-Encoding: chunked
+Content-Type: text/html; charset=utf-8
+
+4F
+<p>The document has moved <a href="/page/softwarestudio.page/show">here</a></p>
+
+0
+
+
+""".split("\n")), expectedrequest)
+        class Handler:
+            def send(self, data):
+                sentData.append(data)
+            def throw(self, exception):
+                if isinstance(exception, StopIteration):
+                    done.append(True)
+        reader = HttpReader(reactor, Connector(reactor, 'localhost', int(port)), Handler(), 'GET', 'localhost', '/', recvSize=5)
+
+        reactor.addTimer(0.2, lambda: self.fail("Test Stuck"))
+        while not done:
+            reactor.step()
+        self.assertEquals("""<p>The document has moved <a href="/page/softwarestudio.page/show">here</a></p>""", "".join(sentData[1:]))
+
+    def testChunkedAllTheWay(self):
+        reactor = CallTrace('Reactor')
+        sokket = CallTrace('Sokket')
+        data = []
+        class Handler:
+            def send(self, chunk):
+                data.append(chunk)
+            def throw(self, exception):
+                pass
+        httpreader = HttpReader(reactor, sokket, Handler(), 'GET', 'host,nl', '/')
+        httpreader._chunked = True
+        # chunk == network message
+        httpreader._sendFragment('4\r\n1234\r\n')
+        self.assertEquals(['1234'], data)
+        httpreader._sendFragment('10\r\n0123456789abcdef\r\n')
+        self.assertEquals(['1234', '0123456789abcdef'], data)
+        del data[0]
+        del data[0]
+        # chunk = 2 network messages
+        httpreader._sendFragment('10\r\nfedcba')
+        #self.assertEquals(['fedcba'], data)
+        httpreader._sendFragment('9876543210\r\n')
+        self.assertEquals(['fedcba9876543210'], data)
+
+    def testLastRecvContainsCompleteChunk(self):
+        reactor = CallTrace('Reactor')
+        sokket = CallTrace('Sokket')
+        data = []
+        done = []
+        class Handler:
+            def send(self, chunk):
+                data.append(chunk)
+            def throw(self, exception):
+                done.append(True)
+        httpreader = HttpReader(reactor, sokket, Handler(), 'GET', 'host,nl', '/')
+        httpreader._chunked = True
+        chunkOne = '9\r\n123456789\r\n'
+        chunkTwo = '8\r\n87654321\r\n'
+        httpreader._sendFragment(chunkOne)
+        self.assertEquals(['123456789'], data)
+        httpreader._sendFragment(chunkTwo)
+        self.assertEquals(['123456789', '87654321'], data)
+        while data: del data[0] # now both in one network message
+        httpreader._sendFragment(chunkOne + chunkTwo +'0\r\n\r\n')
+        # Send fragment will only read one fragment.
+        # Now feed it until all chunks are finished
+        httpreader._sendFragment('')
+        httpreader._sendFragment('')
+        self.assertEquals(['123456789', '87654321'], data)
+        self.assertEquals([True], done)
diff --unidirectional-new-file '--exclude=*.so' '--exclude=*.o' '--exclude=.svn' '--exclude=*.pyc' '--exclude=deps.d' '--exclude=applied' --recursive --unified version_0/test/http/httpservertest.py version_1/test/http/httpservertest.py
--- version_0/test/http/httpservertest.py	1970-01-01 01:00:00.000000000 +0100
+++ version_1/test/http/httpservertest.py	2011-02-15 08:48:27.000000000 +0100
@@ -0,0 +1,428 @@
+# -*- coding: utf-8 -*-
+## begin license ##
+#
+#    Weightless is a High Performance Asynchronous Networking Library
+#    See http://weightless.io
+#    Copyright (C) 2006-2011 Seek You Too (CQ2) http://www.cq2.nl
+#
+#    This file is part of Weightless
+#
+#    Weightless is free software; you can redistribute it and/or modify
+#    it under the terms of the GNU General Public License as published by
+#    the Free Software Foundation; either version 2 of the License, or
+#    (at your option) any later version.
+#
+#    Weightless is distributed in the hope that it will be useful,
+#    but WITHOUT ANY WARRANTY; without even the implied warranty of
+#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+#    GNU General Public License for more details.
+#
+#    You should have received a copy of the GNU General Public License
+#    along with Weightless; if not, write to the Free Software
+#    Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+#
+## end license ##
+from unittest import TestCase
+from random import randint
+from socket import socket, error as SocketError
+from select import select
+from weightless.io import Reactor
+from time import sleep
+from cq2utils import MATCHALL, CallTrace
+from os.path import join, abspath, dirname
+
+from weightless.http import HttpServer, _httpserver
+
+def inmydir(p):
+    return join(dirname(abspath(__file__)), p)
+
+class HttpServerTest(TestCase):
+
+    def setUp(self):
+        self.reactor = Reactor()
+        self._portNumber = randint(2048, 62000)
+
+    def tearDown(self):
+        self.reactor.shutdown()
+        self.reactor = None
+
+    def sendRequestAndReceiveResponse(self, request, recvSize=4096):
+        self.responseCalled = False
+        def response(**kwargs):
+            yield 'The Response'
+            self.responseCalled = True
+        server = HttpServer(self.reactor, self._portNumber, response, recvSize=recvSize)
+        server.listen()
+        sok = socket()
+        sok.connect(('localhost', self._portNumber))
+        sok.send(request)
+        while not self.responseCalled:
+            self.reactor.step()
+        return sok.recv(4096)
+
+    def testConnect(self):
+        self.req = False
+        def onRequest(**kwargs):
+            self.req = True
+            yield 'nosens'
+        reactor = Reactor()
+        server = HttpServer(reactor, self._portNumber, onRequest)
+        server.listen()
+        sok = socket()
+        sok.connect(('localhost', self._portNumber))
+        sok.send('GET / HTTP/1.0\r\n\r\n')
+        reactor.step() # connect/accept
+        reactor.step() # read GET request
+        reactor.step() # call onRequest for response data
+        self.assertEquals(True, self.req)
+
+    def testSendHeader(self):
+        self.kwargs = None
+        def response(**kwargs):
+            self.kwargs = kwargs
+            yield 'nosense'
+        reactor = Reactor()
+        server = HttpServer(reactor, self._portNumber, response)
+        server.listen()
+        sok = socket()
+        sok.connect(('localhost', self._portNumber))
+        sok.send('GET /path/here HTTP/1.0\r\nConnection: close\r\nApe-Nut: Mies\r\n\r\n')
+        while not self.kwargs:
+            reactor.step()
+        self.assertEquals({'Body': '', 'RequestURI': '/path/here', 'HTTPVersion': '1.0', 'Method': 'GET', 'Headers': {'Connection': 'close', 'Ape-Nut': 'Mies'}, 'Client': ('127.0.0.1', MATCHALL)}, self.kwargs)
+
+    def testGetResponse(self):
+        response = self.sendRequestAndReceiveResponse('GET /path/here HTTP/1.0\r\nConnection: close\r\nApe-Nut: Mies\r\n\r\n')
+        self.assertEquals('The Response', response)
+
+    def testCloseConnection(self):
+        response = self.sendRequestAndReceiveResponse('GET /path/here HTTP/1.0\r\nConnection: close\r\nApe-Nut: Mies\r\n\r\n')
+        self.assertEquals('The Response', response)
+        self.assertEquals(1, len(self.reactor._readers)) # only acceptor left
+        self.assertEquals({}, self.reactor._writers)
+
+    def testSmallFragments(self):
+        response = self.sendRequestAndReceiveResponse('GET /path/here HTTP/1.0\r\nConnection: close\r\nApe-Nut: Mies\r\n\r\n', recvSize=3)
+        self.assertEquals('The Response', response)
+
+    def testSmallFragmentsWhileSendingResponse(self):
+
+        def response(**kwargs):
+            yield 'some text that is longer than '
+            yield 'the lenght of fragments sent'
+        reactor = Reactor()
+        server = HttpServer(reactor, self._portNumber, response, recvSize=3)
+        server.listen()
+        sok = socket()
+        sok.connect(('localhost', self._portNumber))
+        sok.send('GET /path/here HTTP/1.0\r\nConnection: close\r\nApe-Nut: Mies\r\n\r\n')
+        while not reactor._writers:
+            reactor.step()
+        serverSok, handler = reactor._writers.items()[0]
+        originalSend = serverSok.send
+        def sendOnlyManagesToActuallySendThreeBytesPerSendCall(data, *options):
+            originalSend(data[:3], *options)
+            return 3
+        serverSok.send = sendOnlyManagesToActuallySendThreeBytesPerSendCall
+        for i in range(21):
+            reactor.step()
+        fragment = sok.recv(4096)
+        self.assertEquals('some text that is longer than the lenght of fragments sent', fragment)
+
+    def testInvalidRequestStartsOnlyOneTimer(self):
+        _httpserver.RECVSIZE = 3
+        reactor = Reactor()
+        timers = []
+        orgAddTimer = reactor.addTimer
+        def addTimerInterceptor(*timer):
+            timers.append(timer)
+            return orgAddTimer(*timer)
+        reactor.addTimer = addTimerInterceptor
+        server = HttpServer(reactor, self._portNumber, None, timeout=0.01)
+        server.listen()
+        sok = socket()
+        sok.connect(('localhost', self._portNumber))
+        sok.send('GET HTTP/1.0\r\n\r\n') # no path
+        while select([sok],[], [], 0) != ([sok], [], []):
+            reactor.step()
+        response = sok.recv(4096)
+        self.assertEquals('HTTP/1.0 400 Bad Request\r\n\r\n', response)
+        self.assertEquals(1, len(timers))
+
+    def testValidRequestResetsTimer(self):
+        reactor = Reactor()
+        server = HttpServer(reactor, self._portNumber, lambda **kwargs: ('a' for a in range(3)), timeout=0.01, recvSize=3)
+        server.listen()
+        sok = socket()
+        sok.connect(('localhost', self._portNumber))
+        sok.send('GET / HTTP/1.0\r\n\r\n')
+        sleep(0.02)
+        for i in range(11):
+            reactor.step()
+        response = sok.recv(4096)
+        self.assertEquals('aaa', response)
+
+    def testPostMethodReadsBody(self):
+        self.requestData = None
+        def handler(**kwargs):
+            self.requestData = kwargs
+
+        reactor = Reactor()
+        server = HttpServer(reactor, self._portNumber, handler, timeout=0.01)
+        server.listen()
+        sok = socket()
+        sok.connect(('localhost', self._portNumber))
+        sok.send('POST / HTTP/1.0\r\nContent-Type: application/x-www-form-urlencoded\r\nContent-Length: 8\r\n\r\nbodydata')
+
+        while not self.requestData:
+            reactor.step()
+        self.assertEquals(dict, type(self.requestData))
+        self.assertTrue('Headers' in self.requestData)
+        headers = self.requestData['Headers']
+        self.assertEquals('POST', self.requestData['Method'])
+        self.assertEquals('application/x-www-form-urlencoded', headers['Content-Type'])
+        self.assertEquals(8, int(headers['Content-Length']))
+
+        self.assertTrue('Body' in self.requestData)
+        self.assertEquals('bodydata', self.requestData['Body'])
+
+    def testPostMethodTimesOutOnBadBody(self):
+        self.requestData = None
+        def handler(**kwargs):
+            self.requestData = kwargs
+
+        done = []
+        def onDone():
+            fromServer = sok.recv(1024)
+            self.assertTrue('HTTP/1.0 400 Bad Request' in fromServer)
+            done.append(True)
+
+        reactor = Reactor()
+        server = HttpServer(reactor, self._portNumber, handler, timeout=0.01)
+        server.listen()
+        reactor.addTimer(0.02, onDone)
+        sok = socket()
+        sok.connect(('localhost', self._portNumber))
+        sok.send('POST / HTTP/1.0\r\nContent-Type: application/x-www-form-urlencoded\r\nContent-Length: 8\r\n\r\n')
+
+        while not done:
+            reactor.step()
+
+
+    def testReadChunkedPost(self):
+        self.requestData = {}
+        def handler(**kwargs):
+            self.requestData = kwargs
+
+        reactor = Reactor()
+        server = HttpServer(reactor, self._portNumber, handler, timeout=0.01, recvSize=3)
+        server.listen()
+        sok = socket()
+        sok.connect(('localhost', self._portNumber))
+        sok.send('POST / HTTP/1.0\r\nContent-Type: application/x-www-form-urlencoded\r\nTransfer-Encoding: chunked\r\n\r\n5\r\nabcde\r\n5\r\nfghij\r\n0\r\n')
+
+        reactor.addTimer(0.2, lambda: self.fail("Test Stuck"))
+        while self.requestData.get('Body', None) != 'abcdefghij':
+            reactor.step()
+
+    def testPostMultipartForm(self):
+        httpRequest = open(inmydir('data/multipart-data-01')).read()
+        self.requestData = {}
+        def handler(**kwargs):
+            self.requestData = kwargs
+
+        reactor = Reactor()
+        server = HttpServer(reactor, self._portNumber, handler)
+        server.listen()
+        sok = socket()
+        sok.connect(('localhost', self._portNumber))
+        sok.send(httpRequest)
+
+        reactor.addTimer(2, lambda: self.fail("Test Stuck"))
+        while self.requestData.get('Form', None) == None:
+            reactor.step()
+        form = self.requestData['Form']
+        self.assertEquals(4, len(form))
+        self.assertEquals(['SOME ID'], form['id'])
+
+    def testWindowsPostMultipartForm(self):
+        httpRequest = open(inmydir('data/multipart-data-02')).read()
+        self.requestData = {}
+        def handler(**kwargs):
+            self.requestData = kwargs
+
+        reactor = Reactor()
+        server = HttpServer(reactor, self._portNumber, handler)
+        server.listen()
+        sok = socket()
+        sok.connect(('localhost', self._portNumber))
+        sok.send(httpRequest)
+
+        reactor.addTimer(2, lambda: self.fail("Test Stuck"))
+        while self.requestData.get('Form', None) == None:
+            reactor.step()
+        form = self.requestData['Form']
+        self.assertEquals(4, len(form))
+        self.assertEquals(['SOME ID'], form['id'])
+        self.assertEquals(1, len(form['somename']))
+        filename, mimetype, data = form['somename'][0]
+        self.assertEquals('Bank Gothic Medium BT.ttf', filename)
+        self.assertEquals('application/octet-stream', mimetype)
+
+    def testTextFileSeenAsFile(self):
+        httpRequest = open(inmydir('data/multipart-data-03')).read()
+        self.requestData = {}
+        def handler(**kwargs):
+            self.requestData = kwargs
+
+        reactor = Reactor()
+        server = HttpServer(reactor, self._portNumber, handler)
+        server.listen()
+        sok = socket()
+        sok.connect(('localhost', self._portNumber))
+        sok.send(httpRequest)
+
+        reactor.addTimer(2, lambda: self.fail("Test Stuck"))
+        while self.requestData.get('Form', None) == None:
+            reactor.step()
+        form = self.requestData['Form']
+        self.assertEquals(4, len(form))
+        self.assertEquals(['SOME ID'], form['id'])
+        self.assertEquals(1, len(form['somename']))
+        filename, mimetype, data = form['somename'][0]
+        self.assertEquals('hello.bas', filename)
+        self.assertEquals('text/plain', mimetype)
+
+    def testReadMultipartFormEndBoundary(self):
+        httpRequest = open(inmydir('data/multipart-data-04')).read()
+        self.requestData = {}
+        def handler(**kwargs):
+            self.requestData = kwargs
+
+        reactor = Reactor()
+        server = HttpServer(reactor, self._portNumber, handler)
+        server.listen()
+        sok = socket()
+        sok.connect(('localhost', self._portNumber))
+        sok.send(httpRequest)
+
+        reactor.addTimer(2, lambda: self.fail("Test Stuck"))
+        while self.requestData.get('Form', None) == None:
+            reactor.step()
+        form = self.requestData['Form']
+        self.assertEquals(1, len(form))
+        self.assertEquals(3521*'X', form['id'][0])
+
+    def testOnlyHandleAMaximumNrOfRequests(self):
+        codes = []
+        def handler(**kwargs):
+            yield "OK"
+
+        def error_handler(**kwargs):
+            codes.append(kwargs['ResponseCode'])
+            yield "FAIL"
+
+        server = HttpServer(self.reactor, self._portNumber, handler, errorHandler=error_handler, maxConnections=5)
+        server.listen()
+
+        self.reactor.getOpenConnections = lambda: 10
+
+        sock = socket()
+        sock.connect(('localhost', self._portNumber))
+        self.reactor.step()
+        sock.send("GET / HTTP/1.0\r\n\r\n")
+        self.reactor.step()
+        self.reactor.step()
+
+        self.assertEquals('FAIL', sock.recv(1024))
+        self.assertEquals([503], codes)
+
+    def testOnlyHandleAMaximumNrOfRequestsBelowBoundary(self):
+        def handler(**kwargs):
+            yield "OK"
+
+        def error_handler(**kwargs):
+            yield "FAIL"
+
+        server = HttpServer(self.reactor, self._portNumber, handler, errorHandler=error_handler, maxConnections=10)
+        server.listen()
+
+        self.reactor.getOpenConnections = lambda: 5
+
+        sock = socket()
+        sock.connect(('localhost', self._portNumber))
+        self.reactor.step()
+        sock.send("GET / HTTP/1.0\r\n\r\n")
+        self.reactor.step()
+        self.reactor.step()
+
+        self.assertEquals('OK', sock.recv(1024))
+
+    def testDefaultErrorHandler(self):
+        def handler(**kwargs):
+            yield "OK"
+
+        server = HttpServer(self.reactor, self._portNumber, handler, maxConnections=5)
+        server.listen()
+
+        self.reactor.getOpenConnections = lambda: 10
+
+        sock = socket()
+        sock.connect(('localhost', self._portNumber))
+        self.reactor.step()
+        sock.send("GET / HTTP/1.0\r\n\r\n")
+        self.reactor.step()
+        self.reactor.step()
+
+        self.assertEquals('HTTP/1.0 503 Service Unavailable\r\n\r\n<html><head></head><body><h1>Service Unavailable</h1></body></html>', sock.recv(1024))
+
+
+    #def testUncaughtException(self):
+        #done = []
+        #def onRequest(**kwargs):
+            #yield "HTTP\1.0 200 Ok\r\n\r\nStart data"
+            #done.append('onRequest')
+            #raise Exception("This exception is printed.")
+        #port = randint(10000, 2**16)
+        #reactor = Reactor()
+        #server = HttpServer(reactor, port, onRequest)
+        #sok = socket()
+        #sok.connect(('localhost', port))
+        #sok.send('GET / HTTP/1.0\r\n\r\n')
+        #reactor.addTimer(0.2, lambda: self.fail("Test Stuck"))
+        #while not done:
+            #reactor.step()
+
+        #try:
+            #sok.recv(4000) # wie een beter plan heeft mag het zeggen
+            #self.fail('Socket not closed by server')
+        #except SocketError, e:
+            #print "asdf", type(e), str(e)
+
+        ## 1. socket closed
+        ## 2. exceptie geraised (print or whatever)
+
+
+
+    #def testPrematureClientClose(self):
+        """Seen in certain phases of the moon. Kvs has not (20071101) been able to reproduce this in tests."""
+        #self.almostDone = False
+        #self.done = False
+
+        #def handler(**kwargs):
+            #if self.almostDone == True:
+                #self.done = True
+                #raise StopIteration()
+            #if kwargs.get("Body", None) == 'abcde':
+                #self.almostDone = True
+
+        #port = randint(20000,25000)
+        #reactor = Reactor()
+        #server = HttpServer(reactor, port, handler, timeout=0.01)
+        #sok = socket()
+        #sok.connect(('localhost', port))
+        #sok.send('POST / HTTP/1.0\r\nContent-Type: application/x-www-form-urlencoded\r\nTransfer-Encoding: chunked\r\n\r\n5\r\nabcde\r\n0\r\n')
+
+        #reactor.addTimer(0.2, lambda: self.fail("Test Stuck"))
+        #while not self.done:
+            #reactor.step()
diff --unidirectional-new-file '--exclude=*.so' '--exclude=*.o' '--exclude=.svn' '--exclude=*.pyc' '--exclude=deps.d' '--exclude=applied' --recursive --unified version_0/test/http/httpspectest.py version_1/test/http/httpspectest.py
--- version_0/test/http/httpspectest.py	1970-01-01 01:00:00.000000000 +0100
+++ version_1/test/http/httpspectest.py	2011-02-15 08:48:27.000000000 +0100
@@ -0,0 +1,32 @@
+## begin license ##
+#
+#    Weightless is a High Performance Asynchronous Networking Library
+#    See http://weightless.io
+#    Copyright (C) 2006-2011 Seek You Too (CQ2) http://www.cq2.nl
+#
+#    This file is part of Weightless
+#
+#    Weightless is free software; you can redistribute it and/or modify
+#    it under the terms of the GNU General Public License as published by
+#    the Free Software Foundation; either version 2 of the License, or
+#    (at your option) any later version.
+#
+#    Weightless is distributed in the hope that it will be useful,
+#    but WITHOUT ANY WARRANTY; without even the implied warranty of
+#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+#    GNU General Public License for more details.
+#
+#    You should have received a copy of the GNU General Public License
+#    along with Weightless; if not, write to the Free Software
+#    Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+#
+## end license ##
+from unittest import TestCase
+
+from weightless.http import httpspec
+
+class HttpSpecTest(TestCase):
+    def testParseHeader(self):
+        self.assertEquals(('aap', {}), httpspec.parseHeader('aap'))
+        self.assertEquals(('aap', {'noot': 'mies'}), httpspec.parseHeader('aap; noot=mies'))
+        self.assertEquals(('aap', {'noot': 'mies', 'vis': 'vuur'}), httpspec.parseHeader('aap; noot=mies; vis=vuur'))
\ No newline at end of file
diff --unidirectional-new-file '--exclude=*.so' '--exclude=*.o' '--exclude=.svn' '--exclude=*.pyc' '--exclude=deps.d' '--exclude=applied' --recursive --unified version_0/test/http/httpsservertest.py version_1/test/http/httpsservertest.py
--- version_0/test/http/httpsservertest.py	1970-01-01 01:00:00.000000000 +0100
+++ version_1/test/http/httpsservertest.py	2011-02-15 08:48:27.000000000 +0100
@@ -0,0 +1,67 @@
+# -*- coding: utf-8 -*-
+## begin license ##
+#
+#    Weightless is a High Performance Asynchronous Networking Library
+#    See http://weightless.io
+#    Copyright (C) 2006-2011 Seek You Too (CQ2) http://www.cq2.nl
+#
+#    This file is part of Weightless
+#
+#    Weightless is free software; you can redistribute it and/or modify
+#    it under the terms of the GNU General Public License as published by
+#    the Free Software Foundation; either version 2 of the License, or
+#    (at your option) any later version.
+#
+#    Weightless is distributed in the hope that it will be useful,
+#    but WITHOUT ANY WARRANTY; without even the implied warranty of
+#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+#    GNU General Public License for more details.
+#
+#    You should have received a copy of the GNU General Public License
+#    along with Weightless; if not, write to the Free Software
+#    Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+#
+## end license ##
+
+from unittest import TestCase
+from random import randint
+
+from weightless.io import Reactor
+from weightless.http import HttpsServer
+
+from OpenSSL import SSL
+from subprocess import Popen, PIPE
+
+class HttpsServerTest(TestCase):
+
+    def setUp(self):
+        self.reactor = Reactor()
+
+    def tearDown(self):
+        self.reactor.shutdown()
+        self.reactor = None
+
+    def testConnect(self):
+        self.req = False
+        serverResponse = 'Hello World'
+        def onRequest(**kwargs):
+            yield 'HTTP/1.0 200 OK\r\n\r\n' + serverResponse
+            self.req = True
+
+        port = randint(15000, 16000)
+        reactor = Reactor()
+        server = HttpsServer(reactor, port, onRequest, keyfile='ssl/server.pkey', certfile='ssl/server.cert')
+
+        p = Popen('wget -O - --no-check-certificate --quiet https://localhost:%s' % port, shell=True, stdout=PIPE)
+
+        popenStdout = []
+        def readPopenStdout():
+            popenStdout.append(p.stdout.read())
+        reactor.addReader(p.stdout, readPopenStdout)
+
+        while not self.req:
+           reactor.step()
+
+        reactor.step()
+        self.assertEquals(1, len(popenStdout))
+        self.assertEquals(serverResponse, popenStdout[0])
diff --unidirectional-new-file '--exclude=*.so' '--exclude=*.o' '--exclude=.svn' '--exclude=*.pyc' '--exclude=deps.d' '--exclude=applied' --recursive --unified version_0/test/http/__init__.py version_1/test/http/__init__.py
--- version_0/test/http/__init__.py	1970-01-01 01:00:00.000000000 +0100
+++ version_1/test/http/__init__.py	2011-02-15 08:48:27.000000000 +0100
@@ -0,0 +1,24 @@
+## begin license ##
+#
+#    Weightless is a High Performance Asynchronous Networking Library
+#    See http://weightless.io
+#    Copyright (C) 2006-2011 Seek You Too (CQ2) http://www.cq2.nl
+#
+#    This file is part of Weightless
+#
+#    Weightless is free software; you can redistribute it and/or modify
+#    it under the terms of the GNU General Public License as published by
+#    the Free Software Foundation; either version 2 of the License, or
+#    (at your option) any later version.
+#
+#    Weightless is distributed in the hope that it will be useful,
+#    but WITHOUT ANY WARRANTY; without even the implied warranty of
+#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+#    GNU General Public License for more details.
+#
+#    You should have received a copy of the GNU General Public License
+#    along with Weightless; if not, write to the Free Software
+#    Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+#
+## end license ##
+
diff --unidirectional-new-file '--exclude=*.so' '--exclude=*.o' '--exclude=.svn' '--exclude=*.pyc' '--exclude=deps.d' '--exclude=applied' --recursive --unified version_0/test/http/suspendtest.py version_1/test/http/suspendtest.py
--- version_0/test/http/suspendtest.py	1970-01-01 01:00:00.000000000 +0100
+++ version_1/test/http/suspendtest.py	2011-02-15 08:48:27.000000000 +0100
@@ -0,0 +1,336 @@
+## begin license ##
+#
+#    Weightless is a High Performance Asynchronous Networking Library
+#    See http://weightless.io
+#    Copyright (C) 2010-2011 Seek You Too (CQ2) http://www.cq2.nl
+#
+#    This file is part of Weightless
+#
+#    Weightless is free software; you can redistribute it and/or modify
+#    it under the terms of the GNU General Public License as published by
+#    the Free Software Foundation; either version 2 of the License, or
+#    (at your option) any later version.
+#
+#    Weightless is distributed in the hope that it will be useful,
+#    but WITHOUT ANY WARRANTY; without even the implied warranty of
+#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+#    GNU General Public License for more details.
+#
+#    You should have received a copy of the GNU General Public License
+#    along with Weightless; if not, write to the Free Software
+#    Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+#
+## end license ##
+
+from sys import exc_info
+import sys
+from StringIO import StringIO
+from unittest import TestCase
+from re import sub
+from traceback import format_exc
+
+from cq2utils import CallTrace, CQ2TestCase
+
+from weightless.io import Reactor
+from weightless.http import Suspend, HttpServer
+
+class MockSocket(object):
+    def close(self):
+        self.closed = True
+
+def mockselect(readers, writers, x, timeout):
+    return readers, writers, x
+
+fileDict = {
+    '__file__': mockselect.func_code.co_filename, # Hacky, but sys.modules[aModuleName].__file__ is inconsistent with traceback-filenames
+    'suspend.py': Suspend.__call__.func_code.co_filename,
+}
+
+
+class SuspendTest(CQ2TestCase):
+
+    def testReactorSuspend(self):
+        handle = ['initial value']
+        reactor = Reactor(select_func=mockselect)
+        def callback():
+            handle[0] = reactor.suspend()
+        sok = MockSocket()
+        reactor.addReader(sok, callback)
+        self.assertTrue(sok in reactor._readers)
+        reactor.step()
+        self.assertTrue(sok not in reactor._readers)
+
+        sok = MockSocket()
+        reactor.addWriter(sok, callback)
+        self.assertTrue(sok in reactor._writers)
+        reactor.step()
+        self.assertTrue(sok not in reactor._writers)
+        self.assertTrue(handle[0] != None)
+        self.assertTrue(handle[0] != 'initial value')
+
+    def testReactorResumeWriter(self):
+        handle = ['initial value']
+        reactor = Reactor(select_func=mockselect)
+        def callback():
+            handle[0] = reactor.suspend()
+            yield
+            yield
+        sok = MockSocket()
+        reactor.addWriter(sok, callback().next)
+        reactor.step()
+        reactor.resumeWriter(handle[0])
+        reactor.step()
+        self.assertTrue(sok in reactor._writers)
+        self.assertTrue(sok not in reactor._readers)
+        self.assertRaises(KeyError, reactor.resumeWriter, handle[0])
+
+    def testWrongUseAfterSuspending(self):
+        reactor = Reactor(select_func=mockselect)
+        handle = ['initial value']
+        def callback():
+            handle[0] = reactor.suspend()
+        sok = MockSocket()
+        reactor.addWriter(sok, callback)
+        reactor.step()
+        self.assertEquals(sok, handle[0])
+        try:
+            reactor.addWriter(sok, callback)
+            self.fail("Exception not raised")
+        except ValueError, e:
+            self.assertEquals('Socket is suspended', str(e))
+        try:
+            reactor.addReader(sok, callback)
+            self.fail("Exception not raised")
+        except ValueError, e:
+            self.assertEquals('Socket is suspended', str(e))
+
+    def testShutdownReactor(self):
+        reactor = Reactor(select_func=mockselect)
+        sok1 = MockSocket()
+        sok2 = MockSocket()
+        sok3 = MockSocket()
+        def callback():
+            reactor.suspend()
+        reactor.addReader(sok1, lambda: None)
+        reactor.addWriter(sok2, lambda: None)
+        reactor.addWriter(sok3, callback)
+        reactor.step()
+        self.assertFalse(sok3 in reactor._readers)
+        self.assertFalse(sok3 in reactor._writers)
+        reactor.shutdown() 
+        self.assertTrue(sok1.closed)
+        self.assertTrue(sok2.closed)
+        self.assertTrue(sok3.closed)
+
+    def testSuspendProtocol(self):
+        reactor = Reactor(select_func=mockselect)
+        suspend = Suspend()
+        def handler(**httpvars):
+            yield 'before suspend'
+            yield suspend
+            yield "result = %s" % suspend.getResult()
+            yield 'after suspend'
+        listener = MyMockSocket()
+        port = 9
+        httpserver = HttpServer(reactor, port, handler, sok=listener)
+        httpserver.listen()
+        reactor.removeReader(listener) # avoid new connections
+        httpserver._acceptor._accept()
+        reactor.step()
+        reactor.step()
+        self.assertEquals(1, len(reactor._writers))
+        reactor.step()
+        self.assertEquals(reactor, suspend._reactor)
+        self.assertEquals(0, len(reactor._writers))
+        suspend.resume('RESPONSE')
+        reactor.step()
+        reactor.step()
+        reactor.step()
+        self.assertEquals(['before suspend', 'result = RESPONSE', 'after suspend'], listener.data)
+
+    def testSuspendProtocolWithThrow(self):
+        reactor = Reactor(select_func=mockselect)
+        suspend = Suspend()
+        def handler(**httpvars):
+            yield 'before suspend'
+            yield suspend
+            try:
+                suspend.getResult()
+                self.fail()
+            except ValueError, e:
+                tbstring = format_exc()
+                yield "result = %s" % tbstring
+            yield 'after suspend'
+        listener = MyMockSocket()
+        port = 9
+        httpserver = HttpServer(reactor, port, handler, sok=listener)
+        httpserver.listen()
+        reactor.removeReader(listener) # avoid new connections
+        httpserver._acceptor._accept()
+        reactor.step()
+        reactor.step()
+        self.assertEquals(1, len(reactor._writers))
+        reactor.step()
+        self.assertEquals(reactor, suspend._reactor)
+        self.assertEquals(0, len(reactor._writers))
+        def raiser():
+            raise ValueError("BAD VALUE")
+        try:
+            raiser()
+        except ValueError, e:
+            exc_type, exc_value, exc_traceback = exc_info()
+            suspend.throw(exc_type, exc_value, exc_traceback)
+        reactor.step()
+        reactor.step()
+        reactor.step()
+        expectedTraceback = ignoreLineNumbers("""Traceback (most recent call last):
+  File "%(__file__)s", line 152, in handler
+    suspend.getResult()
+  File "%(__file__)s", line 172, in testSuspendProtocolWithThrow
+    raiser()
+  File "%(__file__)s", line 170, in raiser
+    raise ValueError("BAD VALUE")
+ValueError: BAD VALUE
+        """ % fileDict)
+        self.assertEquals(3, len(listener.data))
+        self.assertEquals('before suspend', listener.data[0])
+        self.assertEqualsWS("result = %s" % expectedTraceback, ignoreLineNumbers(listener.data[1]))
+        self.assertEquals('after suspend', listener.data[2])
+
+    def testDoNextErrorReRaisedOnGetResult(self):
+        def razor(ignored):
+            1/0  # Division by zero exception
+        suspend = Suspend(doNext=razor)
+        olderr = sys.stderr
+        sys.stderr = StringIO()
+        try:
+            suspend(reactor=CallTrace(), whenDone="not called")
+        finally:
+            sys.stderr = olderr
+        try:
+            suspend.getResult()
+        except:
+            exc_type, exc_value, exc_traceback = exc_info()
+
+
+        expectedTraceback = ignoreLineNumbers("""Traceback (most recent call last):
+  File "%(__file__)s", line 200, in testDoNextErrorReRaisedOnGetResult
+    suspend.getResult()
+  File "%(suspend.py)s", line 40, in __call__
+    self._doNext(self)
+  File "%(__file__)s", line 196, in razor
+    1/0  # Division by zero exception
+ZeroDivisionError: integer division or modulo by zero
+        """ % fileDict)
+        self.assertEquals(ZeroDivisionError, exc_type)
+        self.assertEqualsWS(expectedTraceback, ignoreLineNumbers(format_exc(exc_traceback)))
+
+    def testSuspendThrowBackwardsCompatibleWithInstanceOnlyThrow_YouWillMissTracebackHistory(self):
+        reactor = Reactor(select_func=mockselect)
+        suspend = Suspend()
+        def handler(**httpvars):
+            yield 'before suspend'
+            yield suspend
+            try:
+                suspend.getResult()
+                self.fail()
+            except ValueError, e:
+                tbstring = format_exc()
+                yield "result = %s" % tbstring
+            yield 'after suspend'
+        listener = MyMockSocket()
+        port = 9
+        httpserver = HttpServer(reactor, port, handler, sok=listener)
+        httpserver.listen()
+        reactor.removeReader(listener) # avoid new connections
+        httpserver._acceptor._accept()
+        reactor.step()
+        reactor.step()
+        self.assertEquals(1, len(reactor._writers))
+        reactor.step()
+        self.assertEquals(reactor, suspend._reactor)
+        self.assertEquals(0, len(reactor._writers))
+        def raiser():
+            raise ValueError("BAD VALUE")
+        try:
+            raiser()
+        except:
+            exc_value = exc_info()[1]
+            suspend.throw(exc_value)
+        reactor.step()
+        reactor.step()
+        reactor.step()
+        expectedTraceback = ignoreLineNumbers("""Traceback (most recent call last):
+  File "%(__file__)s", line 201, in handler
+    suspend.getResult()
+  File "%(suspend.py)s", line 62, in getResult
+    raise self._exception[0], self._exception[1], self._exception[2] 
+ValueError: BAD VALUE
+        """ % fileDict)
+        self.assertEquals(3, len(listener.data))
+        self.assertEquals('before suspend', listener.data[0])
+        self.assertEqualsWS("result = %s" % expectedTraceback, ignoreLineNumbers(listener.data[1]))
+        self.assertEquals('after suspend', listener.data[2])
+
+    def testGetResult(self):
+        reactor = CallTrace('reactor')
+        s = Suspend()
+        s(reactor, whenDone=lambda:None)
+        s.resume('state')
+        self.assertEquals('state', s.getResult())
+
+    def testGetNoneResult(self):
+        reactor = CallTrace('reactor')
+        s = Suspend()
+        s(reactor, whenDone=lambda:None)
+        s.resume()
+        self.assertEquals(None, s.getResult())
+
+    def testGetResultRaisesException(self):
+        reactor = CallTrace('reactor')
+        s = Suspend()
+        s(reactor, whenDone=lambda:None)
+        s.throw(ValueError('bad value'))
+        self.assertRaises(ValueError, s.getResult)
+
+    def testCleanUp(self):
+        reactor = Reactor(select_func=mockselect)
+        def handler():
+            reactor.suspend()
+            yield
+        reactor.addWriter(1, lambda: None)
+        reactor.addReader(2, lambda: None)
+        reactor.addReader(3, handler().next)
+        reactor.step()
+        self.assertTrue(1 in reactor._writers)
+        reactor.cleanup(1)
+        self.assertFalse(1 in reactor._writers)
+        self.assertTrue(2 in reactor._readers)
+        reactor.cleanup(2)
+        self.assertFalse(2 in reactor._readers)
+        self.assertTrue(3 in reactor._suspended)
+        reactor.cleanup(3)
+        self.assertFalse(3 in reactor._suspended)
+
+class MyMockSocket(object):
+    def __init__(self, data=None):
+        self.data = [] if data is None else data
+    def accept(self):
+        return MyMockSocket(self.data), None
+    def setsockopt(self, *args):
+        pass
+    def recv(self, *args):
+        return 'GET / HTTP/1.0\r\n\r\n'
+    def getpeername(self):
+        return 'itsme'
+    def shutdown(self, *args):
+        pass
+    def close(self):
+        pass
+    def send(self, chunk, options):
+        self.data.append(chunk)
+        return len(chunk)
+
+def ignoreLineNumbers(s):
+    return sub("line \d+,", "line [#],", s)
+
Only in version_0/test: httpreadertest.py
Only in version_0/test: httpservertest.py
Only in version_0/test: httpspectest.py
Only in version_0/test: httpsservertest.py
diff --unidirectional-new-file '--exclude=*.so' '--exclude=*.o' '--exclude=.svn' '--exclude=*.pyc' '--exclude=deps.d' '--exclude=applied' --recursive --unified version_0/test/integrationtest.py version_1/test/integrationtest.py
--- version_0/test/integrationtest.py	2011-02-12 11:50:45.000000000 +0100
+++ version_1/test/integrationtest.py	2011-02-15 08:48:29.000000000 +0100
@@ -2,7 +2,8 @@
 ## begin license ##
 #
 #    Weightless is a High Performance Asynchronous Networking Library
-#    Copyright (C) 2006-2009 Seek You Too (CQ2) http://www.cq2.nl
+#    See http://weightless.io
+#    Copyright (C) 2006-2011 Seek You Too (CQ2) http://www.cq2.nl
 #
 #    This file is part of Weightless
 #
@@ -33,7 +34,8 @@
 
 from unittest import TestCase, main
 
-from weightless import Reactor, HttpServer
+from weightless.io import Reactor
+from weightless.http import HttpServer
 from socket import socket
 from time import sleep
 
@@ -94,4 +96,4 @@
         self.assertEquals(1, len(reactor._readers))
 
 if __name__ == '__main__':
-    main()
\ No newline at end of file
+    main()
diff --unidirectional-new-file '--exclude=*.so' '--exclude=*.o' '--exclude=.svn' '--exclude=*.pyc' '--exclude=deps.d' '--exclude=applied' --recursive --unified version_0/test/localtest.py version_1/test/localtest.py
--- version_0/test/localtest.py	1970-01-01 01:00:00.000000000 +0100
+++ version_1/test/localtest.py	2011-02-15 08:48:29.000000000 +0100
@@ -0,0 +1,107 @@
+## begin license ##
+#
+#    Weightless is a High Performance Asynchronous Networking Library
+#    See http://weightless.io
+#    Copyright (C) 2009-2011 Seek You Too (CQ2) http://www.cq2.nl
+#
+#    This file is part of Weightless
+#
+#    Weightless is free software; you can redistribute it and/or modify
+#    it under the terms of the GNU General Public License as published by
+#    the Free Software Foundation; either version 2 of the License, or
+#    (at your option) any later version.
+#
+#    Weightless is distributed in the hope that it will be useful,
+#    but WITHOUT ANY WARRANTY; without even the implied warranty of
+#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+#    GNU General Public License for more details.
+#
+#    You should have received a copy of the GNU General Public License
+#    along with Weightless; if not, write to the Free Software
+#    Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+#
+## end license ##
+
+from unittest import TestCase
+from weightless.core import local
+
+class LocalTest(TestCase):
+
+    def testScope(self):
+        _some_var_on_the_callstack_ = 'aap'
+        v = local('_some_var_on_the_callstack_')
+        self.assertEquals('aap', v)
+
+    def testNone(self):
+        var = None
+        self.assertEquals(None, local('var'))
+
+    def testNotFound(self):
+        try:
+            v = local('no_such_thing')
+            print "V", v
+            self.fail()
+        except AttributeError:
+            pass
+
+    def testVariousTypes(self):
+        strArgument = 'string'
+        self.assertEquals('string', local('strArgument'))
+        intArgument = 1
+        self.assertEquals(1, local('intArgument'))
+
+        class MyObject(object):
+            pass
+        objArgument = MyObject()
+        self.assertEquals(objArgument, local('objArgument'))
+
+    def testScoping(self):
+        class MyObject(object):
+            pass
+        refs = []
+        def function():
+            toplevel=MyObject()
+            refs.append(local('toplevel'))
+        function()
+        self.assertEquals(1, len(refs))
+        self.assertEquals(MyObject, type(refs[0]))
+
+    def testOne(self):
+        a=1
+        b=2
+        c=3
+        def f1():
+            d=4
+            a=10
+            b=6
+            self.assertEquals(4, local('d'))
+            self.assertEquals(10, local('a'))
+        f1()
+        self.assertEquals(2, local('b'))
+        self.assertEquals(1, local('a'))
+
+    def testWithGenerator(self):
+        results = []
+        _z_ = 9
+        def e():
+            yield
+            results.append(local('_x_'))
+            yield
+            results.append(local('_y_'))
+            yield
+            results.append(local('_z_'))
+        def f():
+            _x_ = 10
+            yield
+            _y_ = 11
+            list(e())
+        list(f())
+        self.assertEquals([10,11,9], results)
+
+    def testLookupSelfWhileBeingInitialized(self):
+        try:
+            tx = local('tx')
+            self.fail()
+        except AttributeError:
+            pass
+
diff --unidirectional-new-file '--exclude=*.so' '--exclude=*.o' '--exclude=.svn' '--exclude=*.pyc' '--exclude=deps.d' '--exclude=applied' --recursive --unified version_0/test/reactortest.py version_1/test/reactortest.py
--- version_0/test/reactortest.py	2011-02-12 11:50:45.000000000 +0100
+++ version_1/test/reactortest.py	2011-02-15 08:48:29.000000000 +0100
@@ -1,7 +1,8 @@
 ## begin license ##
 #
 #    Weightless is a High Performance Asynchronous Networking Library
-#    Copyright (C) 2006-2009 Seek You Too (CQ2) http://www.cq2.nl
+#    See http://weightless.io
+#    Copyright (C) 2006-2011 Seek You Too (CQ2) http://www.cq2.nl
 #
 #    This file is part of Weightless
 #
@@ -29,7 +30,7 @@
 import os, sys
 from tempfile import mkstemp
 from StringIO import StringIO
-from weightless import Reactor
+from weightless.io import Reactor
 from socket import socketpair, error
 
 class ReactorTest(TestCase):
@@ -322,7 +323,7 @@
             self.assertEquals([], reactor._timers)
 
     def testGlobalReactor(self):
-        from weightless import reactor
+        from weightless.io import reactor
         thereactor = Reactor()
         def handler():
             self.assertEquals(thereactor, reactor())
diff --unidirectional-new-file '--exclude=*.so' '--exclude=*.o' '--exclude=.svn' '--exclude=*.pyc' '--exclude=deps.d' '--exclude=applied' --recursive --unified version_0/test/servertestcase.py version_1/test/servertestcase.py
--- version_0/test/servertestcase.py	2011-02-12 11:50:45.000000000 +0100
+++ version_1/test/servertestcase.py	2011-02-15 08:48:29.000000000 +0100
@@ -1,7 +1,8 @@
 ## begin license ##
 #
 #    Weightless is a High Performance Asynchronous Networking Library
-#    Copyright (C) 2006-2009 Seek You Too (CQ2) http://www.cq2.nl
+#    See http://weightless.io
+#    Copyright (C) 2006-2011 Seek You Too (CQ2) http://www.cq2.nl
 #
 #    This file is part of Weightless
 #
diff --unidirectional-new-file '--exclude=*.so' '--exclude=*.o' '--exclude=.svn' '--exclude=*.pyc' '--exclude=deps.d' '--exclude=applied' --recursive --unified version_0/test/servertestcasetest.py version_1/test/servertestcasetest.py
--- version_0/test/servertestcasetest.py	2011-02-12 11:50:45.000000000 +0100
+++ version_1/test/servertestcasetest.py	2011-02-15 08:48:29.000000000 +0100
@@ -1,7 +1,8 @@
 ## begin license ##
 #
 #    Weightless is a High Performance Asynchronous Networking Library
-#    Copyright (C) 2006-2009 Seek You Too (CQ2) http://www.cq2.nl
+#    See http://weightless.io
+#    Copyright (C) 2006-2011 Seek You Too (CQ2) http://www.cq2.nl
 #
 #    This file is part of Weightless
 #
diff --unidirectional-new-file '--exclude=*.so' '--exclude=*.o' '--exclude=.svn' '--exclude=*.pyc' '--exclude=deps.d' '--exclude=applied' --recursive --unified version_0/test/sidekicktest.py version_1/test/sidekicktest.py
--- version_0/test/sidekicktest.py	2011-02-12 11:50:45.000000000 +0100
+++ version_1/test/sidekicktest.py	2011-02-15 08:48:29.000000000 +0100
@@ -1,6 +1,29 @@
+## begin license ##
+#
+#    Weightless is a High Performance Asynchronous Networking Library
+#    See http://weightless.io
+#    Copyright (C) 2010-2011 Seek You Too (CQ2) http://www.cq2.nl
+#
+#    This file is part of Weightless
+#
+#    Weightless is free software; you can redistribute it and/or modify
+#    it under the terms of the GNU General Public License as published by
+#    the Free Software Foundation; either version 2 of the License, or
+#    (at your option) any later version.
+#
+#    Weightless is distributed in the hope that it will be useful,
+#    but WITHOUT ANY WARRANTY; without even the implied warranty of
+#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+#    GNU General Public License for more details.
+#
+#    You should have received a copy of the GNU General Public License
+#    along with Weightless; if not, write to the Free Software
+#    Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+#
+## end license ##
 from unittest import TestCase
-from weightless import compose
-
+from weightless.core import compose
+from sys import exc_info
 
 class SidekickTest(TestCase):
 
@@ -41,3 +64,41 @@
         self.assertEquals(None, none)
         self.assertEquals(['a', 'b'], data)
         self.assertEquals(['sidekick'], called)
+
+    def testCallableRaisesException(self):
+        def command(sidekick):
+            raise RuntimeError("runtimeError")
+        def f():
+            yield command
+        c = compose(f(), sidekick="sidekick")
+        try:
+            c.next()
+            self.fail()
+        except RuntimeError, e:
+            self.assertEquals("runtimeError", str(e))
+
+    def testCallableRaisesExceptionWhichIsCatchableByGenerators(self):
+        def command(sidekick):
+            raise RuntimeError("runtimeError")
+        def f():
+            try:
+                yield command
+            except RuntimeError, e:
+                yield str(e)
+        c = compose(f(), sidekick="sidekick")
+        self.assertEquals("runtimeError", c.next())
+
+    def testProperTracebackForCallable(self):
+        def command(sidekick):
+            raise RuntimeError("runtimeError")
+        def f():
+            yield command
+        c = compose(f(), sidekick="sidekick")
+        try:
+            c.next()
+            self.fail()
+        except RuntimeError, e:
+            exType, exValue, exTraceback = exc_info()
+            self.assertEquals('testProperTracebackForCallable', exTraceback.tb_frame.f_code.co_name)
+            self.assertEquals('f', exTraceback.tb_next.tb_frame.f_code.co_name)
+            self.assertEquals('command', exTraceback.tb_next.tb_next.tb_frame.f_code.co_name)
diff --unidirectional-new-file '--exclude=*.so' '--exclude=*.o' '--exclude=.svn' '--exclude=*.pyc' '--exclude=deps.d' '--exclude=applied' --recursive --unified version_0/test/snaketest.py version_1/test/snaketest.py
--- version_0/test/snaketest.py	2011-02-12 11:50:45.000000000 +0100
+++ version_1/test/snaketest.py	2011-02-15 08:48:29.000000000 +0100
@@ -1,7 +1,8 @@
 ## begin license ##
 #
 #    Weightless is a High Performance Asynchronous Networking Library
-#    Copyright (C) 2006-2009 Seek You Too (CQ2) http://www.cq2.nl
+#    See http://weightless.io
+#    Copyright (C) 2006-2011 Seek You Too (CQ2) http://www.cq2.nl
 #
 #    This file is part of Weightless
 #
@@ -25,7 +26,7 @@
 from imp import load_source
 from os import listdir
 from os.path import join
-from weightless import compose
+from weightless.core import compose
 import sys
 
 class MySimpleModule:
diff --unidirectional-new-file '--exclude=*.so' '--exclude=*.o' '--exclude=.svn' '--exclude=*.pyc' '--exclude=deps.d' '--exclude=applied' --recursive --unified version_0/test/speedComparisonCallVsCurryVsGeneratorVsClass.py version_1/test/speedComparisonCallVsCurryVsGeneratorVsClass.py
--- version_0/test/speedComparisonCallVsCurryVsGeneratorVsClass.py	2011-02-12 11:50:45.000000000 +0100
+++ version_1/test/speedComparisonCallVsCurryVsGeneratorVsClass.py	2011-02-15 08:48:29.000000000 +0100
@@ -1,7 +1,8 @@
 ## begin license ##
 #
 #    Weightless is a High Performance Asynchronous Networking Library
-#    Copyright (C) 2006-2009 Seek You Too (CQ2) http://www.cq2.nl
+#    See http://weightless.io
+#    Copyright (C) 2006-2011 Seek You Too (CQ2) http://www.cq2.nl
 #
 #    This file is part of Weightless
 #
diff --unidirectional-new-file '--exclude=*.so' '--exclude=*.o' '--exclude=.svn' '--exclude=*.pyc' '--exclude=deps.d' '--exclude=applied' --recursive --unified version_0/test/ssl/mk_simple_certs.py version_1/test/ssl/mk_simple_certs.py
--- version_0/test/ssl/mk_simple_certs.py	2011-02-12 11:50:45.000000000 +0100
+++ version_1/test/ssl/mk_simple_certs.py	2011-02-15 08:48:28.000000000 +0100
@@ -2,6 +2,7 @@
 ## begin license ##
 #
 #    Weightless is a High Performance Asynchronous Networking Library
+#    See http://weightless.io
 #    Copyright (C) 2009-2010 Seek You Too (CQ2) http://www.cq2.nl
 #
 #    This file is part of Weightless
Only in version_0/test: suspendtest.py
Only in version_0/test: transparentsockettest.py
diff --unidirectional-new-file '--exclude=*.so' '--exclude=*.o' '--exclude=.svn' '--exclude=*.pyc' '--exclude=deps.d' '--exclude=applied' --recursive --unified version_0/testsetup.sh version_1/testsetup.sh
--- version_0/testsetup.sh	2011-02-12 11:50:45.000000000 +0100
+++ version_1/testsetup.sh	2011-02-15 08:48:32.000000000 +0100
@@ -1,7 +1,8 @@
 ## begin license ##
 #
 #    Weightless is a High Performance Asynchronous Networking Library
-#    Copyright (C) 2006-2009 Seek You Too (CQ2) http://www.cq2.nl
+#    See http://weightless.io
+#    Copyright (C) 2006-2011 Seek You Too (CQ2) http://www.cq2.nl
 #
 #    This file is part of Weightless
 #
@@ -24,14 +25,14 @@
 
 rm -rf tmp build
 
-for pyversion in 2.4 2.5; do
+python2.5 setup.py install --root tmp
 
-PYTHONPATH=`pwd`/deps.d/Pyrex-0.9.5.1a python$pyversion setup.py install --root tmp
+export PYTHONPATH=`pwd`/tmp/usr/lib/python2.5/site-packages
+cp -r test tmp/test
 
 (
-cd test
-PYTHONPATH=`pwd`/../tmp/usr/lib/python$pyversion/site-packages python$pyversion alltests.py
+cd tmp/test
+./alltests.sh
 )
 
 rm -rf tmp build
-done
Only in version_0/weightless: _acceptor.py
Only in version_0/weightless: bufferedhandler.py
diff --unidirectional-new-file '--exclude=*.so' '--exclude=*.o' '--exclude=.svn' '--exclude=*.pyc' '--exclude=deps.d' '--exclude=applied' --recursive --unified version_0/weightless/core/compose/_compose.c version_1/weightless/core/compose/_compose.c
--- version_0/weightless/core/compose/_compose.c	1970-01-01 01:00:00.000000000 +0100
+++ version_1/weightless/core/compose/_compose.c	2011-02-15 08:48:32.000000000 +0100
@@ -0,0 +1,805 @@
+/* begin license *
+ *
+ *     Weightless is a High Performance Asynchronous Networking Library
+ *     See http://weightless.io
+ *     Copyright (C) 2009-2011 Seek You Too (CQ2) http://www.cq2.nl
+ *
+ *     This file is part of Weightless
+ *
+ *     Weightless is free software; you can redistribute it and/or modify
+ *     it under the terms of the GNU General Public License as published by
+ *     the Free Software Foundation; either version 2 of the License, or
+ *     (at your option) any later version.
+ *
+ *     Weightless is distributed in the hope that it will be useful,
+ *     but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *     GNU General Public License for more details.
+ *
+ *     You should have received a copy of the GNU General Public License
+ *     along with Weightless; if not, write to the Free Software
+ *     Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ *
+ * end license */
+
+/* This code is formatted with:
+ * astyle --style=java --indent-namespaces --break-blocks=all --pad-oper --unpad-paren --delete-empty-lines --align-pointer=type
+ */
+
+#include <Python.h>
+#include <frameobject.h>
+#include <structmember.h>
+
+
+
+////////// Python Object and Type structures //////////
+
+typedef struct {
+    PyObject_HEAD
+    int        expect_data;
+    PyObject** generators_base;
+    PyObject** generators_top;
+    int        generators_allocated;
+    PyObject** messages_base;
+    PyObject** messages_start;
+    PyObject** messages_end;
+    PyObject*  sidekick;
+    PyObject*  weakreflist;
+} PyComposeObject;
+
+PyAPI_DATA(PyTypeObject) PyCompose_Type;
+
+
+
+////////// Generator Stack //////////
+
+#define INITIAL_STACK_SIZE 10
+#define MAX_STACK_SIZE 1000
+
+static int generators_push(PyComposeObject* self, PyObject* generator) {
+    int current_stack_use = self->generators_top - self->generators_base;
+
+    if(current_stack_use >= self->generators_allocated) {
+        if(self->generators_allocated >= MAX_STACK_SIZE) {
+            PyErr_SetString(PyExc_RuntimeError, "maximum recursion depth exceeded (compose)");
+            return 0;
+        }
+
+        self->generators_allocated *= 2;
+
+        if(self->generators_allocated > MAX_STACK_SIZE)
+            self->generators_allocated = MAX_STACK_SIZE;
+
+        PyObject** newstack = realloc(self->generators_base, self->generators_allocated * sizeof(PyObject*));
+        self->generators_base = newstack;
+        self->generators_top = newstack + current_stack_use;
+    }
+
+    *self->generators_top++ = generator;
+    Py_INCREF(generator);
+    return 1;
+}
+
+
+
+////////// Messages Queue //////////
+
+#define QUEUE_SIZE 10
+
+static int messages_empty(PyComposeObject* self) {
+    return self->messages_start == self->messages_end;
+}
+
+
+static int _messages_size(PyComposeObject* self) {
+    // only reliable if and when the queue is NOT full !!
+    int size = self->messages_end - self->messages_start;
+    return size < 0 ? size + QUEUE_SIZE : size;
+}
+
+
+static PyObject* messages_next(PyComposeObject* self) {
+    if(messages_empty(self)) {
+        PyErr_SetString(PyExc_RuntimeError, "internal error: empty messages queue (compose)");
+        return NULL;
+    }
+
+    PyObject* result = *self->messages_start;
+    *self->messages_start++ = NULL;
+
+    if(self->messages_start == self->messages_base + QUEUE_SIZE) {
+        self->messages_start = self->messages_base;
+    }
+
+    return result;
+}
+
+
+static int messages_append(PyComposeObject* self, PyObject* message) {
+    if(_messages_size(self) >= QUEUE_SIZE - 1) {   // keep on entry free at all times
+        PyErr_SetString(PyExc_RuntimeError, "maximum return values exceeded (compose)");
+        return 0;
+    }
+
+    *self->messages_end++ = message;
+    Py_INCREF(message);
+
+    if(self->messages_end == self->messages_base + QUEUE_SIZE) {
+        self->messages_end = self->messages_base;
+    }
+
+    return 1;
+}
+
+
+static int messages_insert(PyComposeObject* self, PyObject* message) {
+    if(_messages_size(self) >= QUEUE_SIZE - 1) {
+        PyErr_SetString(PyExc_RuntimeError, "maximum return values exceeded (compose)");
+        return 0;
+    }
+
+    if(self->messages_start == self->messages_base) {
+        self->messages_start = self->messages_base + QUEUE_SIZE;
+    }
+
+    *--self->messages_start = message;
+    Py_INCREF(message);
+    return 1;
+}
+
+////////// Garbage Collector Support //////////
+
+static int compose_traverse(PyComposeObject* self, visitproc visit, void* arg) {
+    PyObject** p;
+
+    for(p = self->generators_base; p < self->generators_top; p++) {
+        Py_VISIT(*p);
+    }
+
+    for(p = self->messages_base; p < self->messages_base + QUEUE_SIZE; p++) {
+        Py_VISIT(*p);
+    }
+
+    Py_VISIT(self->sidekick);
+    return 0;
+}
+
+
+static int compose_clear(PyComposeObject* self) {
+    while(self->generators_base && --self->generators_top > self->generators_base) {
+        Py_CLEAR(*self->generators_top);
+    }
+
+    free(self->generators_base);
+    self->generators_base = NULL;
+
+    while(self->messages_base && !messages_empty(self)) {
+        Py_DECREF(messages_next(self));
+    }
+
+    free(self->messages_base);
+    self->messages_base = NULL;
+    Py_CLEAR(self->sidekick);
+    return 0;
+}
+
+
+static void compose_dealloc(PyComposeObject* self) {
+    PyObject_GC_UnTrack(self);
+
+    if(self->weakreflist != NULL) {
+        PyObject_ClearWeakRefs((PyObject*)self);
+    }
+
+    compose_clear(self);
+    PyObject_GC_Del(self);
+}
+
+
+
+////////// Compose Methods //////////
+
+static int PyCompose_Check(PyObject* obj) {
+    return PyObject_Type(obj) == (PyObject*) &PyCompose_Type;
+}
+
+
+static void _compose_initialize(PyComposeObject* cmps) {
+    cmps->expect_data = 0;
+    cmps->generators_allocated = INITIAL_STACK_SIZE;
+    cmps->generators_base = (PyObject**) malloc(cmps->generators_allocated * sizeof(PyObject*));
+    cmps->generators_top = cmps->generators_base;
+    cmps->messages_base = (PyObject**) calloc(QUEUE_SIZE, sizeof(PyObject*));
+    cmps->messages_start = cmps->messages_base;
+    cmps->messages_end = cmps->messages_base;
+    cmps->sidekick = NULL;
+    cmps->weakreflist = NULL;
+}
+
+
+static PyObject* compose_new(PyObject* type, PyObject* args, PyObject* kwargs) {
+    char* argnames[] = {"initial", "sidekick"};
+    PyObject* initial = NULL;
+    PyObject* sidekick = NULL;
+
+    if(!PyArg_ParseTupleAndKeywords(args, kwargs, "O|O:compose", argnames,
+                                    &initial, &sidekick)) return NULL;
+
+    if(!PyGen_Check(initial) && !PyCompose_Check(initial)) {
+        PyErr_SetString(PyExc_TypeError, "compose() argument 1 must be generator");
+        return NULL;
+    }
+
+    PyComposeObject* cmps = PyObject_GC_New(PyComposeObject, &PyCompose_Type);
+
+    if(cmps == NULL) return NULL;
+
+    _compose_initialize((PyComposeObject*) cmps);
+
+    if(!generators_push(cmps, initial)) return NULL;
+
+    if(sidekick) {
+        Py_INCREF(sidekick);
+        cmps->sidekick = sidekick;
+    }
+
+    PyObject_GC_Track(cmps);
+    return (PyObject*) cmps;
+}
+
+
+static int _compose_handle_stopiteration(PyComposeObject* self) {
+    PyObject* error_type, *error_value, *error_traceback;
+    PyErr_Fetch(&error_type, &error_value, &error_traceback); // clears exc, new refs or NULLs
+    PyObject* args = error_value
+                     ? PyObject_GetAttrString(error_value, "args") // new ref
+                     : NULL;
+    Py_XDECREF(error_type);
+    Py_XDECREF(error_value);
+    Py_XDECREF(error_traceback);
+
+    if(args && PyTuple_CheckExact(args)) {
+        int i;
+
+        for(i = PyTuple_Size(args) - 1; i >= 0; i--) {
+            if(!messages_insert(self, PyTuple_GET_ITEM(args, i))) {
+                Py_DECREF(args);
+                return 0;
+            }
+        }
+
+        Py_DECREF(args);
+
+    } else {
+        messages_insert(self, Py_None);
+    }
+    return 1;
+}
+
+
+static int generator_invalid(PyObject* gen) {
+    PyFrameObject* frame = ((PyGenObject*)gen)->gi_frame;
+
+    if(!frame) {
+        PyErr_SetString(PyExc_AssertionError, "Generator is exhausted.");
+        return 1;
+    }
+
+    if(frame->f_lasti != -1) {  // fresh generator, see genobject.c
+        PyErr_SetString(PyExc_AssertionError, "Generator already used.");
+        return 1;
+    }
+
+    return 0;
+}
+
+
+static PyObject* _compose_go(PyComposeObject* self, PyObject* exc_type, PyObject* exc_value, PyObject* exc_tb) {
+    while(self->generators_top > self->generators_base) {
+        PyObject* generator = *(self->generators_top - 1); // take over ownership from stack
+        PyObject* response = NULL;
+        PyObject* message = NULL;
+
+        if(exc_type) {
+            if(PyErr_GivenExceptionMatches(exc_type, PyExc_GeneratorExit)) {
+                PyObject* result = PyObject_CallMethod(generator, "close", NULL); // new ref
+
+                if(result) {
+                    Py_DECREF(result);
+                    Py_XINCREF(exc_type);
+                    Py_XINCREF(exc_value);
+                    Py_XINCREF(exc_tb);
+                    PyErr_Restore(exc_type, exc_value, exc_tb); //steals refs
+                    exc_type = exc_value = exc_tb = NULL;
+                }
+
+            } else {
+                response =
+                    PyObject_CallMethod(generator, "throw", "OOO",
+                                        exc_type,
+                                        exc_value ? exc_value : Py_None,
+                                        exc_tb ? exc_tb : Py_None); // new ref
+            }
+
+        } else {
+            message = messages_next(self); // new ref
+            response = PyObject_CallMethod(generator, "send", "O", message); // new ref
+            Py_DECREF(message);
+        }
+
+        if(response) {
+            if(PyGen_Check(response) || PyCompose_Check(response)) {
+                if(!generators_push(self, response)) return NULL;
+
+                if(PyGen_Check(response) && generator_invalid(response)) return NULL;
+
+                messages_insert(self, Py_None);
+
+            } else if(self->sidekick && PyCallable_Check(response)) {
+                messages_insert(self, message);
+                PyObject* r = PyObject_CallFunctionObjArgs(response, self->sidekick, NULL);
+
+                if(!r) {
+                    PyErr_Fetch(&exc_type, &exc_value, &exc_tb); // new refs
+
+                } else
+                    Py_XDECREF(r);
+
+            } else if(response != Py_None || messages_empty(self)) {
+                self->expect_data = response == Py_None;
+                Py_INCREF(response);
+                return response;
+            }
+        } else {
+            if(PyErr_ExceptionMatches(PyExc_StopIteration)) {
+                if(!_compose_handle_stopiteration(self)) {
+                    PyErr_Fetch(&exc_type, &exc_value, &exc_tb); // new refs
+                } else {
+                    exc_type = exc_value = exc_tb = NULL;
+                }
+            } else {
+                PyErr_Fetch(&exc_type, &exc_value, &exc_tb); // new refs
+            }
+            Py_DECREF(generator);
+            *self->generators_top-- = NULL;
+        }
+    }
+
+    if(exc_type) {
+        Py_XINCREF(exc_type);
+        Py_XINCREF(exc_value);
+        Py_XINCREF(exc_tb);
+        PyErr_Restore(exc_type, exc_value, exc_tb); // steals refs
+        exc_type = exc_value = exc_tb = NULL;
+        return NULL;
+    }
+
+    PyErr_SetNone(PyExc_StopIteration);
+    return NULL;
+}
+
+
+static PyObject* compose_send(PyComposeObject* self, PyObject* message) {
+    if(!self->expect_data && message != Py_None) {
+        PyErr_SetString(PyExc_AssertionError, "Cannot accept data. First send None.");
+        return NULL;
+    }
+
+    messages_append(self, message);
+
+    if(!self->expect_data && self->messages_start[0] != Py_None)
+        messages_insert(self, Py_None);
+
+    return _compose_go(self, NULL, NULL, NULL);
+}
+
+
+static PyObject* compose_throw(PyComposeObject* self, PyObject* arg) {
+    PyObject *exc_type = NULL, *exc_value = NULL, *exc_tb = NULL;
+
+    // borrowed refs
+    if(!PyArg_ParseTuple(arg, "O|OO", &exc_type, &exc_value, &exc_tb)) {
+        return NULL;
+    }
+
+    if(PyExceptionInstance_Check(exc_type)) {
+        exc_value = exc_type;
+        exc_type = PyExceptionInstance_Class(exc_type); // borrowed ref
+    }
+
+    return _compose_go(self, exc_type, exc_value, exc_tb);
+}
+
+
+static PyObject* compose_close(PyComposeObject* self) {
+    _compose_go(self, PyExc_GeneratorExit, NULL, NULL);
+
+    if(PyErr_ExceptionMatches(PyExc_StopIteration) || PyErr_ExceptionMatches(PyExc_GeneratorExit)) {
+        PyErr_Clear();	/* ignore these errors */
+        Py_RETURN_NONE;
+    }
+
+    return NULL;
+}
+
+
+static void compose_del(PyObject* self) {
+    if(!compose_close((PyComposeObject*) self)) {
+        PyErr_WriteUnraisable(self);
+    }
+}
+
+
+static PyObject* compose_iternext(PyComposeObject* self) {
+    Py_INCREF(Py_None);
+    PyObject* result = compose_send(self, Py_None);
+    Py_DECREF(Py_None);
+    return result;
+}
+
+
+
+////////// local() implementation //////////
+
+PyObject* find_local_in_locals(PyFrameObject* frame, PyObject* name);
+
+
+PyObject* find_local_in_compose(PyComposeObject* cmps, PyObject* name) {
+    PyObject** generator = cmps->generators_top;
+
+    while(--generator >= cmps->generators_base) {
+        if(PyGen_Check(*generator)) {
+            PyObject* result = find_local_in_locals(((PyGenObject*) * generator)->gi_frame, name);
+
+            if(result != NULL) {
+                return result;
+            }
+
+        } else {
+            PyObject* result = find_local_in_compose((PyComposeObject*) * generator, name);
+
+            if(result != NULL) {
+                return result;
+            }
+        }
+    }
+
+    return NULL;
+}
+
+
+PyObject* find_local_in_locals(PyFrameObject* frame, PyObject* name) {
+    int i;
+
+    for(i = 0; i < PyTuple_Size(frame->f_code->co_varnames); i++) {
+        PyObject* localVar = frame->f_localsplus[i];
+
+        if(localVar) {
+            PyObject* localName = PyTuple_GetItem(frame->f_code->co_varnames, i);
+
+            if(_PyString_Eq(name, localName)) {
+                Py_INCREF(localVar);
+                return localVar;
+            }
+
+            if(localVar->ob_type == &PyCompose_Type) {
+                return find_local_in_compose((PyComposeObject*)localVar, name);
+            }
+        }
+    }
+
+    return NULL;
+}
+
+
+PyObject* find_local_in_frame(PyFrameObject* frame, PyObject* name) {
+    if(!frame) return NULL;
+
+    PyObject* result = find_local_in_locals(frame, name);
+
+    if(result) {
+        return result;
+    }
+
+    return find_local_in_frame(frame->f_back, name);
+}
+
+
+PyObject* local(PyObject* self, PyObject* name) {
+    PyFrameObject* frame = PyEval_GetFrame();
+    PyObject* result = find_local_in_frame(frame, name);
+
+    if(!result) {
+        PyErr_SetString(PyExc_AttributeError, PyString_AsString(name));
+        return NULL;
+    }
+
+    return result;
+}
+
+
+
+////////// tostring //////////
+
+PyObject* py_getline;
+
+PyObject* tostring(PyObject* self, PyObject* gen) {
+    if(PyGen_Check(gen)) {
+        PyFrameObject* frame = ((PyGenObject*)gen)->gi_frame;
+        int ilineno = PyCode_Addr2Line(frame->f_code, frame->f_lasti);
+        PyObject* lineno = PyInt_FromLong(ilineno); // new ref
+        PyObject* codeline = PyObject_CallFunctionObjArgs(py_getline,
+                             frame->f_code->co_filename, lineno, NULL); // new ref
+        Py_DECREF(lineno);
+
+        if(!codeline) return NULL;
+
+        PyObject* codeline_stripped = PyObject_CallMethod(codeline, "strip", NULL); // new ref
+        Py_DECREF(codeline);
+
+        if(!codeline_stripped) return NULL;
+
+        PyObject* result =
+            PyString_FromFormat("  File \"%s\", line %d, in %s\n    %s",
+                                PyString_AsString(frame->f_code->co_filename),
+                                ilineno, PyString_AsString(frame->f_code->co_name),
+                                PyString_AsString(codeline_stripped)); // new ref
+        Py_DECREF(codeline_stripped);
+        return result;
+
+    } else if(gen->ob_type == &PyCompose_Type) {
+        PyComposeObject* cmps = (PyComposeObject*) gen;
+        PyObject* result = NULL;
+        PyObject** generator = cmps->generators_base;
+
+        while(generator < cmps->generators_top) {
+            PyObject* s = tostring(NULL, *generator++);
+
+            if(!result) {
+                result = s;
+
+            } else {
+                PyString_ConcatAndDel(&result, PyString_FromString("\n"));
+                PyString_ConcatAndDel(&result, s);
+            }
+        }
+
+        return result;
+    }
+
+    PyErr_SetString(PyExc_TypeError, "tostring() expects generator");
+    return NULL;
+}
+
+
+
+////////// compose Python Type //////////
+
+static PyObject* _selftest(PyObject* self, PyObject* null);
+
+
+static PyMethodDef compose_functionslist[] = {
+    {"local", local, METH_O, "Finds a local variable on the call stack including compose'd generators."},
+    {"tostring", tostring, METH_O, "Returns a string representation of a genarator."},
+    {"_selftest", _selftest, METH_NOARGS, "runs self test"},
+    {NULL} /* Sentinel */
+};
+
+
+static PyMethodDef compose_methods[] = {
+    {"send", (PyCFunction) compose_send,  METH_O,       "Send arg into composed generator." },
+    {"throw", (PyCFunction) compose_throw, METH_VARARGS, "Raise GeneratorExit in composed generator."},
+    {"close", (PyCFunction) compose_close, METH_NOARGS,  "Throws exception in composed generator."},
+    {NULL}	/* Sentinel */
+};
+
+
+PyTypeObject PyCompose_Type = {
+    PyObject_HEAD_INIT(&PyType_Type)
+    0,                                      /* ob_size */
+    "compose",                              /* tp_name */
+    sizeof(PyComposeObject),                /* tp_basicsize */
+    0,                                      /* tp_itemsize */
+    /* methods */
+    (destructor)compose_dealloc,            /* tp_dealloc */
+    0,                                      /* tp_print */
+    0,                                      /* tp_getattr */
+    0,                                      /* tp_setattr */
+    0,                                      /* tp_compare */
+    0,                                      /* tp_repr */
+    0,                                      /* tp_as_number */
+    0,                                      /* tp_as_sequence */
+    0,                                      /* tp_as_mapping */
+    0,                                      /* tp_hash */
+    0,                                      /* tp_call */
+    0,                                      /* tp_str */
+    PyObject_GenericGetAttr,                /* tp_getattro */
+    0,                                      /* tp_setattro */
+    0,                                      /* tp_as_buffer */
+    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_HAVE_GC,/* tp_flags */
+    0,                                      /* tp_doc */
+    (traverseproc)compose_traverse,         /* tp_traverse */
+    (inquiry)compose_clear,                 /* tp_clear */
+    0,                                      /* tp_richcompare */
+    offsetof(PyComposeObject, weakreflist), /* tp_weaklistoffset */
+    PyObject_SelfIter,                      /* tp_iter */
+    (iternextfunc)compose_iternext,         /* tp_iternext */
+    compose_methods,                        /* tp_methods */
+    0,                                      /* tp_members */
+    0,                                      /* tp_getset */
+    0,                                      /* tp_base */
+    0,                                      /* tp_dict */
+    0,                                      /* tp_descr_get */
+    0,                                      /* tp_descr_set */
+    0,                                      /* tp_dictoffset */
+    0,                                      /* tp_init */
+    0,                                      /* tp_alloc */
+    (newfunc)compose_new,                   /* tp_new */
+    0,                                      /* tp_free */
+    0,                                      /* tp_is_gc */
+    0,                                      /* tp_bases */
+    0,                                      /* tp_mro */
+    0,                                      /* tp_cache */
+    0,                                      /* tp_subclasses */
+    0,                                      /* tp_weaklist */
+    compose_del,                            /* tp_del */
+};
+
+
+
+////////// Module initialization //////////
+
+PyMODINIT_FUNC init_compose_c(void) {
+    PyObject* linecache = PyImport_ImportModule("linecache"); // new ref
+
+    if(!linecache) {
+        PyErr_Print();
+        return;
+    }
+
+    PyObject* dict = PyModule_GetDict(linecache); // borrowed ref
+
+    if(!dict) {
+        Py_DECREF(linecache);
+        PyErr_Print();
+        return;
+    }
+
+    py_getline = PyMapping_GetItemString(dict, "getline"); // new ref
+
+    if(!py_getline) {
+        Py_DECREF(linecache);
+        PyErr_Print();
+        return;
+    }
+
+    if(PyType_Ready(&PyCompose_Type) < 0) {
+        Py_DECREF(linecache);
+        Py_DECREF(py_getline);
+        PyErr_Print();
+        return;
+    }
+
+    PyObject* module = Py_InitModule3("_compose_c", compose_functionslist, "fast compose");
+
+    if(!module) {
+        Py_DECREF(linecache);
+        Py_DECREF(py_getline);
+        PyErr_Print();
+        return;
+    }
+
+    Py_INCREF(&PyCompose_Type);
+    PyModule_AddObject(module, "compose", (PyObject*) &PyCompose_Type);
+}
+
+
+
+////////// Testing support //////////
+
+void assertTrue(const int condition, const char* msg) {
+    if(!condition) {
+        printf("FAIL: ");
+        printf(msg);
+        printf("\n");
+    }
+}
+
+
+static PyObject* _selftest(PyObject* self, PyObject* null) {
+    printf("\nRunning self test in " __FILE__ "\n");
+    PyComposeObject c;
+    _compose_initialize(&c);
+    // test initial state of generator stack
+    assertTrue(c.generators_base != NULL, "generator stack not allocated");
+    assertTrue(c.generators_top == c.generators_base, "generator top of stack invalid");
+    assertTrue(c.generators_allocated == INITIAL_STACK_SIZE, "invalid allocated stack size");
+    // test pushing to generator stack
+    Py_ssize_t refcount = Py_None->ob_refcnt;
+    assertTrue(generators_push(&c, Py_None) == 1, "generators_push must return 1");
+    assertTrue(Py_None->ob_refcnt == refcount + 1, "refcount not increased");
+    assertTrue(c.generators_top == c.generators_base + 1, "stack top not increased");
+    assertTrue(c.generators_base[0] == Py_None, "top of stack must be Py_None");
+    int i;
+
+    for(i = 0; i < INITIAL_STACK_SIZE * 3; i++)
+        generators_push(&c, Py_None);
+
+    assertTrue(c.generators_top - c.generators_base == 3 * INITIAL_STACK_SIZE + 1, "extending stack failed");
+    assertTrue(c.generators_allocated == 2 * 2 * INITIAL_STACK_SIZE, "stack allocation failed");
+    // test messages queue initial state
+    assertTrue(messages_empty(&c), "messages not empty");
+    assertTrue(0 == _messages_size(&c), "initial queue size must be 0");
+    // test append to messages queue
+    refcount = Py_None->ob_refcnt;
+    messages_append(&c, Py_None);
+    assertTrue(1 == _messages_size(&c), "now queue size must be 1");
+    assertTrue(Py_None->ob_refcnt == refcount + 1, "messages_append did not increase ref count");
+    assertTrue(!messages_empty(&c), "messages must not be empty");
+    assertTrue(Py_None == messages_next(&c), "incorrect value from queue");
+    // test next on messages queue
+    assertTrue(0 == _messages_size(&c), "now queue size must be 0 again");
+    assertTrue(messages_empty(&c), "messages must be empty again");
+    messages_append(&c, PyInt_FromLong(5));
+    messages_append(&c, PyInt_FromLong(6));
+    assertTrue(2 == _messages_size(&c), "now queue size must be 2");
+    assertTrue(PyInt_AsLong(messages_next(&c)) == 5, "incorrect value from queue");
+    assertTrue(PyInt_AsLong(messages_next(&c)) == 6, "incorrect value from queue");
+    // test wrap around on append
+    compose_clear(&c);
+    _compose_initialize(&c);
+
+    for(i = 0; i < QUEUE_SIZE - 2; i++)                                     // 8
+        messages_append(&c, PyInt_FromLong(i));
+
+    assertTrue(i == _messages_size(&c), "queue must be equals to i");
+    int status = messages_append(&c, PyInt_FromLong(i));                    // 9
+    assertTrue(i + 1 == _messages_size(&c), "queue must be equals to i+1");
+    assertTrue(status == 1, "status must be ok");
+    status = messages_append(&c, PyInt_FromLong(i));                        // full!
+    assertTrue(status == 0, "status of append must 0 (no room)");
+    assertTrue(PyExc_RuntimeError == PyErr_Occurred(), "runtime exception must be set");
+    PyErr_Clear();
+    status = messages_insert(&c, PyInt_FromLong(99));
+    assertTrue(status == 0, "status of insert must 0 (no room)");
+    assertTrue(PyExc_RuntimeError == PyErr_Occurred(), "runtime exception must be set");
+    PyErr_Clear();
+    // test wrap around on insert
+    compose_clear(&c);
+    _compose_initialize(&c);
+    status = messages_insert(&c, PyInt_FromLong(42));
+    assertTrue(1 == _messages_size(&c), "after insert queue must be equals to 1");
+    assertTrue(status == 1, "status after first insert must be ok");
+    status = messages_insert(&c, PyInt_FromLong(42));
+    assertTrue(2 == _messages_size(&c), "after insert queue must be equals to 2");
+    assertTrue(status == 1, "status after second insert must be ok");
+
+    for(i = 0; i < QUEUE_SIZE - 3; i++)
+        status = messages_insert(&c, PyInt_FromLong(i));
+
+    assertTrue(9 == _messages_size(&c), "after insert queue must be equals to 9");
+    assertTrue(status == 1, "status after 9 inserts must be ok");
+    status = messages_insert(&c, PyInt_FromLong(4242));
+    assertTrue(status == 0, "status after 10 inserts must be error");
+    assertTrue(PyExc_RuntimeError == PyErr_Occurred(), "runtime exception must be set here too");
+    PyErr_Clear();
+    // test wrap around on next
+    compose_clear(&c);
+    _compose_initialize(&c);
+    messages_insert(&c, PyInt_FromLong(1000)); // wrap backward
+    messages_append(&c, PyInt_FromLong(1001)); // wrap forward
+    PyObject* o = messages_next(&c);           // end
+    assertTrue(1000 == PyInt_AsLong(o), "expected 1000");
+    assertTrue(2 == o->ob_refcnt, "refcount on next must be 2");
+    o = messages_next(&c);                     // wrap
+    assertTrue(1001 == PyInt_AsLong(o), "expected 1001");
+    assertTrue(2 == o->ob_refcnt, "refcount on next must be 2");
+    o = messages_next(&c);
+    assertTrue(NULL == o, "error condition on next: empty");
+    assertTrue(PyExc_RuntimeError == PyErr_Occurred(), "no runtime exception no next on empty queue");
+    PyErr_Clear();
+    printf("Done with self test\n");
+    compose_clear(&c);
+    Py_RETURN_NONE;
+}
+
diff --unidirectional-new-file '--exclude=*.so' '--exclude=*.o' '--exclude=.svn' '--exclude=*.pyc' '--exclude=deps.d' '--exclude=applied' --recursive --unified version_0/weightless/core/compose/_compose_py.py version_1/weightless/core/compose/_compose_py.py
--- version_0/weightless/core/compose/_compose_py.py	1970-01-01 01:00:00.000000000 +0100
+++ version_1/weightless/core/compose/_compose_py.py	2011-02-15 08:48:32.000000000 +0100
@@ -0,0 +1,129 @@
+## begin license ##
+#
+#    Weightless is a High Performance Asynchronous Networking Library
+#    See http://weightless.io
+#    Copyright (C) 2006-2011 Seek You Too (CQ2) http://www.cq2.nl
+#
+#    This file is part of Weightless
+#
+#    Weightless is free software; you can redistribute it and/or modify
+#    it under the terms of the GNU General Public License as published by
+#    the Free Software Foundation; either version 2 of the License, or
+#    (at your option) any later version.
+#
+#    Weightless is distributed in the hope that it will be useful,
+#    but WITHOUT ANY WARRANTY; without even the implied warranty of
+#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+#    GNU General Public License for more details.
+#
+#    You should have received a copy of the GNU General Public License
+#    along with Weightless; if not, write to the Free Software
+#    Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+#
+## end license ##
+from types import GeneratorType
+from sys import exc_info
+
+"""
+Wrt exceptions, see http://www.python.org/doc/2.5.4/lib/module-exceptions.html for Python 2.5:
+
+BaseException
+ +-- SystemExit                 sys.exit(), must exit, not an error, triggers finally's
+ +-- KeyboardInterrupt          ctrl-c, must exit, not an error, triggers finally's
+ +-- Exception                  built-in, non-system-exiting + user-defined exceptions
+      +-- GeneratorExit         when close() called, not an error ==> will move
+      +-- StopIteration         next() when no more values, not an error
+      +-- StandardError
+      |    +-- AssertionError   when assert statement fails ==> will move
+      |    +-- ...
+      +-- Warning
+           +-- RuntimeWarning
+           +-- ...
+
+and http://docs.python.org/3.0/library/exceptions.html for Python 3.0:
+
+BaseException
+ +-- SystemExit             sys.exit(), must exit, not an error, triggers finally's
+ +-- KeyboardInterrupt      ctrl-c, must exit
+ +-- GeneratorExit          when close() called, not an error <== moved
+ +-- Exception
+      +-- StopIteration
+      +-- AssertionError    when assert statement fails <== moved
+      +-- Warning
+           +-- RuntimeWarning
+           +-- ...
+
+"""
+
+def compose(initial, sidekick = None):
+    if type(initial) != GeneratorType:
+        raise TypeError("compose() expects generator")
+    return _compose(initial, sidekick)
+
+def _compose(initial, sidekick):
+    """
+    The method compose() allows program (de)composition with generators.  It enables calls like:
+        retvat = yield otherGenerator(args)
+    The otherGenerator may return values by:
+        raise StopIteration(retvat, remaining data)
+    Remaining data might be present if the otherGenerator consumes less than it get gets.  It must
+    make this remaining data available to the calling generator by yielding it as shown.
+    Most notably, compose enables catching exceptions:
+        try:
+            retvat = yield otherGenerator(args)
+        except Exception:
+            pass
+    This will work as expected: it catches an exception thrown by otherGenerator.
+    """
+    generators = [initial]
+    __callstack__ = generators # make these visible to 'local()'
+    messages = [None]
+    exception = None
+    while generators:
+        generator = generators[-1]
+        try:
+            if exception:
+                if exception[0] == GeneratorExit:
+                    generator.close()
+                    raise exception
+                response = generator.throw(*exception)
+                exception = None
+            else:
+                message = messages.pop(0)
+                response = generator.send(message)
+            if sidekick and callable(response):
+                messages.insert(0, message)
+                try:
+                    response(sidekick)
+                except BaseException:
+                    exType, exValue, exTraceback = exc_info()
+                    exception = (exType, exValue, exTraceback.tb_next)
+                    continue
+            elif type(response) == GeneratorType:
+                generators.append(response)
+                frame = response.gi_frame
+                assert frame, 'Generator is exhausted.'
+                assert frame.f_lineno == frame.f_code.co_firstlineno, 'Generator already used.'
+                messages.insert(0, None)
+            elif response or not messages:
+                try:
+                    message = yield response
+                    assert not (message and response), 'Cannot accept data. First send None.'
+                    messages.append(message)
+                    if response and messages[0] is not None:
+                        messages.insert(0, None)
+                except BaseException:
+                    exception = exc_info()
+        except StopIteration, returnValue:
+            exception = None
+            generators.pop()
+            if returnValue.args:
+                messages = list(returnValue.args) + messages
+            else:
+                messages.insert(0, None)
+        except BaseException:
+            generators.pop()
+            exType, exValue, exTraceback = exc_info()
+            exception = (exType, exValue, exTraceback.tb_next)
+    if exception:
+        raise exception[0], exception[1], exception[2]
diff --unidirectional-new-file '--exclude=*.so' '--exclude=*.o' '--exclude=.svn' '--exclude=*.pyc' '--exclude=deps.d' '--exclude=applied' --recursive --unified version_0/weightless/core/compose/__init__.py version_1/weightless/core/compose/__init__.py
--- version_0/weightless/core/compose/__init__.py	1970-01-01 01:00:00.000000000 +0100
+++ version_1/weightless/core/compose/__init__.py	2011-02-15 08:48:32.000000000 +0100
@@ -0,0 +1,43 @@
+## begin license ##
+#
+#    Weightless is a High Performance Asynchronous Networking Library
+#    See http://weightless.io
+#    Copyright (C) 2006-2011 Seek You Too (CQ2) http://www.cq2.nl
+#
+#    This file is part of Weightless
+#
+#    Weightless is free software; you can redistribute it and/or modify
+#    it under the terms of the GNU General Public License as published by
+#    the Free Software Foundation; either version 2 of the License, or
+#    (at your option) any later version.
+#
+#    Weightless is distributed in the hope that it will be useful,
+#    but WITHOUT ANY WARRANTY; without even the implied warranty of
+#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+#    GNU General Public License for more details.
+#
+#    You should have received a copy of the GNU General Public License
+#    along with Weightless; if not, write to the Free Software
+#    Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+#
+## end license ##
+
+from os.path import dirname, abspath, isdir, join            #DO_NOT_DISTRIBUTE
+if isdir(join(abspath(dirname(__file__)), '.svn')):          #DO_NOT_DISTRIBUTE
+    from os import system                                    #DO_NOT_DISTRIBUTE
+    status = system("cd %s/../../..; ./setup.py build_ext --inplace"  % abspath(dirname(__file__)))  #DO_NOT_DISTRIBUTE
+    if status > 0:                                           #DO_NOT_DISTRIBUTE
+        import sys                                           #DO_NOT_DISTRIBUTE
+        sys.exit(status)                                     #DO_NOT_DISTRIBUTE
+
+try:
+    from os import getenv                                        #DO_NOT_DISTRIBUTE
+    if getenv('WEIGHTLESS_COMPOSE_TEST') == 'PYTHON':            #DO_NOT_DISTRIBUTE
+        raise ImportError('Python compose for testing purposes') #DO_NOT_DISTRIBUTE
+    from _compose_c import compose, local, tostring
+except ImportError:
+    from warnings import warn
+    warn("You're now using the suboptimal python version of compose(), local(), tostring()")
+    from _compose_py import compose
+    from _local_py import local
+    from _tostring_py import tostring
diff --unidirectional-new-file '--exclude=*.so' '--exclude=*.o' '--exclude=.svn' '--exclude=*.pyc' '--exclude=deps.d' '--exclude=applied' --recursive --unified version_0/weightless/core/compose/_local_py.py version_1/weightless/core/compose/_local_py.py
--- version_0/weightless/core/compose/_local_py.py	1970-01-01 01:00:00.000000000 +0100
+++ version_1/weightless/core/compose/_local_py.py	2011-02-15 08:48:32.000000000 +0100
@@ -0,0 +1,49 @@
+## begin license ##
+#
+#    Weightless is a High Performance Asynchronous Networking Library
+#    See http://weightless.io
+#    Copyright (C) 2006-2011 Seek You Too (CQ2) http://www.cq2.nl
+#
+#    This file is part of Weightless
+#
+#    Weightless is free software; you can redistribute it and/or modify
+#    it under the terms of the GNU General Public License as published by
+#    the Free Software Foundation; either version 2 of the License, or
+#    (at your option) any later version.
+#
+#    Weightless is distributed in the hope that it will be useful,
+#    but WITHOUT ANY WARRANTY; without even the implied warranty of
+#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+#    GNU General Public License for more details.
+#
+#    You should have received a copy of the GNU General Public License
+#    along with Weightless; if not, write to the Free Software
+#    Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+#
+## end license ##
+from inspect import currentframe
+
+def findInLocals(f_locals, localName):
+    if localName in f_locals:
+        return f_locals[localName]
+    if '__callstack__' in f_locals:
+        for generator in reversed(f_locals['__callstack__']):
+            try:
+                return findInLocals(generator.gi_frame.f_locals, localName)
+            except AttributeError:
+                pass
+    raise AttributeError(localName)
+
+def findLocalInFrame(frame, localName):
+    if not frame:
+        raise AttributeError(localName)
+    try:
+        return findInLocals(frame.f_locals, localName)
+    except AttributeError:
+        pass
+    return findLocalInFrame(frame.f_back, localName)
+
+def local(localName):
+    frame = currentframe().f_back
+    return findLocalInFrame(frame, localName)
+
diff --unidirectional-new-file '--exclude=*.so' '--exclude=*.o' '--exclude=.svn' '--exclude=*.pyc' '--exclude=deps.d' '--exclude=applied' --recursive --unified version_0/weightless/core/compose/_tostring_py.py version_1/weightless/core/compose/_tostring_py.py
--- version_0/weightless/core/compose/_tostring_py.py	1970-01-01 01:00:00.000000000 +0100
+++ version_1/weightless/core/compose/_tostring_py.py	2011-02-15 08:48:32.000000000 +0100
@@ -0,0 +1,43 @@
+## begin license ##
+#
+#    Weightless is a High Performance Asynchronous Networking Library
+#    See http://weightless.io
+#    Copyright (C) 2006-2011 Seek You Too (CQ2) http://www.cq2.nl
+#
+#    This file is part of Weightless
+#
+#    Weightless is free software; you can redistribute it and/or modify
+#    it under the terms of the GNU General Public License as published by
+#    the Free Software Foundation; either version 2 of the License, or
+#    (at your option) any later version.
+#
+#    Weightless is distributed in the hope that it will be useful,
+#    but WITHOUT ANY WARRANTY; without even the implied warranty of
+#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+#    GNU General Public License for more details.
+#
+#    You should have received a copy of the GNU General Public License
+#    along with Weightless; if not, write to the Free Software
+#    Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+#
+## end license ##
+
+from linecache import getline
+from types import GeneratorType
+
+def tostring(generator):
+    if type(generator) != GeneratorType:
+        raise TypeError("tostring() expects generator")
+    frame = generator.gi_frame
+    glocals = frame.f_locals
+    lineno = frame.f_lineno
+    code = frame.f_code
+    name = code.co_name
+    if name == "_compose":
+        if 'generators' in glocals:
+            return '\n'.join(tostring(g) for g in glocals['generators'])
+        else:
+            return tostring(glocals['initial'])
+    filename = code.co_filename
+    codeline = getline(filename, lineno).strip()
+    return '  File "%(filename)s", line %(lineno)d, in %(name)s\n    %(codeline)s' % locals()
diff --unidirectional-new-file '--exclude=*.so' '--exclude=*.o' '--exclude=.svn' '--exclude=*.pyc' '--exclude=deps.d' '--exclude=applied' --recursive --unified version_0/weightless/core/__init__.py version_1/weightless/core/__init__.py
--- version_0/weightless/core/__init__.py	1970-01-01 01:00:00.000000000 +0100
+++ version_1/weightless/core/__init__.py	2011-02-15 08:48:32.000000000 +0100
@@ -0,0 +1,28 @@
+## begin license ##
+#
+#    Weightless is a High Performance Asynchronous Networking Library
+#    See http://weightless.io
+#    Copyright (C) 2011 Seek You Too (CQ2) http://www.cq2.nl
+#
+#    This file is part of Weightless
+#
+#    Weightless is free software; you can redistribute it and/or modify
+#    it under the terms of the GNU General Public License as published by
+#    the Free Software Foundation; either version 2 of the License, or
+#    (at your option) any later version.
+#
+#    Weightless is distributed in the hope that it will be useful,
+#    but WITHOUT ANY WARRANTY; without even the implied warranty of
+#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+#    GNU General Public License for more details.
+#
+#    You should have received a copy of the GNU General Public License
+#    along with Weightless; if not, write to the Free Software
+#    Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+#
+## end license ##
+
+VERSION='$Version: 0.4.x$'[9:-1].strip() # Modified by package scripts
+
+from compose import compose, local, tostring
+from utils import identify, autostart
diff --unidirectional-new-file '--exclude=*.so' '--exclude=*.o' '--exclude=.svn' '--exclude=*.pyc' '--exclude=deps.d' '--exclude=applied' --recursive --unified version_0/weightless/core/utils/__init__.py version_1/weightless/core/utils/__init__.py
--- version_0/weightless/core/utils/__init__.py	1970-01-01 01:00:00.000000000 +0100
+++ version_1/weightless/core/utils/__init__.py	2011-02-15 08:48:31.000000000 +0100
@@ -0,0 +1,25 @@
+## begin license ##
+#
+#    Weightless is a High Performance Asynchronous Networking Library
+#    See http://weightless.io
+#    Copyright (C) 2011 Seek You Too (CQ2) http://www.cq2.nl
+#
+#    This file is part of Weightless
+#
+#    Weightless is free software; you can redistribute it and/or modify
+#    it under the terms of the GNU General Public License as published by
+#    the Free Software Foundation; either version 2 of the License, or
+#    (at your option) any later version.
+#
+#    Weightless is distributed in the hope that it will be useful,
+#    but WITHOUT ANY WARRANTY; without even the implied warranty of
+#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+#    GNU General Public License for more details.
+#
+#    You should have received a copy of the GNU General Public License
+#    along with Weightless; if not, write to the Free Software
+#    Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+#
+## end license ##
+
+from _utils import identify, autostart
diff --unidirectional-new-file '--exclude=*.so' '--exclude=*.o' '--exclude=.svn' '--exclude=*.pyc' '--exclude=deps.d' '--exclude=applied' --recursive --unified version_0/weightless/core/utils/_utils.py version_1/weightless/core/utils/_utils.py
--- version_0/weightless/core/utils/_utils.py	1970-01-01 01:00:00.000000000 +0100
+++ version_1/weightless/core/utils/_utils.py	2011-02-15 08:48:31.000000000 +0100
@@ -0,0 +1,87 @@
+## begin license ##
+#
+#    Weightless is a High Performance Asynchronous Networking Library
+#    See http://weightless.io
+#    Copyright (C) 2006-2011 Seek You Too (CQ2) http://www.cq2.nl
+#
+#    This file is part of Weightless
+#
+#    Weightless is free software; you can redistribute it and/or modify
+#    it under the terms of the GNU General Public License as published by
+#    the Free Software Foundation; either version 2 of the License, or
+#    (at your option) any later version.
+#
+#    Weightless is distributed in the hope that it will be useful,
+#    but WITHOUT ANY WARRANTY; without even the implied warranty of
+#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+#    GNU General Public License for more details.
+#
+#    You should have received a copy of the GNU General Public License
+#    along with Weightless; if not, write to the Free Software
+#    Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+#
+## end license ##
+from re import compile
+
+def identify(generator):
+    def helper(*args, **kwargs):
+        g = generator(*args, **kwargs)
+        g.next()
+        g.send(g)
+        return g
+    return helper
+
+def autostart(generator):
+    def helper(*args, **kwargs):
+        g = generator(*args, **kwargs)
+        g.next()
+        return g
+    return helper
+
+def readRe(regexp, maximum=None):
+    if isinstance(regexp, basestring):
+        regexp = compile(regexp)
+    match = None
+    message = ''
+    while not match:
+        if maximum and len(message) > maximum:
+            raise OverflowError('no match after %s bytes' % len(message))
+        message += yield
+        match = regexp.match(message)
+    args = match.groupdict()
+    rest = message[match.end():]
+    if rest:
+        raise StopIteration(args, rest)
+    raise StopIteration(args)
+
+def readAll():
+    data = []
+    try:
+        while True:
+            data.append((yield))
+    except StopIteration:
+        raise StopIteration(''.join(data))
+
+def copyBytes(tosend, target):
+    response, message, tail = None, None, None
+    while tosend > 0:
+        message = yield response
+        head, tail = message[:tosend], message[tosend:]
+        response = target.send(head)
+        tosend -= len(head)
+    #try:
+    #    response = target.throw(StopIteration())
+    #except StopIteration:
+    #    pass
+    if response:
+        message = yield response
+        if message and tail:
+            raise StopIteration(None, tail, message)
+        if message and not tail:
+            raise StopIteration(None, message)
+        if tail and not message:
+            raise StopIteration(None, tail)
+        raise StopIteration()
+    if tail:
+        raise StopIteration(None, tail)
+
Only in version_0/weightless: _gutils.py
diff --unidirectional-new-file '--exclude=*.so' '--exclude=*.o' '--exclude=.svn' '--exclude=*.pyc' '--exclude=deps.d' '--exclude=applied' --recursive --unified version_0/weightless/http/_acceptor.py version_1/weightless/http/_acceptor.py
--- version_0/weightless/http/_acceptor.py	1970-01-01 01:00:00.000000000 +0100
+++ version_1/weightless/http/_acceptor.py	2011-02-15 08:48:31.000000000 +0100
@@ -0,0 +1,59 @@
+# -*- coding: utf-8 -*-
+## begin license ##
+#
+#    Weightless is a High Performance Asynchronous Networking Library
+#    See http://weightless.io
+#    Copyright (C) 2006-2011 Seek You Too (CQ2) http://www.cq2.nl
+#
+#    This file is part of Weightless
+#
+#    Weightless is free software; you can redistribute it and/or modify
+#    it under the terms of the GNU General Public License as published by
+#    the Free Software Foundation; either version 2 of the License, or
+#    (at your option) any later version.
+#
+#    Weightless is distributed in the hope that it will be useful,
+#    but WITHOUT ANY WARRANTY; without even the implied warranty of
+#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+#    GNU General Public License for more details.
+#
+#    You should have received a copy of the GNU General Public License
+#    along with Weightless; if not, write to the Free Software
+#    Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+#
+## end license ##
+from socket import socket, SOL_SOCKET, SO_REUSEADDR, SO_LINGER, SOL_TCP, TCP_CORK, TCP_NODELAY
+from struct import pack
+
+def createSocket(port):
+    sok = socket()
+    sok.setsockopt(SOL_SOCKET, SO_REUSEADDR, 1)
+    sok.setsockopt(SOL_SOCKET, SO_LINGER, pack('ii', 0, 0))
+    sok.bind(('0.0.0.0', port))
+    sok.listen(127)
+    return sok
+
+class Acceptor(object):
+    """Listens on a port for incoming internet (TCP/IP) connections and calls a factory to create a handler for the new connection.  It does not use threads but a asynchronous reactor instead."""
+
+    def __init__(self, reactor, port, sinkFactory, prio=None, sok=None):
+        """The reactor is a user specified reactor for dispatching I/O events asynchronously. The sinkFactory is called with the newly created socket as its single argument. It is supposed to return a callable callback function that is called by the reactor when data is available."""
+
+        if sok == None:
+            sok = createSocket(port)
+
+        reactor.addReader(sok, self._accept, prio=prio)
+        self._sinkFactory = sinkFactory
+        self._sok = sok
+        self._reactor = reactor
+        self._prio = prio
+
+    def _accept(self):
+        newConnection, address = self._sok.accept()
+        newConnection.setsockopt(SOL_TCP, TCP_CORK, 1)
+        #newConnection.setsockopt(SOL_TCP, TCP_NODELAY, 1)
+        self._reactor.addReader(newConnection,
+            self._sinkFactory(newConnection), prio=self._prio)
+
+    def close(self):
+        self._sok.close()
diff --unidirectional-new-file '--exclude=*.so' '--exclude=*.o' '--exclude=.svn' '--exclude=*.pyc' '--exclude=deps.d' '--exclude=applied' --recursive --unified version_0/weightless/http/_bufferedhandler.py version_1/weightless/http/_bufferedhandler.py
--- version_0/weightless/http/_bufferedhandler.py	1970-01-01 01:00:00.000000000 +0100
+++ version_1/weightless/http/_bufferedhandler.py	2011-02-15 08:48:31.000000000 +0100
@@ -0,0 +1,45 @@
+## begin license ##
+#
+#    Weightless is a High Performance Asynchronous Networking Library
+#    See http://weightless.io
+#    Copyright (C) 2006-2009 Seek You Too (CQ2) http://www.cq2.nl
+#
+#    This file is part of Weightless
+#
+#    Weightless is free software; you can redistribute it and/or modify
+#    it under the terms of the GNU General Public License as published by
+#    the Free Software Foundation; either version 2 of the License, or
+#    (at your option) any later version.
+#
+#    Weightless is distributed in the hope that it will be useful,
+#    but WITHOUT ANY WARRANTY; without even the implied warranty of
+#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+#    GNU General Public License for more details.
+#
+#    You should have received a copy of the GNU General Public License
+#    along with Weightless; if not, write to the Free Software
+#    Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+#
+## end license ##
+
+
+class BufferedHandler(object):
+
+    def __init__(self, nextInChain):
+        self.nextInChain = nextInChain
+        self.allData = []
+        self.sentHeaders = False
+
+    def next(self):
+        return self.nextInChain.next()
+
+    def send(self, data):
+        if not self.sentHeaders:
+            self.sentHeaders = True
+            self.nextInChain.send(data)
+        else:
+            self.allData.append(data)
+
+    def throw(self, ex):
+        self.nextInChain.send("".join(self.allData))
+        return self.nextInChain.throw(ex)
diff --unidirectional-new-file '--exclude=*.so' '--exclude=*.o' '--exclude=.svn' '--exclude=*.pyc' '--exclude=deps.d' '--exclude=applied' --recursive --unified version_0/weightless/http/_httpget.py version_1/weightless/http/_httpget.py
--- version_0/weightless/http/_httpget.py	1970-01-01 01:00:00.000000000 +0100
+++ version_1/weightless/http/_httpget.py	2011-02-15 08:48:31.000000000 +0100
@@ -0,0 +1,83 @@
+## begin license ##
+#
+#    Weightless is a High Performance Asynchronous Networking Library
+#    See http://weightless.io
+#    Copyright (C) 2010-2011 Seek You Too (CQ2) http://www.cq2.nl
+#
+#    This file is part of Weightless
+#
+#    Weightless is free software; you can redistribute it and/or modify
+#    it under the terms of the GNU General Public License as published by
+#    the Free Software Foundation; either version 2 of the License, or
+#    (at your option) any later version.
+#
+#    Weightless is distributed in the hope that it will be useful,
+#    but WITHOUT ANY WARRANTY; without even the implied warranty of
+#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+#    GNU General Public License for more details.
+#
+#    You should have received a copy of the GNU General Public License
+#    along with Weightless; if not, write to the Free Software
+#    Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+#
+## end license ##
+
+from sys import exc_info
+from weightless.http import Suspend
+from weightless.core import identify
+from socket import socket, error as SocketError, SOL_SOCKET, SO_ERROR, SHUT_WR, SHUT_RD
+from errno import EINPROGRESS
+
+@identify
+def doGet(host, port, request, vhost=""):
+    this = yield # this generator, from @identify
+    suspend = yield # suspend object, from Suspend.__call__
+    sok = socket()
+    sok.setblocking(0)
+    #sok.settimeout(1.0)
+    try:
+        sok.connect((host, port))
+    except SocketError, (errno, msg):
+        if errno != EINPROGRESS:
+            raise
+    suspend._reactor.addWriter(sok, this.next)
+    yield
+    try:
+        err = sok.getsockopt(SOL_SOCKET, SO_ERROR)
+        if err != 0:    # connection created succesfully?
+            raise IOError(err)
+        yield
+        suspend._reactor.removeWriter(sok)
+        # sendall() of loop gebruiken
+        # error checking
+        sok.send('%s\r\n' % _httpRequest(request, vhost=vhost))
+        sok.shutdown(SHUT_WR)
+        #sok.shutdown(WRITER)
+        suspend._reactor.addReader(sok, this.next)
+        responses = []
+        while True:
+            yield
+            response = sok.recv(4096) # error checking
+            if response == '':
+                break
+            responses.append(response)
+        suspend._reactor.removeReader(sok)
+        #sok.shutdown(READER)
+        sok.close()
+        suspend.resume(''.join(responses))
+    except Exception, e:
+        suspend.throw(*exc_info())
+    yield
+
+def _httpRequest(request, vhost=""):
+    httpRequest = "GET %s HTTP/1.0\r\n" % request
+    if vhost != "":
+        httpRequest = "GET %s HTTP/1.1\r\nHost: %s\r\n" % (request, vhost)
+    return httpRequest
+
+
+def httpget(host, port, request, vhost=""):
+    s = Suspend(doGet(host, port, request, vhost=vhost).send)
+    yield s
+    result = s.getResult()
+    raise StopIteration(result)
diff --unidirectional-new-file '--exclude=*.so' '--exclude=*.o' '--exclude=.svn' '--exclude=*.pyc' '--exclude=deps.d' '--exclude=applied' --recursive --unified version_0/weightless/http/_httpreader.py version_1/weightless/http/_httpreader.py
--- version_0/weightless/http/_httpreader.py	1970-01-01 01:00:00.000000000 +0100
+++ version_1/weightless/http/_httpreader.py	2011-02-15 08:48:31.000000000 +0100
@@ -0,0 +1,194 @@
+## begin license ##
+#
+#    Weightless is a High Performance Asynchronous Networking Library
+#    See http://weightless.io
+#    Copyright (C) 2006-2011 Seek You Too (CQ2) http://www.cq2.nl
+#
+#    This file is part of Weightless
+#
+#    Weightless is free software; you can redistribute it and/or modify
+#    it under the terms of the GNU General Public License as published by
+#    the Free Software Foundation; either version 2 of the License, or
+#    (at your option) any later version.
+#
+#    Weightless is distributed in the hope that it will be useful,
+#    but WITHOUT ANY WARRANTY; without even the implied warranty of
+#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+#    GNU General Public License for more details.
+#
+#    You should have received a copy of the GNU General Public License
+#    along with Weightless; if not, write to the Free Software
+#    Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+#
+## end license ##
+from socket import socket, SHUT_RDWR, SHUT_WR
+from urlparse import urlsplit
+from weightless.http import REGEXP, FORMAT, HTTP, parseHeaders
+from _bufferedhandler import BufferedHandler
+
+import sys
+
+RECVSIZE = 4096
+
+def soapPost(reactor, serverUrl, soapAction, body, responseCallback=lambda x:None, timeout=15):
+    handler = BufferedHandler(HandlerFacade(responseCallback, lambda x: None, [body, None].__iter__))
+    host, port, path = _httpParseUrl(serverUrl)
+    HttpReader(reactor, Connector(reactor, host, port), handler, "POST", host, path, headers={'SOAPAction': soapAction}, timeout=timeout)
+
+def Connector(reactor, host, port):
+    sok = socket()
+    sok.connect((host, port))
+    return sok
+
+class HandlerFacade(object):
+    def __init__(self, responseHandler, errorHandler, bodyHandler):
+        self._bodyHandler = bodyHandler and bodyHandler() or xrange(0)
+        self.throw = errorHandler
+        self.send = responseHandler
+    def next(self):
+        return self._bodyHandler.next()
+    def __iter__(self):
+        return self
+
+def _httpParseUrl(url):
+    scheme, host, path, query, fragment = urlsplit(url)
+    port = '80'
+    if ':' in host:
+        host, port = host.split(':')
+    path = path or '/'
+    if query:
+        path += '?' + query
+    if fragment:
+        path += '#' + fragment
+    return host, int(port), path
+
+def HttpReaderFacade(reactor, url, responseHandler, errorHandler=None, timeout=1, headers={}, bodyHandler=None, recvSize=RECVSIZE):
+    host, port, path = _httpParseUrl(url)
+    method = bodyHandler and 'POST' or 'GET'
+    return HttpReader(reactor, Connector(reactor, host, int(port)), HandlerFacade(responseHandler, errorHandler, bodyHandler), method, host, path, timeout=timeout,  headers=headers, recvSize=recvSize)
+
+class HttpReader(object):
+
+    def __init__(self, reactor, sokket, handler, method, host, path, headers={}, timeout=1, recvSize=RECVSIZE):
+        self._responseBuffer = ''
+        self._restData = None
+        self._handler = handler
+        self._sok = sokket
+        self._reactor = reactor
+        if method == 'POST':
+            requestSendMethod = lambda: self._sendPostRequest(path, host, headers)
+        else:
+            requestSendMethod = lambda: self._sendGetRequest(path, host)
+        self._reactor.addWriter(self._sok, requestSendMethod)
+        self._timeOuttime = timeout
+
+        self._timer = self._reactor.addTimer(self._timeOuttime, self._timeOut)
+        self._recvSize = recvSize
+        self._buffer = ''
+        self._peername = self._sok.getpeername()
+
+    def _sendPostRequest(self, path, host, headers):
+        headers['Transfer-Encoding'] = 'chunked'
+        self._sok.sendall(
+            FORMAT.RequestLine % {'Method': 'POST', 'Request_URI': path, 'HTTPVersion':'1.1'}
+            + FORMAT.HostHeader % {'Host': host}
+            + ''.join(FORMAT.Header % header for header in headers.items())
+            + FORMAT.UserAgentHeader
+            + HTTP.CRLF)
+        item = self._handler.next()
+        while item:
+            self._sendChunk(item)
+            item = self._handler.next()
+
+        self._sendChunk('')
+        self._reactor.removeWriter(self._sok)
+        self._reactor.addReader(self._sok, self._headerFragment)
+
+    def _createChunk(self, data):
+        return hex(len(data))[len('0x'):].upper() + HTTP.CRLF + data + HTTP.CRLF
+
+    def _sendChunk(self, data):
+        self._sok.sendall(self._createChunk(data))
+
+    def _sendGetRequest(self, path, host):
+        self._sok.sendall(
+            FORMAT.RequestLine % {'Method': 'GET', 'Request_URI': path, 'HTTPVersion':'1.1'}
+            + FORMAT.HostHeader % {'Host': host}
+            + FORMAT.UserAgentHeader
+            + HTTP.CRLF)
+        self._reactor.removeWriter(self._sok)
+        self._reactor.addReader(self._sok, self._headerFragment)
+
+    def _headerFragment(self):
+        self._responseBuffer += self._sok.recv(self._recvSize)
+        match = REGEXP.RESPONSE.match(self._responseBuffer)
+        if not match:
+            if not self._timer:
+                self._startTimer()
+            return #for more data
+        self._stopTimer()
+        if match.end() < len(self._responseBuffer):
+            restData = self._responseBuffer[match.end():]
+        else:
+            restData = ''
+        response = match.groupdict()
+        response['Headers'] = parseHeaders(response['_headers'])
+        self._chunked = 'Transfer-Encoding' in response['Headers'] and response['Headers']['Transfer-Encoding'] == 'chunked'
+        del response['_headers']
+        response['Client'] = self._peername
+        self._handler.send(response)
+        if restData:
+            self._sendFragment(restData)
+        self._reactor.removeReader(self._sok)
+        self._reactor.addReader(self._sok, self._bodyFragment)
+        self._startTimer()
+
+    def _bodyFragment(self):
+        self._stopTimer()
+        fragment = self._sok.recv(self._recvSize)
+
+        if not fragment:
+            self._stop()
+        else:
+            self._sendFragment(fragment)
+            self._startTimer()
+
+    def _stop(self):
+        self._reactor.removeReader(self._sok)
+        self._sok.close()
+        self._handler.throw(StopIteration())
+
+    def _sendFragment(self, fragment):
+        if self._chunked:
+            self._buffer += fragment
+
+            match = REGEXP.CHUNK_SIZE_LINE.match(self._buffer)
+            if match:
+                chunkSize = int("0x" + self._buffer[:match.end()], 16)
+                if chunkSize == 0:
+                    self._stop()
+                    return
+
+                if len(self._buffer) >= chunkSize + match.end():
+                    self._buffer = self._buffer[match.end():]
+                    data = self._buffer[:chunkSize]
+                    self._buffer = self._buffer[chunkSize + len(HTTP.CRLF):]
+                    self._handler.send(data)
+        else:
+            self._handler.send(fragment)
+
+    def _startTimer(self):
+        self._timer = self._reactor.addTimer(self._timeOuttime, self._timeOut)
+
+    def _stopTimer(self):
+        if self._timer:
+            self._reactor.removeTimer(self._timer)
+            self._timer = None
+
+    def _timeOut(self):
+        try:
+            self._handler.throw(Exception('timeout while receiving data'))
+        finally:
+            self._reactor.removeReader(self._sok)
+            self._sok.shutdown(SHUT_RDWR)
+            self._sok.close()
diff --unidirectional-new-file '--exclude=*.so' '--exclude=*.o' '--exclude=.svn' '--exclude=*.pyc' '--exclude=deps.d' '--exclude=applied' --recursive --unified version_0/weightless/http/_httpserver.py version_1/weightless/http/_httpserver.py
--- version_0/weightless/http/_httpserver.py	1970-01-01 01:00:00.000000000 +0100
+++ version_1/weightless/http/_httpserver.py	2011-02-15 08:48:31.000000000 +0100
@@ -0,0 +1,327 @@
+# -*- coding: utf-8 -*-
+## begin license ##
+#
+#    Weightless is a High Performance Asynchronous Networking Library
+#    See http://weightless.io
+#    Copyright (C) 2006-2011 Seek You Too (CQ2) http://www.cq2.nl
+#
+#    This file is part of Weightless
+#
+#    Weightless is free software; you can redistribute it and/or modify
+#    it under the terms of the GNU General Public License as published by
+#    the Free Software Foundation; either version 2 of the License, or
+#    (at your option) any later version.
+#
+#    Weightless is distributed in the hope that it will be useful,
+#    but WITHOUT ANY WARRANTY; without even the implied warranty of
+#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+#    GNU General Public License for more details.
+#
+#    You should have received a copy of the GNU General Public License
+#    along with Weightless; if not, write to the Free Software
+#    Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+#
+## end license ##
+from _acceptor import Acceptor
+from weightless.core import identify
+from weightless.http import REGEXP, FORMAT, parseHeaders, parseHeader
+from socket import SHUT_RDWR, error as SocketError, MSG_DONTWAIT
+from tempfile import TemporaryFile
+from email import message_from_file as parse_mime_message
+
+from OpenSSL import SSL
+from random import randint
+from time import time
+from socket import socket, ssl,  SOL_SOCKET, SO_REUSEADDR, SO_LINGER
+from struct import pack
+from sys import stdout
+
+
+RECVSIZE = 4096
+CRLF_LEN = 2
+
+class HttpServer:
+    """Factory that creates a HTTP server listening on port, calling generatorFactory for each new connection.  When a client does not send a valid HTTP request, it is disconnected after timeout seconds. The generatorFactory is called with the HTTP Status and Headers as arguments.  It is expected to return a generator that produces the response -- including the Status line and Headers -- to be send to the client."""
+    def __init__(self, reactor, port, generatorFactory, timeout=1, recvSize=RECVSIZE, prio=None, sok=None, maxConnections=None, errorHandler=None):
+        self._reactor = reactor
+        self._port = port
+        self._generatorFactory = generatorFactory
+        self._timeout = timeout
+        self._recvSize = recvSize
+        self._prio = prio
+        self._sok = sok
+        self._maxConnections = maxConnections
+        self._errorHandler = errorHandler
+
+    def listen(self):
+        self._acceptor = Acceptor(self._reactor, self._port, 
+                lambda sok: HttpHandler(self._reactor, sok, self._generatorFactory, self._timeout, 
+                    self._recvSize, prio=self._prio, maxConnections=self._maxConnections, 
+                    errorHandler=self._errorHandler),
+                prio=self._prio, sok=self._sok)
+
+
+    def setMaxConnections(self, m):
+        self._maxConnections = m
+
+def HttpsServer(reactor, port, generatorFactory, timeout=1, recvSize=RECVSIZE, prio=None, sok=None, maxConnections=None, errorHandler=None, certfile='', keyfile=''):
+    """Factory that creates a HTTP server listening on port, calling generatorFactory for each new connection.  When a client does not send a valid HTTP request, it is disconnected after timeout seconds. The generatorFactory is called with the HTTP Status and Headers as arguments.  It is expected to return a generator that produces the response -- including the Status line and Headers -- to be send to the client."""
+    if sok == None:
+        def verify_cb(conn, cert, errnum, depth, ok):
+            # This obviously has to be updated
+            print 'Got certificate: %s' % cert.get_subject()
+            return ok
+
+        # Initialize context
+        ctx = SSL.Context(SSL.SSLv23_METHOD)
+        ctx.set_session_id('weightless:%s:%s' % (time(), randint(1024,4096)))
+        ctx.set_options(SSL.OP_NO_SSLv2)
+        ctx.set_verify(SSL.VERIFY_PEER, verify_cb) # Demand a certificate
+        ctx.use_privatekey_file (keyfile)
+        ctx.use_certificate_file(certfile)
+
+        # Set up server
+        sok = SSL.Connection(ctx, socket())
+        sok.setsockopt(SOL_SOCKET, SO_REUSEADDR, 1)
+        sok.setsockopt(SOL_SOCKET, SO_LINGER, pack('ii', 0, 0))
+        sok.bind(('0.0.0.0', port))
+        sok.listen(127)
+
+    return Acceptor(reactor, port, lambda s: HttpsHandler(reactor, s, generatorFactory, timeout, recvSize, prio=prio, maxConnections=maxConnections, errorHandler=errorHandler), prio=prio, sok=sok)
+
+from sys import stdout
+from resource import getrlimit, RLIMIT_NOFILE
+
+def maxFileDescriptors():
+    softLimit, hardLimit = getrlimit(RLIMIT_NOFILE)
+    return softLimit
+
+def defaultErrorHandler(**kwargs):
+    yield 'HTTP/1.0 503 Service Unavailable\r\n\r\n<html><head></head><body><h1>Service Unavailable</h1></body></html>'
+
+class HttpHandler(object):
+    def __init__(self, reactor, sok, generatorFactory, timeout, recvSize=RECVSIZE, prio=None, maxConnections=None, errorHandler=None):
+        self._reactor = reactor
+        self._sok = sok
+        self._generatorFactory = generatorFactory
+        self._dataBuffer = ''
+        self._rest = None
+        self._timeout = timeout
+        self._timer = None
+        self._recvSize = recvSize
+        self.request = None
+        self._dealWithCall = self._readHeaders
+        self._prio = prio
+        self._window = ''
+        self._maxConnections = maxConnections if maxConnections else maxFileDescriptors()
+        self._errorHandler = errorHandler if errorHandler else defaultErrorHandler
+
+    def __call__(self):
+        part = self._sok.recv(self._recvSize)
+        self._dataBuffer += part
+        self._dealWithCall()
+
+    def setCallDealer(self, aMethod):
+        self._dealWithCall = aMethod
+        self._dealWithCall()
+
+    def _readHeaders(self):
+        match = REGEXP.REQUEST.match(self._dataBuffer)
+        if not match:
+            if not self._timer:
+                self._timer = self._reactor.addTimer(self._timeout, self._badRequest)
+            return # for more data
+        if self._timer:
+            self._reactor.removeTimer(self._timer)
+            self._timer = None
+        self.request = match.groupdict()
+        self.request['Body'] = ''
+        self.request['Headers'] = parseHeaders(self.request['_headers'])
+        matchEnd = match.end()
+        self._dataBuffer = self._dataBuffer[matchEnd:]
+        if 'Content-Type' in self.request['Headers']:
+            cType, pDict = parseHeader(self.request['Headers']['Content-Type'])
+            if cType.startswith('multipart/form-data'):
+                self._tempfile = TemporaryFile('w+b')
+                #self._tempfile = open('/tmp/mimetest', 'w+b')
+                self._tempfile.write('Content-Type: %s\r\n\r\n' % self.request['Headers']['Content-Type'])
+                self.setCallDealer(lambda: self._readMultiForm(pDict['boundary']))
+                return
+        if 'Expect' in self.request['Headers']:
+            self._sok.send('HTTP/1.1 100 Continue\r\n\r\n')
+        if self._reactor.getOpenConnections() > self._maxConnections:
+            self.request['ResponseCode'] = 503
+            self._finalize(self._errorHandler)
+        else:
+            self.setCallDealer(self._readBody)
+
+    def _readMultiForm(self, boundary):
+        if self._timer:
+            self._reactor.removeTimer(self._timer)
+            self._timer = None
+        self._tempfile.write(self._dataBuffer)
+
+        self._window += self._dataBuffer
+        self._window = self._window[-2*self._recvSize:]
+
+        if self._window.endswith("\r\n--%s--\r\n" % boundary):
+            self._tempfile.seek(0)
+
+            form = {}
+            for msg in parse_mime_message(self._tempfile).get_payload():
+                cType, pDict = parseHeader(msg['Content-Disposition'])
+                contentType = msg.get_content_type()
+                fieldName = pDict['name'][1:-1]
+                if not fieldName in form:
+                    form[fieldName] = []
+
+                if 'filename' in pDict:
+                    filename = self._processFilename(pDict['filename'][1:-1])
+                    form[fieldName].append((filename, contentType, msg.get_payload()))
+                else:
+                    form[fieldName].append(msg.get_payload())
+
+            self.request['Form'] = form
+            self._tempfile.close()
+            self.finalize()
+            return
+
+        self._dataBuffer= ''
+        if not self._timer:
+            self._timer = self._reactor.addTimer(self._timeout, self._badRequest)
+
+    def _processFilename(self, filename):
+        parts = filename.split('\\')
+        if len(parts) == 1:
+            return filename
+        return parts[-1]
+
+    def _readBody(self):
+        if self.request['Method'] == 'GET':
+            self.finalize()
+        elif self.request['Method'] == 'POST':
+            if 'Content-Length' in self.request['Headers']:
+                contentLength = int(self.request['Headers']['Content-Length'])
+
+                if len(self._dataBuffer) < contentLength:
+                    if not self._timer:
+                        self._timer = self._reactor.addTimer(self._timeout, self._badRequest)
+                    return
+                if self._timer:
+                    self._reactor.removeTimer(self._timer)
+                    self._timer = None
+
+                self.request['Body'] = self._dataBuffer
+                self.finalize()
+            elif 'Transfer-Encoding' in self.request['Headers'] and self.request['Headers']['Transfer-Encoding'] == 'chunked':
+                self.setCallDealer(self._readChunk)
+            else:
+                self.finalize()
+        else:
+            self.finalize()
+
+    def _readChunk(self):
+        match = REGEXP.CHUNK_SIZE_LINE.match(self._dataBuffer)
+        if not match:
+            if not self._timer:
+                self._timer = self._reactor.addTimer(self._timeout, self._badRequest)
+            return # for more data
+        if self._timer:
+            self._reactor.removeTimer(self._timer)
+            self._timer = None
+        self._chunkSize = int(match.groupdict()['ChunkSize'], 16)
+        self._dataBuffer = self._dataBuffer[match.end():]
+        self.setCallDealer(self._readChunkBody)
+
+    def _readChunkBody(self):
+        if self._chunkSize == 0:
+            self.finalize()
+        else:
+            if len(self._dataBuffer) < self._chunkSize + CRLF_LEN:
+                if not self._timer:
+                    self._timer = self._reactor.addTimer(self._timeout, self._badRequest)
+                return # for more data
+            if self._timer:
+                self._reactor.removeTimer(self._timer)
+                self._timer = None
+            self.request['Body'] += self._dataBuffer[:self._chunkSize]
+            self._dataBuffer = self._dataBuffer[self._chunkSize + CRLF_LEN:]
+            self.setCallDealer(self._readChunk)
+
+    def _finalize(self, finalizeMethod):
+        del self.request['_headers']
+        self.request['Client'] = self._sok.getpeername()
+        self._handler = finalizeMethod(**self.request)
+        self._reactor.removeReader(self._sok)
+        self._reactor.addWriter(self._sok, self._writeResponse().next, prio=self._prio)
+
+    def finalize(self):
+        self._finalize(self._generatorFactory)
+
+    def _badRequest(self):
+        self._sok.send('HTTP/1.0 400 Bad Request\r\n\r\n')
+        self._reactor.removeReader(self._sok)
+        self._sok.shutdown(SHUT_RDWR)
+        self._sok.close()
+
+    @identify
+    def _writeResponse(self):
+        this = yield
+        while True:
+            yield
+            try:
+                if self._rest:
+                    data = self._rest
+                else:
+                    data = self._handler.next()
+                    if callable(data):
+                        data(self._reactor, this.next)
+                        yield
+                        data.resumeWriter()
+                        continue
+                sent = self._sok.send(data, MSG_DONTWAIT)
+                if sent < len(data):
+                    self._rest = data[sent:]
+                else:
+                    self._rest = None
+            except StopIteration:
+                self._closeConnection()
+                yield
+            except:
+                self._closeConnection()
+                raise
+
+    def _closeConnection(self):
+        self._reactor.cleanup(self._sok)
+
+        try:
+            self._sok.shutdown(SHUT_RDWR)
+        except SocketError, e:
+            code, message = e.args
+            if code == 107:
+                pass # KVS: not well understood, not tested. It seems some quick (local) servers close the connection before this point is reached. It may happen more generally. In any case, it is based on a truely existing phenomomon
+            else:
+                raise
+        self._sok.close()
+
+class HttpsHandler(HttpHandler):
+    def __call__(self):
+        try:
+            part = self._sok.recv(self._recvSize)
+        except (SSL.WantReadError, SSL.WantWriteError, SSL.WantX509LookupError):
+            pass
+        except Exception, e:
+            self._closeDuringRead()
+        else:
+            self._dataBuffer += part
+            self._dealWithCall()
+
+    def _closeDuringRead(self):
+        self._reactor.removeReader(self._sok)
+        self._sok.shutdown()
+        self._sok.close()
+
+    def _closeConnection(self):
+        self._reactor.removeWriter(self._sok)
+        self._sok.shutdown()
+        self._sok.close()
diff --unidirectional-new-file '--exclude=*.so' '--exclude=*.o' '--exclude=.svn' '--exclude=*.pyc' '--exclude=deps.d' '--exclude=applied' --recursive --unified version_0/weightless/http/httpspec.py version_1/weightless/http/httpspec.py
--- version_0/weightless/http/httpspec.py	2011-02-12 11:50:45.000000000 +0100
+++ version_1/weightless/http/httpspec.py	2011-02-15 08:48:31.000000000 +0100
@@ -1,7 +1,8 @@
 ## begin license ##
 #
 #    Weightless is a High Performance Asynchronous Networking Library
-#    Copyright (C) 2006-2009 Seek You Too (CQ2) http://www.cq2.nl
+#    See http://weightless.io
+#    Copyright (C) 2006-2011 Seek You Too (CQ2) http://www.cq2.nl
 #
 #    This file is part of Weightless
 #
@@ -21,7 +22,7 @@
 #
 ## end license ##
 from re import compile
-from weightless import VERSION
+from weightless.core import VERSION
 
 """
     HTTP specifications.
diff --unidirectional-new-file '--exclude=*.so' '--exclude=*.o' '--exclude=.svn' '--exclude=*.pyc' '--exclude=deps.d' '--exclude=applied' --recursive --unified version_0/weightless/http/__init__.py version_1/weightless/http/__init__.py
--- version_0/weightless/http/__init__.py	2011-02-12 11:50:45.000000000 +0100
+++ version_1/weightless/http/__init__.py	2011-02-15 08:48:31.000000000 +0100
@@ -1,7 +1,8 @@
 ## begin license ##
 #
 #    Weightless is a High Performance Asynchronous Networking Library
-#    Copyright (C) 2006-2009 Seek You Too (CQ2) http://www.cq2.nl
+#    See http://weightless.io
+#    Copyright (C) 2006-2011 Seek You Too (CQ2) http://www.cq2.nl
 #
 #    This file is part of Weightless
 #
@@ -21,3 +22,9 @@
 #
 ## end license ##
 from httpspec import parseHeaders, parseHeader, HTTP, REGEXP, FORMAT
+
+from _suspend import Suspend
+from _httpreader import HttpReader
+from _httpserver import HttpServer, HttpsServer
+from _acceptor import Acceptor
+from _httpget import httpget
diff --unidirectional-new-file '--exclude=*.so' '--exclude=*.o' '--exclude=.svn' '--exclude=*.pyc' '--exclude=deps.d' '--exclude=applied' --recursive --unified version_0/weightless/http/_suspend.py version_1/weightless/http/_suspend.py
--- version_0/weightless/http/_suspend.py	1970-01-01 01:00:00.000000000 +0100
+++ version_1/weightless/http/_suspend.py	2011-02-15 08:48:31.000000000 +0100
@@ -0,0 +1,63 @@
+## begin license ##
+#
+#    Weightless is a High Performance Asynchronous Networking Library
+#    See http://weightless.io
+#    Copyright (C) 2010-2011 Seek You Too (CQ2) http://www.cq2.nl
+#
+#    This file is part of Weightless
+#
+#    Weightless is free software; you can redistribute it and/or modify
+#    it under the terms of the GNU General Public License as published by
+#    the Free Software Foundation; either version 2 of the License, or
+#    (at your option) any later version.
+#
+#    Weightless is distributed in the hope that it will be useful,
+#    but WITHOUT ANY WARRANTY; without even the implied warranty of
+#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+#    GNU General Public License for more details.
+#
+#    You should have received a copy of the GNU General Public License
+#    along with Weightless; if not, write to the Free Software
+#    Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+#
+## end license ##
+from traceback import print_exc
+from sys import exc_info
+
+class Suspend(object):
+    def __init__(self, doNext=lambda this: None):
+        self._doNext = doNext
+        self._exception = None
+
+    def __call__(self, reactor, whenDone):
+        self._reactor = reactor
+        try:
+            self._doNext(self)
+        except Exception:
+            self._exception = exc_info()
+            print_exc()
+        else:
+            self._whenDone = whenDone
+            self._handle = reactor.suspend()
+
+    def resume(self, response=None):
+        self._response = response
+        self._whenDone()
+
+    def throw(self, exc_type, exc_value=None, exc_traceback=None):
+        """Accepts either a full exception triple or only a single exception instance (not encouraged as it loses traceback information)."""
+        if exc_value is None and exc_traceback is None:
+            self._exception = type(exc_type), exc_type, None
+        else:
+            self._exception = (exc_type, exc_value, exc_traceback)
+        self._whenDone()
+
+    def resumeWriter(self):
+        if hasattr(self, "_handle"):
+            self._reactor.resumeWriter(self._handle)
+
+    def getResult(self):
+        if self._exception:
+            raise self._exception[0], self._exception[1], self._exception[2]
+        return self._response
+
Only in version_0/weightless: _httpget.py
Only in version_0/weightless: _httpreader.py
Only in version_0/weightless: _httpserver.py
diff --unidirectional-new-file '--exclude=*.so' '--exclude=*.o' '--exclude=.svn' '--exclude=*.pyc' '--exclude=deps.d' '--exclude=applied' --recursive --unified version_0/weightless/__init__.py version_1/weightless/__init__.py
--- version_0/weightless/__init__.py	2011-02-12 11:50:45.000000000 +0100
+++ version_1/weightless/__init__.py	2011-02-15 08:48:32.000000000 +0100
@@ -1,7 +1,8 @@
 ## begin license ##
 #
 #    Weightless is a High Performance Asynchronous Networking Library
-#    Copyright (C) 2006-2009 Seek You Too (CQ2) http://www.cq2.nl
+#    See http://weightless.io
+#    Copyright (C) 2006-2011 Seek You Too (CQ2) http://www.cq2.nl
 #
 #    This file is part of Weightless
 #
@@ -20,24 +21,6 @@
 #    Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
 #
 ## end license ##
+from pkgutil import extend_path
+__path__ = extend_path(__path__, __name__)
 
-VERSION='0.4.x' # in makeDeb.sh this is replaced by a real version number.
-
-from platform import python_version
-import sys
-from os import system
-from os.path import dirname, abspath, isdir, join
-
-from python2_5._compose_py import compose
-
-from _acceptor import Acceptor
-from _reactor import Reactor, reactor
-from _httpreader import HttpReader, Connector
-from _httpserver import HttpServer, HttpsServer
-from _local import local
-from _suspend import Suspend
-
-from _gutils import tostring, identify, autostart
-from _local import local
-
-from _httpget import httpget
diff --unidirectional-new-file '--exclude=*.so' '--exclude=*.o' '--exclude=.svn' '--exclude=*.pyc' '--exclude=deps.d' '--exclude=applied' --recursive --unified version_0/weightless/io/__init__.py version_1/weightless/io/__init__.py
--- version_0/weightless/io/__init__.py	1970-01-01 01:00:00.000000000 +0100
+++ version_1/weightless/io/__init__.py	2011-02-15 08:48:31.000000000 +0100
@@ -0,0 +1,26 @@
+## begin license ##
+#
+#    Weightless is a High Performance Asynchronous Networking Library
+#    See http://weightless.io
+#    Copyright (C) 2006-2011 Seek You Too (CQ2) http://www.cq2.nl
+#
+#    This file is part of Weightless
+#
+#    Weightless is free software; you can redistribute it and/or modify
+#    it under the terms of the GNU General Public License as published by
+#    the Free Software Foundation; either version 2 of the License, or
+#    (at your option) any later version.
+#
+#    Weightless is distributed in the hope that it will be useful,
+#    but WITHOUT ANY WARRANTY; without even the implied warranty of
+#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+#    GNU General Public License for more details.
+#
+#    You should have received a copy of the GNU General Public License
+#    along with Weightless; if not, write to the Free Software
+#    Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+#
+## end license ##
+
+from _reactor import Reactor, reactor
+
diff --unidirectional-new-file '--exclude=*.so' '--exclude=*.o' '--exclude=.svn' '--exclude=*.pyc' '--exclude=deps.d' '--exclude=applied' --recursive --unified version_0/weightless/io/_reactor.py version_1/weightless/io/_reactor.py
--- version_0/weightless/io/_reactor.py	1970-01-01 01:00:00.000000000 +0100
+++ version_1/weightless/io/_reactor.py	2011-02-15 08:48:31.000000000 +0100
@@ -0,0 +1,213 @@
+# -*- coding: utf-8 -*-
+## begin license ##
+#
+#    Weightless is a High Performance Asynchronous Networking Library
+#    See http://weightless.io
+#    Copyright (C) 2006-2011 Seek You Too (CQ2) http://www.cq2.nl
+#
+#    This file is part of Weightless
+#
+#    Weightless is free software; you can redistribute it and/or modify
+#    it under the terms of the GNU General Public License as published by
+#    the Free Software Foundation; either version 2 of the License, or
+#    (at your option) any later version.
+#
+#    Weightless is distributed in the hope that it will be useful,
+#    but WITHOUT ANY WARRANTY; without even the implied warranty of
+#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+#    GNU General Public License for more details.
+#
+#    You should have received a copy of the GNU General Public License
+#    along with Weightless; if not, write to the Free Software
+#    Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+#
+## end license ##
+from traceback import print_exc
+from inspect import currentframe
+from select import select, error
+from time import time
+from errno import EBADF, EINTR
+import os
+
+def reactor():
+    frame = currentframe().f_back
+    while '__reactor__' not in frame.f_locals:
+        frame = frame.f_back
+    return frame.f_locals['__reactor__']
+
+class Context(object):
+    def __init__(self, callback, prio):
+        self.callback = callback
+        self.prio = prio
+        self.locals = {}
+
+class Timer(Context):
+    def __init__(self, seconds, callback):
+        Context.__init__(self, callback, Reactor.DEFAULTPRIO)
+        assert seconds >= 0, 'Timeout must be >= 0. It was %s.' % seconds
+        self.time = time() + seconds
+
+    def __cmp__(self, rhs):
+        if not rhs:
+            return 1
+        return cmp(self.time, rhs.time)
+
+    def __eq__(self, other):
+        return other and \
+                other.__class__ == Timer and \
+                other.time == self.time and \
+                other.callback == self.callback
+
+class Reactor(object):
+    """This Reactor allows applications to be notified of read, write or time events.  The callbacks being executed can contain instructions to modify the reader, writers and timers in the reactor.  Additions of new events are effective with the next step() call, removals are effective immediately, even if the actual event was already trigger, but the handler wat not called yet."""
+
+    MAXPRIO = 10
+    DEFAULTPRIO = 0
+
+    def __init__(self, select_func = select):
+        self._readers = {}
+        self._writers = {}
+        self._suspended = {}
+        self._timers = []
+        self._select = select_func
+        self._prio = 0
+
+    def addReader(self, sok, sink, prio=None):
+        """Adds a socket and calls sink() when the socket becomes readable. It remains at the readers list."""
+        if not prio:
+            prio = Reactor.DEFAULTPRIO
+        if not 0 <= prio < Reactor.MAXPRIO:
+            raise ValueError('Invalid priority: %s' % prio)
+        if sok in self._suspended:
+            raise ValueError('Socket is suspended')
+        self._readers[sok] = Context(sink, prio)
+
+    def addWriter(self, sok, source, prio=None):
+        """Adds a socket and calls source() whenever the socket is writable. It remains at the writers list."""
+        if not prio:
+            prio = Reactor.DEFAULTPRIO
+        if not 0 <= prio < Reactor.MAXPRIO:
+            raise ValueError('Invalid priority: %s' % prio)
+        if sok in self._suspended:
+            raise ValueError('Socket is suspended')
+        self._writers[sok] = Context(source, prio)
+
+    def addTimer(self, seconds, callback):
+        """Add a timer that calls callback() after the specified number of seconds. Afterwards, the timer is deleted.  It returns a token for removeTimer()."""
+        timer = Timer(seconds, callback)
+        self._timers.append(timer)
+        self._timers.sort()
+        return timer
+
+    def removeReader(self, sok):
+        del self._readers[sok]
+
+    def removeWriter(self, sok):
+        del self._writers[sok]
+
+    def removeTimer(self, token):
+        self._timers.remove(token)
+
+    def cleanup(self, sok):
+        self._writers.pop(sok, None)
+        self._readers.pop(sok, None)
+        self._suspended.pop(sok, None)
+
+    def suspend(self):
+        self._readers.pop(self.currentsok, None)
+        self._writers.pop(self.currentsok, None)
+        self._suspended[self.currentsok] = self.currentcontext
+        return self.currentsok
+
+    def resumeWriter(self, handle):
+        self._writers[handle] = self._suspended.pop(handle)
+
+    def shutdown(self):
+        for sok in self._readers: sok.close()
+        for sok in self._writers: sok.close()
+        for sok in self._suspended: sok.close()
+
+    def loop(self):
+        try:
+            while True:
+                self.step()
+        finally:
+            self.shutdown()
+
+    def step(self):
+        __reactor__ = self
+
+        aTimerTimedOut = False
+        self._prio = (self._prio + 1) % Reactor.MAXPRIO
+        if self._timers:
+            timeout = max(0, self._timers[0].time - time())
+        else:
+            timeout = None
+
+        try:
+            rReady, wReady, ignored = self._select(self._readers.keys(), self._writers.keys(), [], timeout)
+        except TypeError:
+            print_exc()
+            self._findAndRemoveBadFd()
+            return self
+        except error, (errno, description):
+            if errno == EBADF:
+                self._findAndRemoveBadFd()
+            elif errno == EINTR:
+                pass
+            else:
+                raise
+            return self
+        except KeyboardInterrupt:
+            self.shutdown()
+            raise
+
+        for timer in self._timers[:]:
+            if timer.time > time():
+                break
+            try:
+                self.currentcontext = timer
+                timer.callback()
+            except AssertionError:
+                raise
+            except:
+                print_exc()
+            finally:
+                del self._timers[0]
+
+        self._callback(rReady, self._readers)
+        self._callback(wReady, self._writers)
+
+        return self
+
+    def getOpenConnections(self):
+        return len(self._readers) + len(self._writers)
+
+    def _callback(self, ready, soks):
+        for self.currentsok in ready:
+            if self.currentsok in soks:
+                try:
+                    context = soks[self.currentsok]
+                    if context.prio <= self._prio:
+                        self.currentcontext = context
+                        context.callback()
+                except AssertionError:
+                    raise
+                except:
+                    print_exc()
+                    if self.currentsok in soks:
+                        del soks[self.currentsok]
+
+    def _findAndRemoveBadFd(self):
+        for sok in self._readers:
+            try:
+                select([sok], [], [], 0)
+            except:
+                del self._readers[sok]
+                return
+        for sok in self._writers:
+            try:
+                select([], [sok], 0)
+            except:
+                del self._writers[sok]
+                return
Only in version_0/weightless: _local.py
Only in version_0/weightless: python2_5
Only in version_0/weightless: _reactor.py
Only in version_0/weightless: _suspend.py
Only in version_0/weightless: transparentsocket.py
Only in version_0/weightless: utils
