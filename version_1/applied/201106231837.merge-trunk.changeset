Changeset created on Thu Jun 23 18:37:06 CEST 2011 by Seek You Too

Description: Merge trunk.  Restructure modules.  Adds Observable and httpng

    This merge is intended to remove trunk completely.  It restructures the modules in 0.5.x in such a way that it is compatible with trunk.  All stuff from trunk is then merged into 0.5.x.  The old HTTP stack is still in the module 'http', and the new http stuff is in httpng.  The new version is compatible with the previous version, except that import might fail.  Things have moved: Reactor is now in weightless.io for example.

Baseline version: https://weightless.svn.sourceforge.net/svnroot/weightless/weightless-core/workingsets/0.5.2.3-seecr/version_0

diff --unidirectional-new-file '--exclude=*.so' '--exclude=*.o' '--exclude=.svn' '--exclude=*.pyc' '--exclude=deps.d' '--exclude=applied' --recursive --unified version_0/deps.txt version_0-merge-trunk/deps.txt
--- version_0/deps.txt	2011-06-21 09:47:06.000000000 +0200
+++ version_0-merge-trunk/deps.txt	2011-06-21 10:31:47.000000000 +0200
@@ -1,4 +1,2 @@
-python-cq2utils (>=5.4)
-python-cq2utils (<<5.5)
 python-openssl
 
diff --unidirectional-new-file '--exclude=*.so' '--exclude=*.o' '--exclude=.svn' '--exclude=*.pyc' '--exclude=deps.d' '--exclude=applied' --recursive --unified version_0/doc/speedComparisonCallVsCurryVsGeneratorVsClass.py version_0-merge-trunk/doc/speedComparisonCallVsCurryVsGeneratorVsClass.py
--- version_0/doc/speedComparisonCallVsCurryVsGeneratorVsClass.py	1970-01-01 01:00:00.000000000 +0100
+++ version_0-merge-trunk/doc/speedComparisonCallVsCurryVsGeneratorVsClass.py	2011-02-28 16:17:10.000000000 +0100
@@ -0,0 +1,64 @@
+## begin license ##
+#
+#    Weightless is a High Performance Asynchronous Networking Library
+#    See http://weightless.io
+#    Copyright (C) 2006-2011 Seek You Too (CQ2) http://www.cq2.nl
+#
+#    This file is part of Weightless
+#
+#    Weightless is free software; you can redistribute it and/or modify
+#    it under the terms of the GNU General Public License as published by
+#    the Free Software Foundation; either version 2 of the License, or
+#    (at your option) any later version.
+#
+#    Weightless is distributed in the hope that it will be useful,
+#    but WITHOUT ANY WARRANTY; without even the implied warranty of
+#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+#    GNU General Public License for more details.
+#
+#    You should have received a copy of the GNU General Public License
+#    along with Weightless; if not, write to the Free Software
+#    Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+#
+## end license ##
+from functools import partial as curry
+from time import time
+
+def f(a):
+    b = a
+
+t0 = time()
+
+for i in xrange(10**6):
+    f('a')
+
+t1 = time()
+print 'Function call sec', t1-t0, 'us 100%'
+
+for i in xrange(10**6):
+    curry(f, 'a')()
+
+t2 = time()
+print 'With Curry', t2-t1, 'us', (t2-t1)/(t1-t0)*100, '%'
+
+def f(a):
+    yield
+    b = a
+
+for i in xrange(10**6):
+    f('a').next()
+
+t3 = time()
+print 'With Generator', t3-t2, 'us', (t3-t2)/(t1-t0)*100, '%'
+
+class f:
+    def __init__(self, a):
+        self.a = a
+    def __call__(self):
+        b = self.a
+
+for i in xrange(10**6):
+    f('a')()
+
+t4 = time()
+print 'With Class', t4-t3, 'us', (t4-t3)/(t1-t0)*100, '%'
\ No newline at end of file
diff --unidirectional-new-file '--exclude=*.so' '--exclude=*.o' '--exclude=.svn' '--exclude=*.pyc' '--exclude=deps.d' '--exclude=applied' --recursive --unified version_0/setup.py version_0-merge-trunk/setup.py
--- version_0/setup.py	2011-06-21 09:47:06.000000000 +0200
+++ version_0-merge-trunk/setup.py	2011-06-21 10:32:47.000000000 +0200
@@ -35,12 +35,18 @@
         'weightless.core.utils',
         'weightless.http', 
         'weightless.io',
+		'weightless.examples',
     ],
     url='http://www.weightless.io',
     author='Seek You Too',
     author_email='info@cq2.nl',
-    description='Weightless is a High Performance Asynchronous Networking Library.',
-    long_description='Weightless is a High Performance Asynchronous Networking Library.',
+    description='Weightless data-processing with coroutines',
+    long_description="""
+Weightless presents a way to implement data-processing programs, such as web-servers, with coroutines in Python. The results are lightweight, efficient and readable programs without call-backs, threads and buffering. Weightless supports:
+1. decomposing programs into coroutines using compose
+2. creating pipelines using the observer pattern
+3. connecting file descriptors (sockets etc) to pipelines using gio
+""",
     license='GNU Public License',
     platforms=['linux'],
     ext_modules=[
@@ -48,6 +54,20 @@
             "weightless/core/compose/_compose.c"
             ],
         )
-    ]
+    ],
+    classifiers=[
+        'Development Status :: 3 - Alpha',
+        'Environment :: Web Environment',
+        'Intended Audience :: Developers',
+        'License :: OSI Approved :: GNU General Public License (GPL)',
+        'Operating System :: POSIX :: Linux',
+        'Programming Language :: Python',
+        'Topic :: Communications',
+        'Topic :: Internet :: WWW/HTTP :: Dynamic Content',
+        'Topic :: Internet :: WWW/HTTP :: HTTP Servers',
+        'Topic :: Software Development :: Libraries :: Application Frameworks',
+        'Topic :: Text Processing'
+        ],
+
 )
 
diff --unidirectional-new-file '--exclude=*.so' '--exclude=*.o' '--exclude=.svn' '--exclude=*.pyc' '--exclude=deps.d' '--exclude=applied' --recursive --unified version_0/test/_alltests.py version_0-merge-trunk/test/_alltests.py
--- version_0/test/_alltests.py	2011-06-21 09:47:06.000000000 +0200
+++ version_0-merge-trunk/test/_alltests.py	2011-06-21 10:26:59.000000000 +0200
@@ -36,15 +36,14 @@
 
 from unittest import main
 from types import GeneratorType
+
 from weightless.core.compose import ComposeType
 if ComposeType == GeneratorType:
-    from composetest import ComposePyTest
+    from core.composetest import ComposePyTest
 else:
-    from composetest import ComposeCTest
-from localtest import LocalTest
-from sidekicktest import SidekickTest
-from reactortest import ReactorTest
-from servertestcasetest import ServerTestCaseTest
+    from core.composetest import ComposeCTest
+from core.localtest import LocalTest
+from core.sidekicktest import SidekickTest
 
 from http.acceptortest import AcceptorTest
 from http.httpreadertest import HttpReaderTest
@@ -54,5 +53,16 @@
 from http.suspendtest import SuspendTest
 from http.asyncreadertest import AsyncReaderTest
 
+from core.observabletest import ObservableTest
+from core.observabledirectedmessagingtest import ObservableDirectedMessagingTest
+
+from io.reactortest import ReactorTest
+from io.giotest import GioTest
+from io.gutilstest import GutilsTest
+from io.servertest import ServerTest
+
+from httpng.httpprotocolintegrationtest import HttpProtocolIntegrationTest
+from httpng.httpprotocoltest import HttpProtocolTest
+
 if __name__ == '__main__':
     main()
diff --unidirectional-new-file '--exclude=*.so' '--exclude=*.o' '--exclude=.svn' '--exclude=*.pyc' '--exclude=deps.d' '--exclude=applied' --recursive --unified version_0/test/alltests.sh version_0-merge-trunk/test/alltests.sh
--- version_0/test/alltests.sh	2011-06-21 09:47:06.000000000 +0200
+++ version_0-merge-trunk/test/alltests.sh	2011-06-21 10:28:21.000000000 +0200
@@ -48,4 +48,3 @@
         WEIGHTLESS_COMPOSE_TEST=$t $pycmd _alltests.py "$@"
     done
 done
-
Only in version_0/test: basetestcase.py
Only in version_0/test: composetest.py
diff --unidirectional-new-file '--exclude=*.so' '--exclude=*.o' '--exclude=.svn' '--exclude=*.pyc' '--exclude=deps.d' '--exclude=applied' --recursive --unified version_0/test/core/composetest.py version_0-merge-trunk/test/core/composetest.py
--- version_0/test/core/composetest.py	1970-01-01 01:00:00.000000000 +0100
+++ version_0-merge-trunk/test/core/composetest.py	2011-06-21 10:19:07.000000000 +0200
@@ -0,0 +1,1106 @@
+## begin license ##
+#
+#    Weightless is a High Performance Asynchronous Networking Library
+#    See http://weightless.io
+#    Copyright (C) 2006-2011 Seek You Too (CQ2) http://www.cq2.nl
+#
+#    This file is part of Weightless
+#
+#    Weightless is free software; you can redistribute it and/or modify
+#    it under the terms of the GNU General Public License as published by
+#    the Free Software Foundation; either version 2 of the License, or
+#    (at your option) any later version.
+#
+#    Weightless is distributed in the hope that it will be useful,
+#    but WITHOUT ANY WARRANTY; without even the implied warranty of
+#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+#    GNU General Public License for more details.
+#
+#    You should have received a copy of the GNU General Public License
+#    along with Weightless; if not, write to the Free Software
+#    Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+#
+## end license ##
+
+from unittest import TestCase
+from sys import stdout, exc_info, getrecursionlimit, version_info
+import gc
+from weakref import ref
+from types import GeneratorType
+from weightless.core import autostart
+from weightless.core.compose._local_py import local as pyLocal
+from weightless.core.compose._compose_py import compose as pyCompose
+from weightless.core.compose._tostring_py import tostring as pyTostring
+from weightless.core.compose._compose_c import local as cLocal, compose as cCompose
+from weightless.core.compose._compose_c import tostring as cTostring
+
+class ATrackedObj(object):
+    def __init__(self):
+        self.l = []
+        
+class _ComposeTest(TestCase):
+
+    def testCallCompose(self):
+        try:
+            compose()
+            self.fail()
+        except TypeError, e:
+            self.assertTrue(
+                    "compose() takes at least 1 argument (0 given)" in str(e)
+                    or # (python 2.5/2.6 C-API differences)
+                    "Required argument 'initial' (pos 1) not found" in str(e))
+        self.assertRaises(TypeError, compose, 's')
+        self.assertRaises(TypeError, compose, 0)
+
+    def testGC(self):
+        c = compose((x for x in []))
+        gc.collect()
+        del c
+        gc.collect()
+
+    def assertComposeImpl(self, impl):
+        self.assertEquals(impl, compose)
+
+    def testCreateSinglecompose(self):
+        def multplyBy2(number): yield number * 2
+        g = multplyBy2(2)
+        wlt = compose(g)
+        response = wlt.next()
+        self.assertEquals(4, response)
+
+    def testRunCompletely(self):
+        wlt = compose(x for x in range(3))
+        results = list(wlt)
+        self.assertEquals([0,1,2], results)
+
+    def testCreateNestedcompose(self):
+        def multplyBy2(number): yield number * 2
+        def delegate(number): yield multplyBy2(number * 2)
+        wlt = compose(delegate(2))
+        response = wlt.next()
+        self.assertEquals(8, response)
+
+    def testCreateTripleNextedcompose(self):
+        def multplyBy2(number): yield number * 2
+        def delegate(number): yield multplyBy2(number * 2)
+        def master(number): yield delegate(number * 2)
+        wlt = compose(master(2))
+        response = wlt.next()
+        self.assertEquals(16, response)
+
+    def testResumecompose(self):
+        def thread():
+            yield 'A'
+            yield 'B'
+        wlt = compose(thread())
+        response = wlt.next()
+        self.assertEquals('A', response)
+        response = wlt.next()
+        self.assertEquals('B', response)
+
+    def testResumeNestedcompose(self):
+        def threadA():
+            yield 'A'
+            yield 'B'
+        def threadB():
+            yield 'C'
+            yield threadA()
+            yield 'D'
+        wlt = compose(threadB())
+        results = list(wlt)
+        self.assertEquals(['C','A','B','D'], results)
+
+    def testPassValueToRecursivecompose(self):
+        def threadA():
+            r = yield threadB()     # <= C
+            yield r * 3                     # <= D
+        def threadB():
+            yield 7                     # <= A
+            r = yield
+            raise StopIteration(r * 2)     # <= B
+        t = compose(threadA())
+        self.assertEquals(7, t.next())              # 7 yielded at A
+        t.next() # adhere to 'send on None' protocol
+        self.assertEquals(18, t.send(3))        # 3 send to A, 6 yielded at B, as return value to C, then yielded at D
+
+    def testReturnOne(self):
+        data = []
+        def child():
+            raise StopIteration('result')
+            yield
+        def parent():
+            result = yield child()
+            data.append(result)
+        g = compose(parent())
+        list(g)
+        self.assertEquals('result', data[0])
+
+    def testReturnThree(self):
+        data = []
+        def child():
+            raise StopIteration('result', 'remainingData1', 'other2')
+            yield
+        def parent():
+            result = yield child()
+            data.append(result)
+            remainingData = yield None
+            data.append(remainingData)
+            other2 = yield None
+            data.append(other2)
+        g = compose(parent())
+        list(g)
+        self.assertEquals('result', data[0])
+        self.assertEquals('remainingData1', data[1])
+        self.assertEquals('other2', data[2])
+
+    def testReturnAndCatchRemainingDataInNextGenerator(self):
+        messages = []
+        responses = []
+        def child1():
+            raise StopIteration('result', 'remainingData0', 'remainingData1')
+            yield
+        def child2():
+            messages.append((yield 'A'))                # I want to 'send' and do not accept data
+            messages.append((yield))                     # now accept 'remainingData0'
+            messages.append((yield))                     # append 'remainingData1'
+            messages.append((yield 'C'))               # append None (I want to send)
+        def parent():
+            messages.append((yield child1()))   # append 'result'
+            messages.append((yield child2()))   # what does 'yield child2()' return???
+        g = compose(parent())
+        responses.append(g.send(None))
+        responses.append(g.send(None))
+        #responses.append(g.send(None))
+        try:
+            responses.append(g.send(None))
+            self.fail()
+        except StopIteration:
+            pass
+        self.assertEquals(['result', None, 'remainingData0', 'remainingData1', None, None], messages)
+        self.assertEquals(['A', 'C'], responses)
+
+    def testStopIterationWithReturnValue(self):
+        def f():
+            raise StopIteration('return value')
+            yield 'something'
+        def g():
+            self.retval = yield f()
+        list(compose(g()))
+        self.assertEquals('return value', self.retval)
+
+    def testReturnInNestedGeneratorQuiteTricky(self):
+        r = []
+        def ding1():
+            dataIn = yield None     # receive 'dataIn'
+            self.assertEquals('dataIn', dataIn)
+            raise StopIteration('ding1retval', 'rest('+dataIn+')')
+        def ding2():
+            dataIn = yield None     # receive 'rest(dataIn)'
+            #retval = RETURN, 'ding2retval', 'rest('+dataIn+')'
+            raise StopIteration('ding2retval', 'rest('+dataIn+')')
+        def child():
+            ding1retval = yield ding1()
+            r.append('child-1:' + str(ding1retval))
+            ding2retval = yield ding2()
+            r.append('child-2:' + str(ding2retval))
+            raise StopIteration('childretval')
+        def parent():
+            childRetVal = yield child()
+            self.assertEquals('childretval', childRetVal)
+            rest = yield
+            r.append('parent:'+rest)
+        g = compose(parent())
+        g.next()
+        try:
+            g.send('dataIn')
+            self.fail()
+        except StopIteration:
+            pass
+        self.assertEquals(['child-1:ding1retval', 'child-2:ding2retval', 'parent:rest(rest(dataIn))'], r)
+
+    def testCheckForFreshGenerator(self):
+        def sub():
+            yield
+            yield
+        def main():
+            s = sub()
+            s.next() # start it already
+            yield s
+        c = compose(main())
+        try:
+            c.next()
+            self.fail('must raise')
+        except Exception, e:
+            self.assertEquals('Generator already used.', str(e))
+
+    def testForExhaustedGenerator(self):
+        def sub():
+            yield
+        def main():
+            s = sub()
+            s.next()
+            try:
+                s.next()
+                self.fail('must raise StopIteration')
+            except StopIteration: pass
+            yield s
+        c = compose(main())
+        try:
+            c.next()
+            self.fail('must not come here')
+        except Exception, e:
+            self.assertEquals('Generator is exhausted.', str(e))
+
+    def testPassThrowCorrectly(self):
+        class MyException(Exception): pass
+        def child():
+            try:
+                yield 1
+            except Exception, e:
+                self.e = e
+            yield 2
+        g = compose(child())
+        g.next()
+        g.throw(MyException('aap'))
+        self.assertEquals('aap', str(self.e))
+
+    def testThrowWithLocalCorrectly(self):
+        class MyException(Exception): pass
+        def child(x):
+            try:
+                yield 1
+            except Exception, e:
+                yield f2()
+        def f2():
+            self.e = local("x")
+            yield 2
+        a = compose(child("test"))
+        g = compose(child("aap"))
+        g.next()
+        g.throw(MyException())
+        self.assertEquals('aap', str(self.e))
+
+    def testHandleAllDataAndDoAvoidSuperfluousSendCalls(self):
+        data = []
+        def f():
+            x = yield
+            data.append(x)
+            raise StopIteration(*tuple(x))
+        def g():
+            r = yield f()
+            data.append(r)
+            while True:
+                data.append((yield None))
+        program = compose(g())
+        program.next() # init
+        program.send('mies')
+        #program.next() # this is what we don't want and what we're testing here
+        #program.next()
+        #program.next()
+        self.assertEquals('mies', data[0])
+        self.assertEquals('m', data[1])
+        self.assertEquals('i', data[2])
+        self.assertEquals('e', data[3])
+        self.assertEquals('s', data[4])
+        program.close()
+
+    def testHandleClose(self):
+        r = []
+        def f():
+            try:
+                yield None
+            except BaseException, e:
+                r.append(e)
+                raise
+        g = compose(f())
+        g.next()
+        g.close()
+        self.assertEquals(GeneratorExit, type(r[0]))
+
+    def testCloseWithLocalCorrectly(self):
+        class MyException(Exception): pass
+        def child(x):
+            yield f2()
+        def f2():
+            try:
+                yield 1
+            except BaseException, e:
+                self.e = local("x")
+                raise
+        g = compose(child("aap"))
+        g.next()
+        g.close()
+        self.assertEquals('aap', str(self.e))
+
+    def testHandleStop(self):
+        r = []
+        def f():
+            try:
+                yield None
+            except Exception, e:
+                r.append(e)
+                raise
+        g = compose(f())
+        g.next()
+        try:
+            g.throw(StopIteration)
+        except:
+            pass
+        self.assertEquals(StopIteration, type(r[0]))
+
+    def testPassException1(self):
+        class MyException(Exception): pass
+        class WrappedException(Exception): pass
+        def child():
+            raise MyException('abc')
+            yield None
+        def parent():
+            try:
+                yield child()
+            except MyException, e:
+                raise WrappedException(e)
+        g = compose(parent())
+        try:
+            g.next()
+            self.fail()
+        except WrappedException, e:
+            self.assertEquals('abc', str(e))
+
+    def testDealloc(self):
+        def f():
+            yield 'A'
+            yield (1,2,3,4)
+            yield 'B'
+            yield 'C'
+            yield 'D'
+        g = compose(f())
+        g.next()
+        g.next()
+        del g
+
+    def testPassException2(self):
+        class MyException(Exception): pass
+        class WrappedException(Exception): pass
+        def child():
+            yield None
+            raise MyException('abc')
+        def parent():
+            try:
+                yield child()
+            except MyException, e:
+                raise WrappedException(e)
+        g = compose(parent())
+        g.next()
+        try:
+            g.next()
+            self.fail()
+        except WrappedException, e:
+            self.assertEquals('abc', str(e))
+
+    def xtestPerformance(self):
+        def f1(arg):
+            r = yield None
+            yield arg
+            raise StopIteration('aap', 'rest')
+        def f2(arg):
+            r1 = yield f1('noot')
+            r2 = yield f1('mies')
+        def f3(arg):
+            yield 'A'
+            r = yield None
+            yield 'B'
+            a = yield f2('C')
+            b = yield f2('D')
+            yield a
+            yield b
+        # name, creates, runs
+        #       f3          1           1
+        #       f2          2           2
+        #       f1          4           4
+        #   total       7           7
+        def baseline():
+            list(f3('A'))   # 3     1
+            list(f2('B'))   # 3     1
+            list(f1('C'))   # 1     1
+            list(f1('C'))   # 1     1
+                                # 8     4  (versus 7        7)
+        from time import time
+        tg = tb = 0.0
+        for i in range(10):
+            stdout.write('*')
+            stdout.flush()
+            t0 = time()
+            [list(compose(f3('begin'))) for i in xrange(100)]
+            t1 = time()
+            tg = tg + t1 - t0
+            [baseline() for i in xrange(100)]
+            t2 = time()
+            tb = tb + t2 - t1
+        print 'Overhead compose compared to list(): %2.2f %%' % ((tg/tb - 1) * 100.0)
+
+    def testMemLeaks(self):
+        def f1(arg):
+            r = yield arg                       # None
+            raise Exception()
+        def f2(arg):
+            r1 = yield None                 # 'A'
+            try:
+                r2 = yield f1(r1)
+            except GeneratorExit:
+                raise
+            except Exception, e:
+                raise StopIteration(e, 'more')
+        def f3(arg):
+            e = yield f2('aa')
+            more = yield None
+            try:
+                yield more                      #   'X'
+            except Exception:
+                raise
+        # runs this a zillion times and watch 'top'
+        for i in xrange(1):
+            g = compose(f3('noot'))
+            g.next()
+            g.send('A')
+            g.send(None)
+            try:
+                g.throw(Exception('X'))
+            except:
+                pass
+
+    def testNestedExceptionHandling(self):
+        def f():
+            yield 'A'
+        def g():
+            try:
+                yield f()
+            except Exception, e:
+                raise Exception(e)
+        c = compose(g())
+        r = c.next()
+        self.assertEquals('A', r)
+        try:
+            c.throw(Exception('wrong'))
+            self.fail('must raise wrapped exception')
+        except Exception, e:
+            self.assertEquals("Exception(Exception('wrong',),)", repr(e))
+
+    def testNestedClose(self):
+        def f():
+            yield 'A'
+        def g():
+            try:
+                yield f()
+            except BaseException, e:
+                raise Exception(e)
+        c = compose(g())
+        r = c.next()
+        self.assertEquals('A', r)
+        try:
+            c.close()
+            self.fail('must raise wrapped CLOSE exception')
+        except Exception, e:
+            self.assertEquals("Exception(GeneratorExit(),)", repr(e))
+
+    def testMaskException(self):
+        def f():
+            try:
+                yield 'a'
+            except:
+                pass
+        c = compose(f())
+        c.next()
+        try:
+            c.throw(Exception('aap'))
+        except StopIteration:
+            pass
+        except Exception, e:
+            self.fail(str(e))
+
+    def testThrowWithExceptionCaughtDoesNotDitchResponse(self):
+        def f():
+            try:
+                yield 'response'
+            except StopIteration:
+                pass
+            yield 'is this ditched?'
+        c = compose(f())
+        response = c.next()
+        self.assertEquals('response', response)
+        response = c.throw(StopIteration())
+        self.assertEquals('is this ditched?', response)
+
+    def testThrowWithExceptionCaughtDoesNotDitchResponseWhileInSubGenerator(self):
+        def sub():
+            try:
+                yield 'response'
+            except StopIteration:
+                raise StopIteration('return')
+        def f():
+            ret = yield sub()
+            self.assertEquals('return', ret)
+            yield 'is this ditched?'
+        c = compose(f())
+        response = c.next()
+        self.assertEquals('response', response)
+        response = c.throw(StopIteration())
+        self.assertEquals('is this ditched?', response)
+
+    def testAdhereToYieldNoneMeansReadAndYieldValueMeansWriteWhenMessagesAreBuffered(self):
+        done = []
+        def bufferSome():
+            raise StopIteration('retval', 'rest1', 'rest2')
+            yield
+        def writeSome():
+            yield 'write this'
+        def g():
+            yield bufferSome()
+            yield writeSome()
+            data = yield 'write'
+            self.assertEquals(None, data)
+            data = yield
+            self.assertEquals('rest1', data)
+            done.append(True)
+        g = compose(g())
+        results = list(g)
+        self.assertEquals([True], done)
+        self.assertEquals(['write this', 'write'], results)
+
+    def testAdhereToYieldNoneMeansReadAndYieldValueMeansWriteWhenMessagesAreBuffered2(self):
+        done = []
+        def bufferSome():
+            raise StopIteration('retval', 'rest1', 'rest2')
+            yield
+        def writeSome():
+            data = yield 'write this'
+            self.assertEquals(None, data)
+        def g():
+            yield bufferSome()
+            yield writeSome()
+            data = yield
+            self.assertEquals('rest1', data)
+            done.append(True)
+        g = compose(g())
+        results = list(g)
+        self.assertEquals([True], done)
+        self.assertEquals(['write this'], results)
+
+    def testDoNotSendSuperfluousNonesOrAdhereToNoneProtocol(self):
+        def sub():
+            jack = yield None
+            none = yield 'hello ' + jack
+            peter = yield None
+            none = yield 'hello ' + peter
+        c = compose(sub())
+        self.assertEquals(None, c.send(None))           # 1 init with None, oh, it accepts data
+        self.assertEquals('hello jack', c.send('jack')) # 2 send data, oh it has data
+        self.assertEquals(None, c.send(None))           # 3 it had data, so send None to see what it wants next, oh, it accepts data
+        self.assertEquals('hello peter', c.send('peter')) # 4 send data, oh, it has data
+
+    def testUserAdheresToProtocol(self):
+        def sub():
+            yield 'response'
+            yield 'response'
+        c = compose(sub())
+        self.assertEquals('response', c.next())
+        try:
+            c.send('message')
+            self.fail('must raise exception')
+        except AssertionError, e:
+            self.assertEquals('Cannot accept data. First send None.', str(e))
+
+    def testExceptionsHaveGeneratorCallStackAsBackTrace(self):
+        def f():
+            yield
+        def g():
+            yield f()
+        c = compose(g())
+        c.next()
+        try:
+            c.throw(Exception, Exception('ABC'))
+            self.fail()
+        except Exception:
+            exType, exValue, exTraceback = exc_info()
+            self.assertEquals('testExceptionsHaveGeneratorCallStackAsBackTrace', exTraceback.tb_frame.f_code.co_name)
+            self.assertEquals('g', exTraceback.tb_next.tb_frame.f_code.co_name)
+            self.assertEquals('f', exTraceback.tb_next.tb_next.tb_frame.f_code.co_name)
+    
+    def testToStringForSimpleGenerator(self):
+        def f():
+            yield
+        g = f()
+        soll = """  File "%s", line 629, in f
+    def f():""" % __file__.replace('pyc', 'py')
+        self.assertEquals(soll, tostring(g))
+        g.next()
+        soll = """  File "%s", line 630, in f
+    yield""" % __file__.replace('pyc', 'py')
+        self.assertEquals(soll, tostring(g))
+
+
+    def testToStringGivesStackOfGeneratorsAKAcallStack(self):
+        def f1():
+            yield
+        def f2():
+            yield f1()
+        c = compose(f2())
+        result = """  File "%s", line 645, in f2
+    yield f1()
+  File "%s", line 643, in f1
+    yield""" % (2*(__file__.replace('pyc', 'py'),))
+        c.next()
+        self.assertEquals(result, tostring(c), "\n%s\n!=\n%s\n" % (result, tostring(c)))
+
+    def testToStringForUnstartedGenerator(self):
+        def f1():
+            yield
+        def f2():
+            yield f1()
+        c = compose(f2())
+        result = """  File "%s", line 657, in f2
+    def f2():""" % __file__.replace('pyc', 'py')
+        self.assertEquals(result, tostring(c))
+
+    def testWrongArgToToString(self):
+        try:
+            tostring('x')
+            self.fail('must raise TypeError')
+        except TypeError, e:
+            self.assertEquals("tostring() expects generator", str(e))
+
+    def testFindLocalNotThere(self):
+        def f1():
+            yield f2()
+        def f2():
+            try:
+                l = local('doesnotexist')
+            except AttributeError, e:
+                yield e
+        f = compose(f1())
+        result = f.next()
+        self.assertEquals('doesnotexist', str(result))
+
+    def testFindLocal(self):
+        def f1():
+            someLocal = 'f1'
+            yield f3()
+        def f2():
+            someLocal = 'f2'
+            yield f3()
+        def f3():
+            l = local('someLocal')
+            yield l
+        f = compose(f1())
+        result = f.next()
+        self.assertEquals('f1', str(result))
+        self.assertEquals('f2', str(compose(f2()).next()))
+
+    def testFindLocalWithComposeUnassignedToVariable(self):
+        def f1():
+            f1local = 'f1'
+            yield f2()
+        def f2():
+            l = local('f1local')
+            yield l
+        self.assertEquals('f1', compose(f1()).next())
+
+    def testFindClosestLocal(self):
+        def f1():
+            myLocal = 'f1'
+            yield f2()
+        def f2():
+            myLocal = 'f2'
+            yield f3()
+        def f3():
+            l = local('myLocal')
+            yield l
+        f = compose(f1())
+        result = f.next()
+        self.assertEquals('f2', str(result))
+
+    def testOneFromPEP380(self):
+        """
+        Exceptions other than GeneratorExit thrown into the delegating
+     generator are passed to the ``throw()`` method of the iterator.
+     If the call raises StopIteration, the delegating generator is resumed.
+     Any other exception is propagated to the delegating generator.
+     (EG: rationale is that normally SystemExit is not catched, but it must
+     trigger finally's to clean up.)
+        """
+        msg = []
+        def f():
+            try:
+                yield g()
+            except SystemExit, e:
+                msg.append('see me')
+            yield
+        def g():
+            try:
+                yield
+            except KeyboardInterrupt:
+                msg.append('KeyboardInterrupt')
+            try:
+                yield
+            except SystemExit:
+                msg.append('SystemExit')
+            try:
+                yield
+            except BaseException:
+                msg.append('BaseException')
+                raise SystemExit('see me')
+            yield
+        c = compose(f())
+        c.next()
+        c.throw(KeyboardInterrupt())
+        self.assertEquals(['KeyboardInterrupt'], msg)
+        c.throw(SystemExit())
+        self.assertEquals(['KeyboardInterrupt', 'SystemExit'], msg)
+        c.throw(SystemExit()) # second time
+        self.assertEquals(['KeyboardInterrupt', 'SystemExit', 'BaseException', 'see me'], msg)
+
+    def testTwoFromPEP380(self):
+        """
+        If a GeneratorExit exception is thrown into the delegating generator,
+     or the ``close()`` method of the delegating generator is called, then
+     the ``close()`` method of the iterator is called if it has one. If this
+     call results in an exception, it is propagated to the delegating generator.
+     Otherwise, GeneratorExit is raised in the delegating generator.
+        """
+
+        # First test some assumptions about close()
+
+        @autostart
+        def f1():
+            try:
+                yield
+            except GeneratorExit:
+                raise ValueError('1')
+            yield
+        g1 = f1()
+        try:
+            g1.close()
+            self.fail('must raise ValueError')
+        except ValueError, e:
+            self.assertEquals('1', str(e))
+
+        @autostart
+        def f2():
+            try:
+                yield
+            except GeneratorExit:
+                pass
+            # implicit raise StopIteration here
+
+        g2 = f2()
+        try:
+            g2.close()
+        except BaseException:
+            self.fail('must not raise an exception')
+
+        @autostart
+        def f3():
+            try:
+                yield
+            except GeneratorExit:
+                pass
+            yield  # does not raise an exception but yields None
+
+        g3 = f3()
+        try:
+            g3.close()
+            self.fail('must not raise an exception')
+        except RuntimeError, e:
+            self.assertEquals('generator ignored GeneratorExit', str(e))
+
+
+        @autostart
+        def f4():
+            yield
+            yield
+
+        g4 = f4()
+        try:
+            g4.close()
+        except BaseException, e:
+            self.fail('must not raise an exception')
+
+        # This is test one
+
+        msg = []
+        def f5():
+            yield f6()
+        def f6():
+            try:
+                yield
+            except GeneratorExit:
+                msg.append('GeneratorExit turned into StopIteration')
+                raise StopIteration  # <= this is the clue, see next test
+        g5 = compose(f5())
+        g5.next()
+        try:
+            g5.throw(GeneratorExit())
+            self.fail('must reraise GeneratorExit if no exception by g1()')
+        except GeneratorExit:
+            pass
+        self.assertEquals(['GeneratorExit turned into StopIteration'], msg)
+
+        msg = []
+        def f7():
+            yield f8()
+        def f8():
+            try:
+                yield
+            except GeneratorExit:
+                msg.append('GeneratorExit ignored')
+            yield # <= this is the clue, see previous test
+        g7 = compose(f7())
+        g7.next()
+        try:
+            g7.throw(GeneratorExit)
+            self.fail('must reraise RuntimeError(generator ignored GeneratorExit)')
+        except RuntimeError:
+            pass
+        self.assertEquals(['GeneratorExit ignored'], msg)
+
+
+        # Second case
+
+        msg = []
+        def f8():
+            try:
+                yield f9()
+            #except RuntimeError, e:
+            except ValueError, e:
+                msg.append(str(e))
+                raise StopIteration()
+        def f9():
+            try:
+                yield
+            except GeneratorExit:
+                msg.append('GeneratorExit turned into ValueError')
+                #raise RuntimeError('stop here')
+                raise ValueError('stop here')
+            yield
+
+        g8 = compose(f8())
+        g8.next()
+        try:
+            g8.throw(GeneratorExit())
+            self.fail('must raise StopIteration')
+        except StopIteration:
+            pass
+        self.assertEquals(['GeneratorExit turned into ValueError', 'stop here'], msg)
+
+    def testYieldCompose(self):
+        def f():
+            yield "f"
+        def g():
+            yield compose(f())
+        c = compose(g())
+        self.assertEquals(['f'], list(c))
+
+    def testComposeCompose(self):
+        def f():
+            yield
+        c = compose(compose(f()))
+        self.assertTrue(c)
+
+    def testYieldComposeCloseAndThrow(self):
+        def f():
+            try:
+                yield 42
+            except Exception, e:
+                yield 84
+
+        c = compose(f())
+        self.assertEquals(42, c.send(None))
+        self.assertEquals(84, c.throw(Exception()))
+        self.assertEquals(None, c.close())
+
+    def testMessagesAndResponseAreFreed(self):
+        def f():
+            v = yield ATrackedObj() # some that is tracked
+        self.assertTrue('ATrackedObj' in str(compose(f()).next()))
+
+    def testDecorator(self):
+        from weightless.core import compose
+        @compose
+        def f():
+            yield "a"
+        self.assertEquals(["a"], list(f()))
+
+    def testEmptyArgsInStopIteration(self):
+        def f1():
+            si = StopIteration()
+            si.args = () # empty tuple
+            raise si
+            yield
+        def f2():
+            x = yield f1()
+            yield x
+        g = compose(f2())
+        self.assertEquals([None], list(g))
+
+    def testArgsIsNoIterable(self):
+        # because the Python VM checks this, we test the assumtion only
+        si = StopIteration()
+        try:
+            si.args = 9 # not a tuple. Actually checked by StopIteration itself!
+        except TypeError, e:
+            self.assertEquals("'int' object is not iterable", str(e))
+
+    def testArgsIsNoTuple(self):
+        # because the Python VM turns the args into a tuple, we only test this
+        si = StopIteration()
+        si.args = [2] # not a tuple. VM turns this into tuple
+        self.assertEquals((2,), si.args)
+
+    def testComposeType(self):
+        from weightless.core.compose import ComposeType
+        self.assertEquals(type, type(ComposeType))
+        self.assertEquals(ComposeType, type(compose((n for n in []))))
+
+    def testRaiseStopIterationWithRemainingMessages(self):
+        def f0():
+            raise StopIteration()
+            yield
+        def f1():
+            raise StopIteration(1)
+            yield
+        def f2():
+            raise StopIteration(2,3)
+            yield
+        def f3():
+            raise StopIteration(4,5,6)
+            yield
+        try: f0().next()
+        except StopIteration, e: self.assertEquals((), e.args)
+        try: f1().next()
+        except StopIteration, e: self.assertEquals((1,), e.args)
+        try: f2().next()
+        except StopIteration, e: self.assertEquals((2,3), e.args)
+        try: f3().next()
+        except StopIteration, e: self.assertEquals((4,5,6), e.args)
+
+    def testConcurrentFlow(self):
+        def f():
+            first_msg = yield
+            raise StopIteration(*first_msg.split())
+        def g():
+            first = yield f()
+            yield "response" # in between receiving msgs
+            msg = yield
+            second_msg = yield
+            yield second_msg
+        p = compose(g())
+        p.next()
+        p.send("first msg")
+        p.send(None)
+        x = p.send("second msg")
+        self.assertEquals('second msg', x)
+
+    def get_tracked_objects(self):
+        return [o for o in gc.get_objects() if type(o) in 
+                (compose, GeneratorType, Exception, StopIteration, ATrackedObj)]
+
+    def setUp(self):
+        gc.collect()
+        self._baseline = self.get_tracked_objects()
+
+    def tearDown(self):
+        def tostr(o):
+            try:
+                return tostring(o)
+            except:
+                return repr(o)
+        gc.collect()
+        for obj in self.get_tracked_objects():
+            self.assertTrue(obj in self._baseline, obj) #tostr(obj))
+        del self._baseline
+        gc.collect()
+
+class ComposePyTest(_ComposeTest):
+    def setUp(self):
+        global local, tostring, compose
+        local = pyLocal
+        tostring = pyTostring
+        compose = pyCompose
+        _ComposeTest.setUp(self)
+
+class ComposeCTest(_ComposeTest):
+    def setUp(self):
+        global local, tostring, compose
+        local = cLocal
+        tostring = cTostring
+        compose = cCompose
+        _ComposeTest.setUp(self)
+
+    def testQueueSize(self):
+        testrange = 9 #QUEUE SIZE = 10
+        def f():
+            raise StopIteration(*xrange(testrange))
+            yield 'f done'
+        def g():
+            results = []
+            x = yield f()
+            results.append(x)
+            for i in xrange(testrange-1):
+                results.append((yield))
+            yield results
+        c = compose(g())
+        self.assertEquals([range(testrange)], list(c))
+
+    def testQueueSizeExceeded(self):
+        testrange = 10 #QUEUE SIZE = 10
+        def f():
+            raise StopIteration(*xrange(testrange))
+            yield
+        def g():
+            x = yield f()
+        self.assertRaises(RuntimeError, compose(g()).next)
+
+    def testStackOverflow(self):
+        max_recursion_depth = getrecursionlimit()
+        def f(recursion_depth=1):
+            if recursion_depth < max_recursion_depth:
+                yield f(recursion_depth + 1)
+        c = compose(f())
+        try:
+            list(c)
+        except RuntimeError, e:
+            self.fail('must not raise %s' % e)
+
+        max_recursion_depth += 1 # <== 
+        c = compose(f())
+        try:
+            list(c)
+            self.fail('must raise runtimeerror')
+        except RuntimeError, e:
+            self.assertEquals('maximum recursion depth exceeded (compose)', str(e))
+
+    def testDECREF_in_compose_clear(self):
+        """A bit strange, but this triggers a bug with 
+        DECREF(<temporary>) in compose_clear()"""
+        def f():
+            msg = yield
+            raise StopIteration(*msg.split())
+
+        r = compose(f())
+        r.next()
+        try:
+            r.send("ab an")
+        except StopIteration, e:
+            self.assertEquals(('ab', 'an'), e.args)
+
+    def testSelftest(self):
+        from weightless.core.compose._compose_c import _selftest
+        _selftest()
+
+
+def gettypeerrormsg():
+    def compose(initial, arg1 = None): pass
+    try:
+        compose()
+    except TypeError, e:
+        return str(e)
+ 
diff --unidirectional-new-file '--exclude=*.so' '--exclude=*.o' '--exclude=.svn' '--exclude=*.pyc' '--exclude=deps.d' '--exclude=applied' --recursive --unified version_0/test/core/localtest.py version_0-merge-trunk/test/core/localtest.py
--- version_0/test/core/localtest.py	1970-01-01 01:00:00.000000000 +0100
+++ version_0-merge-trunk/test/core/localtest.py	2011-02-28 14:40:31.000000000 +0100
@@ -0,0 +1,107 @@
+## begin license ##
+#
+#    Weightless is a High Performance Asynchronous Networking Library
+#    See http://weightless.io
+#    Copyright (C) 2009-2011 Seek You Too (CQ2) http://www.cq2.nl
+#
+#    This file is part of Weightless
+#
+#    Weightless is free software; you can redistribute it and/or modify
+#    it under the terms of the GNU General Public License as published by
+#    the Free Software Foundation; either version 2 of the License, or
+#    (at your option) any later version.
+#
+#    Weightless is distributed in the hope that it will be useful,
+#    but WITHOUT ANY WARRANTY; without even the implied warranty of
+#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+#    GNU General Public License for more details.
+#
+#    You should have received a copy of the GNU General Public License
+#    along with Weightless; if not, write to the Free Software
+#    Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+#
+## end license ##
+
+from unittest import TestCase
+from weightless.core import local
+
+class LocalTest(TestCase):
+
+    def testScope(self):
+        _some_var_on_the_callstack_ = 'aap'
+        v = local('_some_var_on_the_callstack_')
+        self.assertEquals('aap', v)
+
+    def testNone(self):
+        var = None
+        self.assertEquals(None, local('var'))
+
+    def testNotFound(self):
+        try:
+            v = local('no_such_thing')
+            print "V", v
+            self.fail()
+        except AttributeError:
+            pass
+
+    def testVariousTypes(self):
+        strArgument = 'string'
+        self.assertEquals('string', local('strArgument'))
+        intArgument = 1
+        self.assertEquals(1, local('intArgument'))
+
+        class MyObject(object):
+            pass
+        objArgument = MyObject()
+        self.assertEquals(objArgument, local('objArgument'))
+
+    def testScoping(self):
+        class MyObject(object):
+            pass
+        refs = []
+        def function():
+            toplevel=MyObject()
+            refs.append(local('toplevel'))
+        function()
+        self.assertEquals(1, len(refs))
+        self.assertEquals(MyObject, type(refs[0]))
+
+    def testOne(self):
+        a=1
+        b=2
+        c=3
+        def f1():
+            d=4
+            a=10
+            b=6
+            self.assertEquals(4, local('d'))
+            self.assertEquals(10, local('a'))
+        f1()
+        self.assertEquals(2, local('b'))
+        self.assertEquals(1, local('a'))
+
+    def testWithGenerator(self):
+        results = []
+        _z_ = 9
+        def e():
+            yield
+            results.append(local('_x_'))
+            yield
+            results.append(local('_y_'))
+            yield
+            results.append(local('_z_'))
+        def f():
+            _x_ = 10
+            yield
+            _y_ = 11
+            list(e())
+        list(f())
+        self.assertEquals([10,11,9], results)
+
+    def testLookupSelfWhileBeingInitialized(self):
+        try:
+            tx = local('tx')
+            self.fail()
+        except AttributeError:
+            pass
+
diff --unidirectional-new-file '--exclude=*.so' '--exclude=*.o' '--exclude=.svn' '--exclude=*.pyc' '--exclude=deps.d' '--exclude=applied' --recursive --unified version_0/test/core/observabledirectedmessagingtest.py version_0-merge-trunk/test/core/observabledirectedmessagingtest.py
--- version_0/test/core/observabledirectedmessagingtest.py	1970-01-01 01:00:00.000000000 +0100
+++ version_0-merge-trunk/test/core/observabledirectedmessagingtest.py	2011-02-28 16:17:53.000000000 +0100
@@ -0,0 +1,98 @@
+from unittest import TestCase
+
+from weightless.core import Observable
+
+class ObservableDirectedMessagingTest(TestCase):
+
+    def testDirectedObserverMessagingDoesNotBreakUndirectedCall(self):
+        observable = Observable()
+        called = []
+        class A(Observable):
+            def method(this):
+                called.append("A")
+        observable.addObserver(A("name"))
+
+        list(observable.all["name"].method())
+        
+        self.assertEquals(["A"], called)
+
+    def testDirectedObserverMessagingIgnoresNonObservableObservers(self):
+        observable = Observable()
+        called = []
+        class Z(object):
+            def method(this):
+                called.append("Z")
+        observable.addObserver(Z())
+
+        list(observable.all["name"].method())
+        
+        self.assertEquals([], called)
+
+        list(observable.all.method())
+
+        self.assertEquals(["Z"], called)
+
+    def testDirectedMessagesCanAlsoBeAcceptedByObjects(self):
+        observable = Observable()
+        called = []
+        class Y(object):
+            def method(this):
+                called.append("Y")
+            def observable_name(this):
+                return 'name'
+        class Z(object):
+            def method(this):
+                called.append("Z")
+        observable.addObserver(Y())
+        observable.addObserver(Z())
+
+        list(observable.all["name"].method())
+        
+        self.assertEquals(['Y'], called)
+
+        del called[:]
+
+        list(observable.all.method())
+
+        self.assertEquals(['Y', "Z"], called)
+
+        del called[:]
+
+        list(observable.all["other"].method())
+
+        self.assertEquals([], called)
+
+
+    def testUndirectedObserverMessagingIsUnaffectedByObserverName(self):
+        observable = Observable()
+        called = []
+        class A(Observable):
+            def method(this):
+                called.append(("A", this.observable_name()))
+        
+        class B(Observable):
+            def method(this):
+                called.append(("B", this.observable_name()))
+
+        observable.addObserver(A("name"))
+        observable.addObserver(A().observable_setName("anothername"))
+        observable.addObserver(B("anothername"))
+        observable.addObserver(B())
+
+        list(observable.all.method())
+        
+        self.assertEquals([("A", "name"), 
+            ("A", "anothername"), 
+            ("B", "anothername"), 
+            ("B", None)], called)
+        del called[:]
+
+        list(observable.all["name"].method())
+        self.assertEquals([("A", "name")], called)
+
+    def testSetName(self):
+        observable = Observable().observable_setName('name')
+        self.assertEquals('name', observable.observable_name())
+
+
+    # observable_setName('name')
diff --unidirectional-new-file '--exclude=*.so' '--exclude=*.o' '--exclude=.svn' '--exclude=*.pyc' '--exclude=deps.d' '--exclude=applied' --recursive --unified version_0/test/core/observabletest.py version_0-merge-trunk/test/core/observabletest.py
--- version_0/test/core/observabletest.py	1970-01-01 01:00:00.000000000 +0100
+++ version_0-merge-trunk/test/core/observabletest.py	2011-06-18 11:17:26.000000000 +0200
@@ -0,0 +1,686 @@
+# -*- coding: utf-8 -*-
+## begin license ##
+#
+#    Meresco Core is an open-source library containing components to build
+#    searchengines, repositories and archives.
+#    Copyright (C) 2007-2011 Seek You Too (CQ2) http://www.cq2.nl
+#    Copyright (C) 2007-2009 SURF Foundation. http://www.surf.nl
+#    Copyright (C) 2007-2009 Stichting Kennisnet Ict op school.
+#       http://www.kennisnetictopschool.nl
+#    Copyright (C) 2007 SURFnet. http://www.surfnet.nl
+#    Copyright (C) 2010 Stichting Kennisnet http://www.kennisnet.nl
+#
+#    This file is part of Meresco Core.
+#
+#    Meresco Core is free software; you can redistribute it and/or modify
+#    it under the terms of the GNU General Public License as published by
+#    the Free Software Foundation; either version 2 of the License, or
+#    (at your option) any later version.
+#
+#    Meresco Core is distributed in the hope that it will be useful,
+#    but WITHOUT ANY WARRANTY; without even the implied warranty of
+#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+#    GNU General Public License for more details.
+#
+#    You should have received a copy of the GNU General Public License
+#    along with Meresco Core; if not, write to the Free Software
+#    Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+#
+## end license ##
+
+import gc
+from sys import exc_info
+from traceback import format_tb
+from inspect import isframe, getframeinfo
+from types import GeneratorType
+from weightless.core import compose, Observable, Transparant, be, tostring
+from weightless.core._observable import AllMessage, AnyMessage, DoMessage, OnceMessage, DeferredMessage, AsyncanyMessage, AsyncdoMessage
+from calltrace import CallTrace
+from unittest import TestCase
+
+class Interceptor(Observable):
+    def unknown(self, message, *args, **kwargs):
+        self.message = message
+        self.args = args
+        self.kwargs = kwargs
+
+class ObservableTest(TestCase):
+
+    def testTransparentUnknownWithAny(self):
+        class A(Observable):
+            def a(self):
+                return self.any.c()
+        class B1(Observable):
+            def unknown(self, message, *args, **kwargs):
+                return self.all.unknown(message, *args, **kwargs)
+        class B2(Observable):
+            def unknown(self, message, *args, **kwargs):
+                return self.all.unknown(message, *args, **kwargs)
+        class C(object):
+            def c(self):
+                return (ch for ch in 'see')
+        a = A()
+        b1 = B1()
+        b2 = B2()
+        c = C()
+        a.addObserver(b1)
+        b1.addObserver(b2)
+        b2.addObserver(c)
+        self.assertEquals('see', ''.join(a.a()))
+        del a, b1, b2, c
+
+    def testObserverInit(self):
+        initcalled = [0]
+        class MyObserver(object):
+            def observer_init(self):
+                initcalled[0] += 1
+        root = be((Observable(), (MyObserver(),)))
+        root.once.observer_init()
+        self.assertEquals([1], initcalled)
+
+    def testAllWithoutImplementers(self):
+        observable = Observable()
+        responses = observable.all.someMethodNobodyIsListeningTo()
+        self.assertEquals(GeneratorType, type(responses))
+
+    def testAllWithMoreImplementers(self):
+        observable = Observable()
+        observerOne = CallTrace(returnValues={'aMethod': 'one'})
+        observerTwo = CallTrace(returnValues={'aMethod': 'two'})
+        root = be((observable, (observerOne,), (observerTwo,)))
+        responses = root.all.aMethod()
+        self.assertEquals(GeneratorType, type(responses))
+        self.assertEquals(['one', 'two'], list(responses))
+
+    def testAnyCallsFirstImplementer(self):
+        observable = Observable()
+        observerA = ObserverA()
+        observerAB = ObserverAB()
+        root = be((observable, (observerA,), (observerAB,)))
+        resultA = root.any.methodA(0)
+        resultB = root.any.methodB(1, 2)
+        self.assertEquals([("Method A", (0,))], observerA.notifications)
+        self.assertEquals([("Method B", (1, 2))], observerAB.notifications)
+        self.assertEquals("A.methodA", resultA)
+        self.assertEquals("AB.methodB", resultB)
+
+    def testAnyCallsFirstImplementerNotReturningNone(self):
+        class A(object):
+            def do(self, x):
+                if x == 1: return 'A'
+        class B(object):
+            def do(self, x):
+                if x == 2: return 'B'
+        root = be((Observable(), (A(),), (B(),)))
+        result = root.any.do(1)
+        self.assertEquals('A', result)
+        result = root.any.do(2)
+        self.assertEquals('B', result)
+
+    def testAllException(self):
+        observable = Observable()
+        class ExceptionRaiser(MockObserver):
+            def mayRaiseException(self, *args):
+                raise TestException
+        class Safe(MockObserver):
+            def mayRaiseException(self, *args):
+                self.notifications.append(("mayRaiseException", args))
+        observable.addObserver(ExceptionRaiser())
+        safe = Safe()
+        observable.addObserver(safe)
+        try:
+            list(observable.all.mayRaiseException())
+            self.fail()
+        except TestException:
+            pass
+        self.assertEquals([], safe.notifications)
+
+    def testDo(self):
+        observable = Observable()
+        retvalIsAlwaysNone = observable.do.oneWayMethodWithoutReturnValue()
+        self.assertEquals(None, retvalIsAlwaysNone)
+        observer = CallTrace("Observer")
+        observer.something = lambda x,y: x.append(y)
+        observable.addObserver(observer)
+        value = []
+        observable.do.something(value, 1)
+        self.assertEquals([1], value)
+
+    def testAsyncdoReturnsGenerator(self):
+        observable = Observable()
+        retval = observable.asyncdo.oneWayMethodWithoutReturnValue()
+        self.assertRaises(StopIteration, retval.next)
+
+    def testAsyncdoEmptyGenerator(self):
+        observable = Observable()
+        called=[]
+        class Listener(object):
+            def message(this):
+                yield 'a'
+                called.append(True)
+                yield 'b'
+        observable.addObserver(Listener())
+        retval = observable.asyncdo.message()
+        self.assertRaises(StopIteration, retval.next)
+        self.assertEquals([True], called)
+
+    def testAsyncdoYieldsCallables(self):
+        observable = Observable()
+        called=[]
+        def callable():
+            pass
+        class Listener(object):
+            def message(this):
+                yield 'a'
+                yield callable
+                yield 'b'
+                called.append(True)
+        observable.addObserver(Listener())
+        retval = observable.asyncdo.message()
+        self.assertEquals(callable, retval.next())
+        self.assertRaises(StopIteration, retval.next)
+        self.assertEquals([True], called)
+
+    def testAsyncAnyNoSuchMessage(self):
+        observable = Observable()
+        try:
+            observable.asyncany.notExisting().next()
+            self.fail('fail')
+        except AttributeError, e:
+            self.assertEquals('None of the 0 observers responds to asyncany.notExisting(...)', str(e))
+
+    def testAsyncAny2(self):
+        observable = Observable()
+        done = []
+        def callable():
+            pass
+        class Caller(Observable):
+            def useasyncany(this):
+                result = yield this.asyncany.message()
+                self.assertEquals("the answer", result)
+                yield
+        class Listener(object):
+            def message(this):
+                yield callable
+                done.append(0)
+                raise StopIteration("the answer")
+        caller = Caller()
+        caller.addObserver(Listener())
+        observable.addObserver(caller)
+        generator = compose(observable.all.useasyncany())
+        self.assertEquals(callable, generator.next())
+        retval = generator.next()
+        self.assertEquals([0], done)
+ 
+    def testAddStrandEmptyList(self):
+        observable = Observable()
+        observable.addStrand((), [])
+        self.assertEquals([], observable._observers)
+
+    def testBeOne(self):
+        observer = CallTrace()
+        root = be((observer,))
+        self.assertEquals(root, observer)
+
+    def testBeTwo(self):
+        observable = Observable()
+        child0 = Observable()
+        child1 = Observable()
+        root = be((observable, (child0,), (child1,)))
+        self.assertEquals([child0, child1], observable._observers)
+
+    def testBeTree(self):
+        observable = Observable()
+        child0 = Observable(name='child0')
+        child1 = Observable(name='child1')
+        strand = (observable, (child0, (child1,)))
+        root = be(strand)
+        self.assertEquals([child0], root._observers)
+        self.assertEquals([child1], child0._observers)
+
+    def testBeToExplainTheIdeaWhithoutTestingSomethingNew(self):
+        observable = Observable()
+        child0 = Observable(name='child0')
+        child1 = Observable(name='child1')
+        child2 = Observable(name='child2')
+        tree = (observable, (child0, (child1, (child2,))))
+        root = be(tree)
+        self.assertEquals([child0], observable._observers)
+        self.assertEquals([child1], child0._observers)
+        self.assertEquals([child2], child1._observers)
+
+    def testAny(self):
+        class A(Observable):
+            def myThing(self):
+                return self.any.myThing()
+        class B(Observable):
+            def myThing(self):
+                yield "data"
+        a = A()
+        b = B()
+        a.addObserver(b)
+        self.assertEquals(GeneratorType, type(a.any.myThing()))
+        self.assertEquals(["data"], list(a.any.myThing()))
+
+    def testAllUnknown(self):
+        class Interceptor(Observable):
+            def unknown(self, message, *args, **kwargs):
+                self.message = message
+                self.args = args
+                self.kwargs = kwargs
+        interceptor = Interceptor()
+        root = Observable()
+        root.addObserver(interceptor)
+        list(root.all.anUnknownMessage('with', unknown='arguments'))
+
+        self.assertEquals('anUnknownMessage', interceptor.message)
+        self.assertEquals(('with',), interceptor.args)
+        self.assertEquals({'unknown': 'arguments'}, interceptor.kwargs)
+
+    def testUnknownDispatchingNoImplementation(self):
+        observable = Observable()
+        class Listener(object):
+            pass
+        observable.addObserver(Listener())
+        retval = observable.all.unknown('non_existing_method', 'one')
+        self.assertEquals([], list(retval))
+
+    def testUnknownDispatching(self):
+        observable = Observable()
+        class Listener(object):
+            def method(inner, one):
+                return one + " another"
+        observable.addObserver(Listener())
+        retval = observable.any.unknown('method', 'one')
+        self.assertEquals('one another', retval)
+
+    def testUnknownDispatchingBackToUnknown(self):
+        observable = Observable()
+        class Listener(object):
+            def unknown(self, methodName, one):
+                return ("via unknown " + one for x in [1])
+        observable.addObserver(Listener())
+        retval = observable.any.unknown('non_existing_method', 'one')
+        self.assertEquals("via unknown one", retval)
+
+    def testUnknownIsEquivalentToNormalCall(self):
+        observable = Observable()
+        class Listener(object):
+            def normal(self):
+                return 'normal'
+            def unknown(self, message, *args, **kwargs):
+                yield self.normal()
+        observable.addObserver(Listener())
+        result1 = observable.any.unknown('normal')
+        result2 = observable.any.unknown('other')
+        self.assertEquals(result1, result2)
+
+    def testSyntacticSugarIsPreserved(self):
+        class WithUnknown(Observable):
+            def unknown(self, methodName, *args):
+                return self.all.unknown(methodName, "extra arg", *args)
+
+        observer = CallTrace("Observer")
+
+        withUnknown = WithUnknown()
+        withUnknown.addObserver(observer)
+
+        source = Observable()
+        source.addObserver(withUnknown)
+        source.do.someMethod("original arg")
+        #if syntactic sugar (i.e. "do") is preseverd, it would force the call self.all.unknown directly
+        self.assertEquals(1, len(observer.calledMethods))
+        self.assertEquals("someMethod('extra arg', 'original arg')", str(observer.calledMethods[0]))
+
+    def testProperErrorMessage(self):
+        observable = Observable()
+        try:
+            answer = observable.any.gimmeAnswer('please')
+            self.fail('shoud raise AttributeError')
+        except AttributeError, e:
+            self.assertEquals('None of the 0 observers responds to any.gimmeAnswer(...)', str(e))
+
+    def testProperErrorMessageWhenArgsDoNotMatch(self):
+        from traceback import print_exc
+        observable = Observable()
+        class YesObserver:
+            def yes(self, oneArg): pass
+        observable.addObserver(YesObserver())
+        try:
+            answer = observable.any.yes()
+            self.fail('shoud raise AttributeError')
+        except TypeError, e:
+            self.assertEquals('yes() takes exactly 2 arguments (1 given)', str(e))
+
+    def testNestedAllWithDoOnlyExecutesTheHighestLevelCalls(self):
+        done = []
+        class A(Observable):
+            def a(this):
+                done.append('A')
+                return this.all.a()
+        class B(Observable):
+            def a(this):
+                done.append('B')
+                return this.all.a()
+        class C(Observable):
+            def a(this):
+                done.append('C')
+                self.done = True
+        t = be((Observable(),
+                    (A(),
+                        (B(),
+                            (C(),)
+                        )
+                    )
+                ))
+        result = t.do.a()
+        self.assertEquals(None, result)
+        self.assertEquals(['A'], done)
+
+    def testFixUpExceptionTraceBack(self):
+        class A:
+            def a(self):
+                raise Exception('A.a')
+            def unknown(self, msg, *args, **kwargs):
+                yield self.a()
+        observable = Observable()
+        observable.addObserver(A())
+        try:
+            observable.any.a()
+        except Exception:
+            self.assertFunctionsOnTraceback("testFixUpExceptionTraceBack", "a")
+        try:
+            list(observable.all.a())
+        except Exception:
+            self.assertFunctionsOnTraceback("testFixUpExceptionTraceBack", "a")
+
+        try:
+            observable.do.a()
+        except Exception:
+            self.assertFunctionsOnTraceback("testFixUpExceptionTraceBack", "a")
+
+        try:
+            list(observable.asyncdo.a())
+        except Exception:
+            self.assertFunctionsOnTraceback("testFixUpExceptionTraceBack", "a")
+
+        try:
+            observable.any.unknown('a')
+        except Exception:
+            self.assertFunctionsOnTraceback("testFixUpExceptionTraceBack", "a")
+
+        try:
+            observable.any.somethingNotThereButHandledByUnknown('a')
+        except Exception:
+            self.assertFunctionsOnTraceback("testFixUpExceptionTraceBack", "unknown", "a")
+
+    def assertFunctionsOnTraceback(self, *args):
+        na, na, tb = exc_info()
+        for functionName in args:
+            self.assertEquals(functionName, tb.tb_frame.f_code.co_name)
+            tb = tb.tb_next
+        self.assertEquals(None, tb)
+
+    def testMoreElaborateExceptionCleaning(self):
+        class A(Observable):
+            def a(self): return self.any.b()
+        class B(Observable):
+            def b(self): return self.any.c()
+        class C(Observable):
+            def c(self): return self.any.d()
+        class D:
+            def d(self): raise Exception('D.d')
+        a = A()
+        b = B()
+        c = C()
+        a.addObserver(b)
+        b.addObserver(c)
+        c.addObserver(D())
+        try:
+            a.a()
+            self.fail('should raise exception')
+        except:
+            self.assertFunctionsOnTraceback("testMoreElaborateExceptionCleaning", "a", "b", "c", "d")
+
+    def testAddObserversOnce(self):
+        class  MyObservable(Observable):
+            pass
+        o1 = MyObservable(name='O1')
+        o2 = MyObservable(name='O2')
+        o3 = MyObservable(name='O3')
+        o4 = MyObservable(name='O4')
+        o5 = MyObservable(name='O5')
+        helix = \
+            (o1,
+                (o2, )
+            )
+        dna =   (o3,
+                    helix,
+                    (o4,),
+                    (o5, helix)
+                 )
+        root = be(dna)
+        self.assertEquals([o2], o1._observers)
+        self.assertEquals([], o2._observers)
+        self.assertEquals([o1, o4, o5], o3._observers)
+        self.assertEquals([], o4._observers)
+        self.assertEquals([o1], o5._observers)
+
+    def testResolveCallStackVariables(self):
+        class StackVarHolder(Observable):
+            def unknown(self, name, *args, **kwargs):
+                __callstack_var_myvar__ = []
+                for result in self.all.unknown(name, *args, **kwargs):
+                    pass
+                yield __callstack_var_myvar__
+
+        class StackVarUser(Observable):
+            def useVariable(self):
+                self.ctx.myvar.append('Thingy')
+
+        dna = \
+            (Observable(),
+                (StackVarHolder(),
+                    (StackVarUser(),)
+                )
+            )
+        root = be(dna)
+        self.assertEquals(['Thingy'], root.any.useVariable())
+
+    def testOnceAndOnlyOnce(self):
+        class MyObserver(Observable):
+            def methodOnlyCalledOnce(self, aList):
+                aList.append('once')
+        once = MyObserver()
+        dna = \
+            (Observable(),
+                (once,),
+                (once,)
+            )
+        root = be(dna)
+        collector = []
+        root.once.methodOnlyCalledOnce(collector)
+        self.assertEquals(['once'], collector)
+
+    def testOnceInDiamondWithTransparant(self):
+        class MyObserver(Observable):
+            def methodOnlyCalledOnce(self, aList):
+                aList.append('once')
+        once = MyObserver()
+        diamond = \
+            (Transparant(),
+                (Transparant(),
+                    (once,)
+                ),
+                (Transparant(),
+                    (once,)
+                )
+            )
+        root = be(diamond)
+        collector = []
+        root.once.methodOnlyCalledOnce(collector)
+        self.assertEquals(['once'], collector)
+
+    def testPropagateThroughAllObservablesInDiamondWithNONTransparantObservablesWithoutUnknownMethodDelegatingUnknownCalls(self):
+        class MyObserver(Observable):
+            def methodOnlyCalledOnce(self, aList):
+                aList.append('once')
+        once = MyObserver()
+        diamond = \
+            (Observable(),
+                (Observable(),
+                    (once,)
+                ),
+                (Observable(),
+                    (once,)
+                )
+            )
+        root = be(diamond)
+        collector = []
+        root.once.methodOnlyCalledOnce(collector)
+        self.assertEquals(['once'], collector)
+
+    def testNonObservableInTreeWithOnce(self):
+        class MyObserver(object):
+            def methodOnNonObservableSubclass(self, aList):
+                aList.append('once')
+        once = MyObserver()
+        dna =   (Observable(),
+                    (once,)
+                )
+        root = be(dna)
+        collector = []
+        root.once.methodOnNonObservableSubclass(collector)
+        self.assertEquals(['once'], collector)
+
+    def testOnceAndOnlyOnceForMutuallyObservingObservables(self):
+        class MyObserver(Observable):
+            def methodOnlyCalledOnce(self, aList):
+                aList.append(self)
+        ownobserverobserver = MyObserver()
+        dna = \
+            (Observable(),
+                (ownobserverobserver,
+                    (Observable("observer"),
+                        (ownobserverobserver,),
+                    )
+                )
+            )
+        root = be(dna)
+        collector = []
+        root.once.methodOnlyCalledOnce(collector)
+        self.assertEquals([ownobserverobserver], collector)
+
+    def testNoLeakingGeneratorsInCycle(self):
+
+        class Responder(Observable):
+            def message(self):
+                return 'response'
+        obs = Observable()
+        obs.addObserver(Responder())
+        result = obs.all.message().next()
+        self.assertEquals('response',result)
+        del obs
+
+    def testNoLeakingGeneratorsInMultiTransparants(self):
+        class Responder(Observable):
+            def message(self):
+                return 'response'
+        obs = Observable()
+        t1 = Transparant()
+        t2 = Transparant()
+        obs.addObserver(t1)
+        t1.addObserver(t2)
+        t2.addObserver(Responder())
+        result = obs.any.message()
+        self.assertEquals('response', result)
+        del obs, t1, t2, result
+
+    def testMatchingBasedOnDefaultArgs(self):
+        class A(object):
+            def a(x, y=10, z=11):
+                p = 1
+                q = 2
+                yield
+        a = A()
+        func = a.a
+        code = func.func_code
+        func_defaults = func.func_defaults
+        self.assertEquals((10,11), func_defaults)
+        argcount = code.co_argcount
+        self.assertEquals(3, argcount)
+        varnames = code.co_varnames
+        self.assertEquals(('x', 'y', 'z', 'p', 'q'), varnames)
+        argnames = varnames[:argcount]
+        self.assertEquals(('x','y','z'), argnames)
+        kwargsnames = argnames[-len(func_defaults):]
+        self.assertEquals(('y','z'), kwargsnames)
+        kwargdefaults = dict(zip(kwargsnames, func_defaults))
+        self.assertEquals({'y':10, 'z':11}, kwargdefaults)
+        self.assertEquals({'z':11, 'y':10}, kwargdefaults)
+        func.__dict__['kwargdefaults'] = kwargdefaults
+        self.assertEquals({'z':11, 'y':10}, func.kwargdefaults)
+
+        class Wildcard(object):
+            def __eq__(self, other):
+                return True
+        self.assertTrue({'z':11, 'y':10} == {'z':11, 'y': Wildcard()})
+
+    def get_tracked_objects(self):
+        return [o for o in gc.get_objects() if type(o) in 
+                (compose, GeneratorType, Exception,
+                    AllMessage, AnyMessage, DoMessage, OnceMessage, DeferredMessage,
+                    AsyncdoMessage, AsyncanyMessage)]
+ 
+    def setUp(self):
+        gc.collect()
+        self._baseline = self.get_tracked_objects()
+
+    def tearDown(self):
+        def tostr(o):
+            if isframe(o):
+                return getframeinfo(o)
+            try:
+                return tostring(o)
+            except:
+                return repr(o)
+        gc.collect()
+        diff = set(self.get_tracked_objects()) - set(self._baseline)
+        #self.assertEquals(set(), diff)
+        #for obj in diff:
+        #    print "Leak:"
+        #    print tostr(obj)
+        #    print "Referrers:"
+        #    for o in  gc.get_referrers(obj):
+        #        print tostr(o)
+        del self._baseline
+
+
+class TestException(Exception):
+    pass
+
+class MockObserver:
+
+    def __init__(self):
+        self.notifications = []
+
+class ObserverA(MockObserver):
+
+    def methodA(self, *args):
+        self.notifications.append(("Method A", args))
+        return "A.methodA"
+
+class ObserverAB(MockObserver):
+
+    def methodA(self, *args):
+        self.notifications.append(("Method A", args))
+        return "AB.methodA"
+
+    def methodB(self, *args):
+        self.notifications.append(("Method B", args))
+        return "AB.methodB"
+
+class DoesNotReturn(MockObserver):
+
+    def methodA(self, *args):
+        self.notifications.append(("Method A", args))
diff --unidirectional-new-file '--exclude=*.so' '--exclude=*.o' '--exclude=.svn' '--exclude=*.pyc' '--exclude=deps.d' '--exclude=applied' --recursive --unified version_0/test/core/sidekicktest.py version_0-merge-trunk/test/core/sidekicktest.py
--- version_0/test/core/sidekicktest.py	1970-01-01 01:00:00.000000000 +0100
+++ version_0-merge-trunk/test/core/sidekicktest.py	2011-02-28 14:40:31.000000000 +0100
@@ -0,0 +1,104 @@
+## begin license ##
+#
+#    Weightless is a High Performance Asynchronous Networking Library
+#    See http://weightless.io
+#    Copyright (C) 2010-2011 Seek You Too (CQ2) http://www.cq2.nl
+#
+#    This file is part of Weightless
+#
+#    Weightless is free software; you can redistribute it and/or modify
+#    it under the terms of the GNU General Public License as published by
+#    the Free Software Foundation; either version 2 of the License, or
+#    (at your option) any later version.
+#
+#    Weightless is distributed in the hope that it will be useful,
+#    but WITHOUT ANY WARRANTY; without even the implied warranty of
+#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+#    GNU General Public License for more details.
+#
+#    You should have received a copy of the GNU General Public License
+#    along with Weightless; if not, write to the Free Software
+#    Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+#
+## end license ##
+from unittest import TestCase
+from weightless.core import compose
+from sys import exc_info
+
+class SidekickTest(TestCase):
+
+    def testCallCallableWithSidekick(self):
+        called = []
+        def command(sidekick):
+            called.append(sidekick)
+        def f():
+            yield 'a'
+            yield command
+            yield 'b'
+
+        c = compose(f(), sidekick="sidekick")
+        result = list(c)
+        self.assertEquals(['a', 'b'], result)
+        self.assertEquals(["sidekick"], called)
+
+
+    def testCallableIsTransparent(self):
+        data = []
+        called = []
+        def command(sidekick):
+            called.append(sidekick)
+        def f():
+            a = yield None
+            data.append(a)
+            yield command
+            b = yield None
+            data.append(b)
+            yield
+
+        c = compose(f(), sidekick="sidekick")
+        none = c.send(None)
+        self.assertEquals(None, none)
+        none = c.send('a')
+        self.assertEquals(None, none)
+        none = c.send('b')
+        self.assertEquals(None, none)
+        self.assertEquals(['a', 'b'], data)
+        self.assertEquals(['sidekick'], called)
+
+    def testCallableRaisesException(self):
+        def command(sidekick):
+            raise RuntimeError("runtimeError")
+        def f():
+            yield command
+        c = compose(f(), sidekick="sidekick")
+        try:
+            c.next()
+            self.fail()
+        except RuntimeError, e:
+            self.assertEquals("runtimeError", str(e))
+
+    def testCallableRaisesExceptionWhichIsCatchableByGenerators(self):
+        def command(sidekick):
+            raise RuntimeError("runtimeError")
+        def f():
+            try:
+                yield command
+            except RuntimeError, e:
+                yield str(e)
+        c = compose(f(), sidekick="sidekick")
+        self.assertEquals("runtimeError", c.next())
+
+    def testProperTracebackForCallable(self):
+        def command(sidekick):
+            raise RuntimeError("runtimeError")
+        def f():
+            yield command
+        c = compose(f(), sidekick="sidekick")
+        try:
+            c.next()
+            self.fail()
+        except RuntimeError, e:
+            exType, exValue, exTraceback = exc_info()
+            self.assertEquals('testProperTracebackForCallable', exTraceback.tb_frame.f_code.co_name)
+            self.assertEquals('f', exTraceback.tb_next.tb_frame.f_code.co_name)
+            self.assertEquals('command', exTraceback.tb_next.tb_next.tb_frame.f_code.co_name)
diff --unidirectional-new-file '--exclude=*.so' '--exclude=*.o' '--exclude=.svn' '--exclude=*.pyc' '--exclude=deps.d' '--exclude=applied' --recursive --unified version_0/test/http/asyncreadertest.py version_0-merge-trunk/test/http/asyncreadertest.py
--- version_0/test/http/asyncreadertest.py	2011-06-21 09:47:06.000000000 +0200
+++ version_0-merge-trunk/test/http/asyncreadertest.py	2011-06-22 15:01:54.000000000 +0200
@@ -22,7 +22,6 @@
 #
 ## end license ##
 
-from basetestcase import BaseTestCase
 from re import sub
 from sys import exc_info
 import sys
@@ -30,9 +29,10 @@
 from traceback import format_exception
 from socket import socket, gaierror as SocketGaiError
 from random import randint
+from weightlesstestcase import WeightlessTestCase
 from httpreadertest import server as testserver
-from weightless.http import HttpServer, httpget, Suspend
-from weightless.io import Reactor
+from weightless.http import HttpServer, httpget
+from weightless.io import Reactor, Suspend
 from weightless.core import compose
 
 from weightless.http._httpget import _httpRequest
@@ -50,18 +50,23 @@
     'httpget.py': httpget.func_code.co_filename,
 }
  
-class AsyncReaderTest(BaseTestCase):
+class AsyncReaderTest(WeightlessTestCase):
 
     def dispatch(self, *args, **kwargs):
         return compose(self.handler(*args, **kwargs))
 
     def setUp(self):
-        BaseTestCase.setUp(self)
+        WeightlessTestCase.setUp(self)
         self.reactor = Reactor()
         self.port = randint(2**10, 2**16)
         self.httpserver = HttpServer(self.reactor, self.port, self.dispatch)
         self.httpserver.listen()
-    
+
+    def tearDown(self):
+        self.httpserver.shutdown()
+        self.reactor.shutdown()
+        WeightlessTestCase.tearDown(self)
+
     def testHttpRequest(self):
         self.assertEquals('GET / HTTP/1.0\r\n', _httpRequest('/'))
         self.assertEquals('GET / HTTP/1.1\r\nHost: weightless.io\r\n', _httpRequest('/', vhost="weightless.io"))
diff --unidirectional-new-file '--exclude=*.so' '--exclude=*.o' '--exclude=.svn' '--exclude=*.pyc' '--exclude=deps.d' '--exclude=applied' --recursive --unified version_0/test/http/httpreadertest.py version_0-merge-trunk/test/http/httpreadertest.py
--- version_0/test/http/httpreadertest.py	2011-06-21 09:47:06.000000000 +0200
+++ version_0-merge-trunk/test/http/httpreadertest.py	2011-06-22 15:02:06.000000000 +0200
@@ -35,7 +35,7 @@
 import sys
 from StringIO import StringIO
 from calltrace import CallTrace
-from basetestcase import MATCHALL
+from weightlesstestcase import MATCHALL
 
 def server(port, response, expectedrequest, delay=0, loop=50):
     isListening = Event()
@@ -82,7 +82,8 @@
 
     def testRequestAndHeaders(self):
         port = randint(2**10, 2**16)
-        expectedrequest = "GET /aap/noot/mies HTTP/1.1\r\nHost: localhost\r\nUser-Agent: Weightless/v0.4.x\r\n\r\n"
+        v = 'v0.5.x'
+        expectedrequest = "GET /aap/noot/mies HTTP/1.1\r\nHost: localhost\r\nUser-Agent: Weightless/%s\r\n\r\n" % v
         dataReceived = []
         serverThread = server(port, "HTTP/1.1 200 OK\r\ncOnteNt-type: text/html\r\n\r\nHello World!", expectedrequest)
         class Generator(object):
@@ -120,7 +121,7 @@
     def testEmptyPath(self):
         port = randint(2**10, 2**16)
         reactor = Reactor()
-        request = "GET / HTTP/1.1\r\nHost: localhost\r\nUser-Agent: Weightless/v0.4.x\r\n\r\n"
+        request = "GET / HTTP/1.1\r\nHost: localhost\r\nUser-Agent: Weightless/v%s\r\n\r\n" % WlVersion
         serverThread = server(port, "HTTP/1.1 200 OK\r\n\r\n", request)
         reader = HttpReaderFacade(reactor, "http://localhost:%s" % port, lambda data: 'a')
         reactor.step()
@@ -131,7 +132,7 @@
     def testTimeoutOnInvalidRequest(self):
         port = randint(2**10, 2**16)
         reactor = Reactor()
-        expectedrequest = "GET / HTTP/1.1\r\nHost: localhost\r\nUser-Agent: Weightless/v0.4.x\r\n\r\n"
+        expectedrequest = "GET / HTTP/1.1\r\nHost: localhost\r\nUser-Agent: Weightless/v%s\r\n\r\n" % WlVersion
         serverThread = server(port, "HTTP/1.1 *invalid reponse* 200 OK\r\n\r\n", expectedrequest)
         errorArgs = []
         def error(exception):
@@ -145,7 +146,7 @@
     def testTimeoutOnSilentServer(self):
         port = randint(2**10, 2**16)
         reactor = Reactor()
-        expectedrequest = "GET / HTTP/1.1\r\nHost: localhost\r\nUser-Agent: Weightless/v0.4.x\r\n\r\n"
+        expectedrequest = "GET / HTTP/1.1\r\nHost: localhost\r\nUser-Agent: Weightless/v%s\r\n\r\n" % WlVersion
         serverThread = server(port, "", expectedrequest)
         errorArgs = []
         class Handler:
@@ -163,7 +164,7 @@
     def testTimeoutOnServerGoingSilentAfterHeaders(self):
         port = randint(2**10, 2**16)
         reactor = Reactor()
-        expectedrequest = "GET / HTTP/1.1\r\nHost: localhost\r\nUser-Agent: Weightless/v0.4.x\r\n\r\n"
+        expectedrequest = "GET / HTTP/1.1\r\nHost: localhost\r\nUser-Agent: Weightless/v%s\r\n\r\n" % WlVersion
         serverThread = server(port, "HTTP/1.1 200 OK\r\n\r\n", expectedrequest, delay=1)
         errorArgs = []
         class Handler:
@@ -183,7 +184,7 @@
     def testClearTimer(self):
         port = randint(2**10, 2**16)
         reactor = Reactor()
-        expectedrequest = "GET / HTTP/1.1\r\nHost: localhost\r\nUser-Agent: Weightless/v0.4.x\r\n\r\n"
+        expectedrequest = "GET / HTTP/1.1\r\nHost: localhost\r\nUser-Agent: Weightless/v%s\r\n\r\n" % WlVersion
         serverThread = server(port, "HTTP/1.1 200 OK\r\n\r\nresponse", expectedrequest)
         self.exception = None
         sentData = []
@@ -201,7 +202,7 @@
     def testPost(self):
         port = randint(2048, 4096)
         reactor = Reactor()
-        request = "POST / HTTP/1.1\r\nHost: localhost\r\nTransfer-Encoding: chunked\r\nSOAPAction: blah\r\nUser-Agent: Weightless/v0.4.x\r\n\r\n1\r\nA\r\n1\r\nB\r\n1\r\nC\r\n0\r\n\r\n"
+        request = "POST / HTTP/1.1\r\nHost: localhost\r\nTransfer-Encoding: chunked\r\nSOAPAction: blah\r\nUser-Agent: Weightless/v%s\r\n\r\n1\r\nA\r\n1\r\nB\r\n1\r\nC\r\n0\r\n\r\n" % WlVersion
         serverThread = server(port, "HTTP/1.1 200 OK\r\n\r\nresponse", request, loop=9)
         sentData = []
         done = []
@@ -237,7 +238,7 @@
         reactor = Reactor()
         sentData = []
         done = []
-        expectedrequest = "GET / HTTP/1.1\r\nHost: localhost\r\nUser-Agent: Weightless/v0.4.x\r\n\r\n"
+        expectedrequest = "GET / HTTP/1.1\r\nHost: localhost\r\nUser-Agent: Weightless/v%s\r\n\r\n" % WlVersion
         serverThread = server(port, "\r\n".join("""HTTP/1.1 302 Found
 Date: Fri, 26 Oct 2007 07:23:26 GMT
 Server: Apache/2.2.3 (Debian) mod_python/3.2.10 Python/2.4.4 mod_ssl/2.2.3 OpenSSL/0.9.8c
diff --unidirectional-new-file '--exclude=*.so' '--exclude=*.o' '--exclude=.svn' '--exclude=*.pyc' '--exclude=deps.d' '--exclude=applied' --recursive --unified version_0/test/http/httpservertest.py version_0-merge-trunk/test/http/httpservertest.py
--- version_0/test/http/httpservertest.py	2011-06-21 09:47:06.000000000 +0200
+++ version_0-merge-trunk/test/http/httpservertest.py	2011-06-21 10:13:35.000000000 +0200
@@ -22,14 +22,15 @@
 #    Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
 #
 ## end license ##
-from unittest import TestCase
+from __future__ import with_statement
+
+from weightlesstestcase import WeightlessTestCase, MATCHALL
 from random import randint
 from socket import socket, error as SocketError
 from select import select
 from weightless.io import Reactor
 from time import sleep
 from calltrace import CallTrace
-from basetestcase import MATCHALL
 from os.path import join, abspath, dirname
 from StringIO import StringIO
 from sys import getdefaultencoding
@@ -39,29 +40,25 @@
 def inmydir(p):
     return join(dirname(abspath(__file__)), p)
 
-class HttpServerTest(TestCase):
-
-    def setUp(self):
-        self.reactor = Reactor()
-        self._portNumber = randint(2048, 62000)
-
-    def tearDown(self):
-        self.reactor.shutdown()
-        self.reactor = None
+class HttpServerTest(WeightlessTestCase):
 
     def sendRequestAndReceiveResponse(self, request, recvSize=4096):
         self.responseCalled = False
         def response(**kwargs):
             yield 'The Response'
             self.responseCalled = True
-        server = HttpServer(self.reactor, self._portNumber, response, recvSize=recvSize)
+        server = HttpServer(self.reactor, self.port, response, recvSize=recvSize)
         server.listen()
         sok = socket()
-        sok.connect(('localhost', self._portNumber))
+        sok.connect(('localhost', self.port))
         sok.send(request)
-        while not self.responseCalled:
-            self.reactor.step()
-        return sok.recv(4096)
+        with self.stdout_replaced():
+            while not self.responseCalled:
+                self.reactor.step()
+        server.shutdown()
+        r = sok.recv(4096)
+        sok.close()
+        return r
 
     def testConnect(self):
         self.req = False
@@ -69,10 +66,10 @@
             self.req = True
             yield 'nosens'
         reactor = Reactor()
-        server = HttpServer(reactor, self._portNumber, onRequest)
+        server = HttpServer(reactor, self.port, onRequest)
         server.listen()
         sok = socket()
-        sok.connect(('localhost', self._portNumber))
+        sok.connect(('localhost', self.port))
         sok.send('GET / HTTP/1.0\r\n\r\n')
         reactor.step() # connect/accept
         reactor.step() # read GET request
@@ -85,10 +82,10 @@
             self.kwargs = kwargs
             yield 'nosense'
         reactor = Reactor()
-        server = HttpServer(reactor, self._portNumber, response)
+        server = HttpServer(reactor, self.port, response)
         server.listen()
         sok = socket()
-        sok.connect(('localhost', self._portNumber))
+        sok.connect(('localhost', self.port))
         sok.send('GET /path/here HTTP/1.0\r\nConnection: close\r\nApe-Nut: Mies\r\n\r\n')
         while not self.kwargs:
             reactor.step()
@@ -101,7 +98,7 @@
     def testCloseConnection(self):
         response = self.sendRequestAndReceiveResponse('GET /path/here HTTP/1.0\r\nConnection: close\r\nApe-Nut: Mies\r\n\r\n')
         self.assertEquals('The Response', response)
-        self.assertEquals(1, len(self.reactor._readers)) # only acceptor left
+        self.assertEquals({}, self.reactor._readers)
         self.assertEquals({}, self.reactor._writers)
 
     def testSmallFragments(self):
@@ -113,10 +110,10 @@
             yield 'some text that is longer than '
             yield 'the lenght of fragments sent'
         reactor = Reactor()
-        server = HttpServer(reactor, self._portNumber, response, recvSize=3)
+        server = HttpServer(reactor, self.port, response, recvSize=3)
         server.listen()
         sok = socket()
-        sok.connect(('localhost', self._portNumber))
+        sok.connect(('localhost', self.port))
         sok.send('GET /path/here HTTP/1.0\r\nConnection: close\r\nApe-Nut: Mies\r\n\r\n')
         while not reactor._writers:
             reactor.step()
@@ -138,10 +135,10 @@
         def response(**kwargs):
             yield unicodeString * 6000
         reactor = Reactor()
-        server = HttpServer(reactor, self._portNumber, response, recvSize=3)
+        server = HttpServer(reactor, self.port, response, recvSize=3)
         server.listen()
         sok = socket()
-        sok.connect(('localhost', self._portNumber))
+        sok.connect(('localhost', self.port))
         sok.send('GET /path/here HTTP/1.0\r\nConnection: close\r\nApe-Nut: Mies\r\n\r\n')
         while not reactor._writers:
             reactor.step()
@@ -161,10 +158,10 @@
             timers.append(timer)
             return orgAddTimer(*timer)
         reactor.addTimer = addTimerInterceptor
-        server = HttpServer(reactor, self._portNumber, None, timeout=0.01)
+        server = HttpServer(reactor, self.port, None, timeout=0.01)
         server.listen()
         sok = socket()
-        sok.connect(('localhost', self._portNumber))
+        sok.connect(('localhost', self.port))
         sok.send('GET HTTP/1.0\r\n\r\n') # no path
         while select([sok],[], [], 0) != ([sok], [], []):
             reactor.step()
@@ -174,10 +171,10 @@
 
     def testValidRequestResetsTimer(self):
         reactor = Reactor()
-        server = HttpServer(reactor, self._portNumber, lambda **kwargs: ('a' for a in range(3)), timeout=0.01, recvSize=3)
+        server = HttpServer(reactor, self.port, lambda **kwargs: ('a' for a in range(3)), timeout=0.01, recvSize=3)
         server.listen()
         sok = socket()
-        sok.connect(('localhost', self._portNumber))
+        sok.connect(('localhost', self.port))
         sok.send('GET / HTTP/1.0\r\n\r\n')
         sleep(0.02)
         for i in range(11):
@@ -191,10 +188,10 @@
             self.requestData = kwargs
 
         reactor = Reactor()
-        server = HttpServer(reactor, self._portNumber, handler, timeout=0.01)
+        server = HttpServer(reactor, self.port, handler, timeout=0.01)
         server.listen()
         sok = socket()
-        sok.connect(('localhost', self._portNumber))
+        sok.connect(('localhost', self.port))
         sok.send('POST / HTTP/1.0\r\nContent-Type: application/x-www-form-urlencoded\r\nContent-Length: 8\r\n\r\nbodydata')
 
         while not self.requestData:
@@ -221,11 +218,11 @@
             done.append(True)
 
         reactor = Reactor()
-        server = HttpServer(reactor, self._portNumber, handler, timeout=0.01)
+        server = HttpServer(reactor, self.port, handler, timeout=0.01)
         server.listen()
         reactor.addTimer(0.02, onDone)
         sok = socket()
-        sok.connect(('localhost', self._portNumber))
+        sok.connect(('localhost', self.port))
         sok.send('POST / HTTP/1.0\r\nContent-Type: application/x-www-form-urlencoded\r\nContent-Length: 8\r\n\r\n')
 
         while not done:
@@ -238,10 +235,10 @@
             self.requestData = kwargs
 
         reactor = Reactor()
-        server = HttpServer(reactor, self._portNumber, handler, timeout=0.01, recvSize=3)
+        server = HttpServer(reactor, self.port, handler, timeout=0.01, recvSize=3)
         server.listen()
         sok = socket()
-        sok.connect(('localhost', self._portNumber))
+        sok.connect(('localhost', self.port))
         sok.send('POST / HTTP/1.0\r\nContent-Type: application/x-www-form-urlencoded\r\nTransfer-Encoding: chunked\r\n\r\n5\r\nabcde\r\n5\r\nfghij\r\n0\r\n')
 
         reactor.addTimer(0.2, lambda: self.fail("Test Stuck"))
@@ -255,10 +252,10 @@
             self.requestData = kwargs
 
         reactor = Reactor()
-        server = HttpServer(reactor, self._portNumber, handler)
+        server = HttpServer(reactor, self.port, handler)
         server.listen()
         sok = socket()
-        sok.connect(('localhost', self._portNumber))
+        sok.connect(('localhost', self.port))
         sok.send(httpRequest)
 
         reactor.addTimer(2, lambda: self.fail("Test Stuck"))
@@ -275,10 +272,10 @@
             self.requestData = kwargs
 
         reactor = Reactor()
-        server = HttpServer(reactor, self._portNumber, handler)
+        server = HttpServer(reactor, self.port, handler)
         server.listen()
         sok = socket()
-        sok.connect(('localhost', self._portNumber))
+        sok.connect(('localhost', self.port))
         sok.send(httpRequest)
 
         reactor.addTimer(2, lambda: self.fail("Test Stuck"))
@@ -299,10 +296,10 @@
             self.requestData = kwargs
 
         reactor = Reactor()
-        server = HttpServer(reactor, self._portNumber, handler)
+        server = HttpServer(reactor, self.port, handler)
         server.listen()
         sok = socket()
-        sok.connect(('localhost', self._portNumber))
+        sok.connect(('localhost', self.port))
         sok.send(httpRequest)
 
         reactor.addTimer(2, lambda: self.fail("Test Stuck"))
@@ -323,10 +320,10 @@
             self.requestData = kwargs
 
         reactor = Reactor()
-        server = HttpServer(reactor, self._portNumber, handler)
+        server = HttpServer(reactor, self.port, handler)
         server.listen()
         sok = socket()
-        sok.connect(('localhost', self._portNumber))
+        sok.connect(('localhost', self.port))
         sok.send(httpRequest)
 
         reactor.addTimer(2, lambda: self.fail("Test Stuck"))
@@ -345,17 +342,17 @@
             codes.append(kwargs['ResponseCode'])
             yield "FAIL"
 
-        server = HttpServer(self.reactor, self._portNumber, handler, errorHandler=error_handler, maxConnections=5)
+        server = HttpServer(self.reactor, self.port, handler, errorHandler=error_handler, maxConnections=5)
         server.listen()
 
         self.reactor.getOpenConnections = lambda: 10
 
         sock = socket()
-        sock.connect(('localhost', self._portNumber))
+        sock.connect(('localhost', self.port))
         self.reactor.step()
         sock.send("GET / HTTP/1.0\r\n\r\n")
-        self.reactor.step()
-        self.reactor.step()
+        self.reactor.step().step().step()
+        server.shutdown()
 
         self.assertEquals('FAIL', sock.recv(1024))
         self.assertEquals([503], codes)
@@ -367,17 +364,17 @@
         def error_handler(**kwargs):
             yield "FAIL"
 
-        server = HttpServer(self.reactor, self._portNumber, handler, errorHandler=error_handler, maxConnections=10)
+        server = HttpServer(self.reactor, self.port, handler, errorHandler=error_handler, maxConnections=10)
         server.listen()
 
         self.reactor.getOpenConnections = lambda: 5
 
         sock = socket()
-        sock.connect(('localhost', self._portNumber))
+        sock.connect(('localhost', self.port))
         self.reactor.step()
         sock.send("GET / HTTP/1.0\r\n\r\n")
-        self.reactor.step()
-        self.reactor.step()
+        self.reactor.step().step().step()
+        server.shutdown()
 
         self.assertEquals('OK', sock.recv(1024))
 
@@ -385,19 +382,19 @@
         def handler(**kwargs):
             yield "OK"
 
-        server = HttpServer(self.reactor, self._portNumber, handler, maxConnections=5)
+        server = HttpServer(self.reactor, self.port, handler, maxConnections=5)
         server.listen()
 
         self.reactor.getOpenConnections = lambda: 10
 
         sock = socket()
-        sock.connect(('localhost', self._portNumber))
+        sock.connect(('localhost', self.port))
         self.reactor.step()
         sock.send("GET / HTTP/1.0\r\n\r\n")
-        self.reactor.step()
-        self.reactor.step()
+        self.reactor.step().step().step()
 
         self.assertEquals('HTTP/1.0 503 Service Unavailable\r\n\r\n<html><head></head><body><h1>Service Unavailable</h1></body></html>', sock.recv(1024))
+        server.shutdown()
 
 
     #def testUncaughtException(self):
diff --unidirectional-new-file '--exclude=*.so' '--exclude=*.o' '--exclude=.svn' '--exclude=*.pyc' '--exclude=deps.d' '--exclude=applied' --recursive --unified version_0/test/http/suspendtest.py version_0-merge-trunk/test/http/suspendtest.py
--- version_0/test/http/suspendtest.py	2011-06-21 09:47:06.000000000 +0200
+++ version_0-merge-trunk/test/http/suspendtest.py	2011-06-21 10:16:44.000000000 +0200
@@ -21,19 +21,20 @@
 #    Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
 #
 ## end license ##
+from __future__ import with_statement
 
-from sys import exc_info
 import sys
+from sys import exc_info
 from StringIO import StringIO
-from unittest import TestCase
+
 from re import sub
 from traceback import format_exc
 
-from basetestcase import BaseTestCase
+from weightlesstestcase import WeightlessTestCase
 from calltrace import CallTrace
 
-from weightless.io import Reactor
-from weightless.http import Suspend, HttpServer
+from weightless.io import Reactor, Suspend
+from weightless.http import HttpServer
 
 class MockSocket(object):
     def close(self):
@@ -47,8 +48,7 @@
     'suspend.py': Suspend.__call__.func_code.co_filename,
 }
 
-
-class SuspendTest(BaseTestCase):
+class SuspendTest(WeightlessTestCase):
 
     def testReactorSuspend(self):
         handle = ['initial value']
@@ -118,7 +118,11 @@
         reactor.step()
         self.assertFalse(sok3 in reactor._readers)
         self.assertFalse(sok3 in reactor._writers)
-        reactor.shutdown() 
+        with self.stdout_replaced() as s:
+            reactor.shutdown() 
+            self.assertTrue(str(sok1) in s.getvalue(), s.getvalue())
+            self.assertTrue(str(sok2) in s.getvalue(), s.getvalue())
+        self.assertTrue(str(sok3) in s.getvalue())
         self.assertTrue(sok1.closed)
         self.assertTrue(sok2.closed)
         self.assertTrue(sok3.closed)
diff --unidirectional-new-file '--exclude=*.so' '--exclude=*.o' '--exclude=.svn' '--exclude=*.pyc' '--exclude=deps.d' '--exclude=applied' --recursive --unified version_0/test/httpng/httpprotocolintegrationtest.py version_0-merge-trunk/test/httpng/httpprotocolintegrationtest.py
--- version_0/test/httpng/httpprotocolintegrationtest.py	1970-01-01 01:00:00.000000000 +0100
+++ version_0-merge-trunk/test/httpng/httpprotocolintegrationtest.py	2011-06-22 15:40:00.000000000 +0200
@@ -0,0 +1,432 @@
+## begin license ##
+#
+#    Weightless is a High Performance Asynchronous Networking Library
+#    Copyright (C) 2006-2009 Seek You Too (CQ2) http://www.cq2.nl
+#
+#    This file is part of Weightless
+#
+#    Weightless is free software; you can redistribute it and/or modify
+#    it under the terms of the GNU General Public License as published by
+#    the Free Software Foundation; either version 2 of the License, or
+#    (at your option) any later version.
+#
+#    Weightless is distributed in the hope that it will be useful,
+#    but WITHOUT ANY WARRANTY; without even the implied warranty of
+#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+#    GNU General Public License for more details.
+#
+#    You should have received a copy of the GNU General Public License
+#    along with Weightless; if not, write to the Free Software
+#    Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+#
+## end license ##
+from __future__ import with_statement
+from urllib2 import urlopen, Request, urlopen
+from StringIO import StringIO
+from socket import socket, SHUT_RD, SHUT_WR, SHUT_RDWR, SO_REUSEADDR, SOL_SOCKET
+from select import select
+import sys
+from subprocess import Popen, PIPE
+from re import compile
+
+from weightlesstestcase import WeightlessTestCase
+from weightless.core import compose, Observable, Transparant, be, autostart
+from weightless.io import Gio, Reactor, Server
+from weightless.httpng import HttpProtocol, http
+
+
+def getNetStat(clientport, serverport):
+    connectionRe = compile(':%d.+:%d' % (clientport, serverport))
+    p1 = Popen(['netstat', '-n', '-p'], stdout=PIPE, stderr=PIPE).communicate()[0]
+    return sorted(line for line in p1.split('\n') if connectionRe.search(line))
+
+class HttpProtocolIntegrationTest(WeightlessTestCase):
+
+    def setUp(self):
+        WeightlessTestCase.setUp(self)
+        self.httpprotocol = HttpProtocol()
+        self.server = Server(self.reactor, self.port)
+        dna = (Transparant(),
+            (self.server,
+                (self.httpprotocol,
+                    # add your test thing here
+                )
+            )
+        )
+        self.body = be(dna)
+
+    def tearDown(self):
+        self.server.stop()
+        WeightlessTestCase.tearDown(self)
+
+    def assertNetStat(self, local, remote, state):
+        statelines = getNetStat(local, remote)
+        if not state:
+            self.assertEquals(0, len(statelines), statelines)
+        else:
+            self.assertTrue(state in statelines[0], statelines[0])
+
+    def testSimpleServerSetUpAndAFewPOSTRequests(self):
+        class MyServer(object):
+            def processRequest(self, Method=None, ContentLength=None, *args, **kwargs):
+                if Method != 'POST':
+                    return
+                result = yield http.readRe('(?P<BODY>.*)', ContentLength)
+                body = result['BODY']
+                yield http.ok()
+                yield http.headers('a', 'b')
+                yield 'Hello ' + body
+        self.httpprotocol.addObserver(MyServer())
+        with self.loopingReactor():
+            result1 = urlopen(Request('http://localhost:%s/' % self.port, data='Johan')).read()
+            result2 = urlopen(Request('http://localhost:%s/' % self.port, data='Erik')).read()
+        self.assertEquals('Hello Johan', result1)
+        self.assertEquals('Hello Erik', result2)
+
+    def testContentLenght(self):
+        body = []
+        class MyServer(object):
+            def processRequest(this, Method, RequestURI, HTTPVersion, Headers, **kwargs):
+                length = int(Headers['content-length'].keys()[0])
+                @autostart
+                def destination(result):
+                    while True:
+                        result += (yield)
+                result = []
+                yield http.copyBytes(length, destination(result))
+                self.assertEquals('This is a body', ''.join(result))
+                yield http.ok()
+                yield http.headers('a', 'b')
+                yield 'Hello ' + ''.join(result)
+        self.httpprotocol.addObserver(MyServer())
+        with self.loopingReactor():
+            result1 = urlopen(Request('http://localhost:%s/' % self.port, data='This is a body')).read()
+        self.assertEquals('Hello This is a body', result1)
+
+    def testOneRequest(self):
+        done = []
+        class MyServer(object):
+            def processRequest(this, Method, RequestURI, HTTPVersion, Headers, **kwargs):
+                self.assertEquals('GET', Method)
+                self.assertEquals('/seven', RequestURI)
+                self.assertEquals('1.0', HTTPVersion)
+                self.assertEquals({}, Headers)
+                yield 'Hello there'
+                done.append(True)
+        self.httpprotocol.addObserver(MyServer())
+        sok = socket()
+        sok.connect(('localhost', self.port))
+        sok.send('GET /seven HTTP/1.0\r\n\r\n')
+        while not done:
+            self.reactor.step()
+        self.assertEquals([True], done)
+        self.assertEquals('Hello there', sok.recv(99))
+
+    def testHttp11TwoRequests(self):
+        done = []
+        class MyServer(object):
+            def processRequest(self, Method=None, RequestURI=None, HTTPVersion=None, Headers=None, fragment=None, netloc=None, query=None, path=None, scheme=None):
+                yield http.ok()
+                yield http.noheaders()
+                yield 'Echo ' + RequestURI
+                done.append(True)
+        self.httpprotocol.addObserver(MyServer())
+        sok = socket()
+        sok.connect(('localhost', self.port)) # ONE connection!
+        sok.send('GET /six HTTP/1.1\r\n\r\n')
+        while not done:
+            self.reactor.step()
+        response = sok.recv(999)
+        self.assertEquals('HTTP/1.1 200 Ok\r\n\r\nEcho /six', response)
+        sok.send('GET /seven HTTP/1.1\r\n\r\n')
+        done = []
+        while not done:
+            self.reactor.step()
+        self.assertEquals([True], done)
+        response = sok.recv(999)
+        self.assertEquals('HTTP/1.1 200 Ok\r\n\r\nEcho /seven', response)
+        sok.close() # need to do this, because we use HTTP/1.1
+        self.reactor.step()
+
+    def testGETWithResponse(self):
+        class MyServer(object):
+            def processRequest(self, **kwargs):
+                yield 'answer 1'
+                yield 'answer 2'
+        self.httpprotocol.addObserver(MyServer())
+        sok = socket()
+        sok.connect(('localhost', self.port)) # ONE connection!
+        sok.send('GET /one HTTP/1.1\r\n\r\n')
+        self.reactor.step().step().step()
+        self.assertEquals('answer 1', sok.recv(999))
+        self.reactor.step()
+        self.assertEquals('answer 2', sok.recv(999))
+        sok.shutdown(1)
+        self.reactor.step()
+        self.assertEquals('', sok.recv(999))
+        sok.close()
+
+    def testPOSTandThenGET(self):
+        class MyPOSTServer(object):
+            def processRequest(this, Method=None, RequestURI=None, ContentLength=0, **kwargs):
+                if Method == 'POST':
+                    return this.handle(ContentLength)
+            def handle(this, ContentLength):
+                body = yield http.readRe('(?P<BODY>.*)', ContentLength)
+                self.assertEquals('XXYYZZ', body['BODY'])
+                yield http.ok()
+                yield http.noheaders()
+                yield 'this was the post handler'
+        class MyGETServer(object):
+            def processRequest(this, Method=None, RequestURI=None, **kwargs):
+                if Method == 'GET':
+                    return this.handle()
+            def handle(self):
+                yield http.ok()
+                yield http.noheaders()
+                yield 'this was the GET handler'
+        self.httpprotocol.addObserver(MyPOSTServer())
+        self.httpprotocol.addObserver(MyGETServer())
+        body = 'XXYYZZ'
+        sok = socket()
+        sok.connect(('localhost', self.port)) # ONE connection!
+        sok.send('POST /one HTTP/1.1\r\nContent-Length: %s\r\n\r\n' % len(body) + body)
+        self.reactor.step().step().step()
+        self.assertEquals('HTTP/1.1 200 Ok\r\n', sok.recv(999))
+        self.reactor.step()
+        self.assertEquals('\r\n', sok.recv(999))
+        self.reactor.step()
+        self.assertEquals('this was the post handler', sok.recv(999))
+        sok.send('GET /two HTTP/1.1\r\n\r\n')
+        self.reactor.step().step()
+        self.assertEquals('HTTP/1.1 200 Ok\r\n', sok.recv(999))
+        self.reactor.step()
+        self.assertEquals('\r\n', sok.recv(999))
+        self.reactor.step()
+        self.assertEquals('this was the GET handler', sok.recv(999))
+        sok.close()
+        self.reactor.step()
+
+    def testTwoRequestOnSameConnectionAndConnectionCloseHeader(self):
+        done = []
+        class MyServer(object):
+            def processRequest(this, Method=None, RequestURI=None, ContentLength=0, *args, **kwargs):
+                yield http.ok()
+                if Method == 'POST':
+                    @autostart
+                    def devNull():
+                        while True: yield
+                    yield http.copyBytes(ContentLength, devNull())
+                wrong = yield 'Path = ' + str(RequestURI)
+                self.assertEquals(None, wrong) # Second request must not end up here
+                done.append(True)
+        self.httpprotocol.addObserver(MyServer())
+        sok = socket()
+        sok.connect(('localhost', self.port))
+        body = 'XXYYZZ'
+        sok.send('POST /one HTTP/1.1\r\nContent-Length: %s\r\n\r\n' % len(body) + body)
+        sok.send('GET /two HTTP/1.1\r\nConnection: close\r\n\r\n')
+        while not done == [True]:
+            self.reactor.step()
+        self.assertEquals([True], done)
+        self.assertEquals('HTTP/1.1 200 Ok\r\nPath = /one', sok.recv(99))
+        while not done == [True, True]:
+            self.reactor.step()
+        self.assertEquals('HTTP/1.1 200 Ok\r\nPath = /two', sok.recv(99))
+        sok.close()
+
+    def testConnectionCloseForHTTP10afterPIPELINING(self):
+        class MyServer(object):
+            def processRequest(this, Method, RequestURI, HTTPVersion, Headers, *args, **kwargs):
+                yield http.ok()
+                yield http.headers('Content-Length', 3)
+                yield 'Bye'
+        self.httpprotocol.addObserver(MyServer())
+        sok = socket()
+        sok.connect(('localhost', self.port))
+        sok.send('GET /one HTTP/1.1\r\n\r\n') #pipeline 2 requests
+        sok.send('GET /two HTTP/1.0\r\n\r\n')
+        self.reactor.step().step().step()
+        self.assertEquals('HTTP/1.1 200 Ok\r\n', sok.recv(999))
+        self.reactor.step()
+        self.assertEquals('Content-Length: 3\r\n\r\n', sok.recv(999))
+        self.reactor.step()
+        self.assertEquals('Bye', sok.recv(999))
+        self.reactor.step()
+        self.assertEquals('HTTP/1.1 200 Ok\r\n', sok.recv(999))
+        self.reactor.step()
+        self.assertEquals('Content-Length: 3\r\n\r\n', sok.recv(999))
+        self.reactor.step()
+        self.assertEquals('Bye', sok.recv(999))
+        self.assertEquals('', sok.recv(999))  # empty string means 'closed' in socket land
+
+    def testTimerFiresWhenConnectedClientIsSilent(self):
+        sok = socket()
+        sok.connect(('localhost', self.port))
+        localport = sok.getsockname()[1]
+        self.reactor.step().step().step()
+        self.assertEquals('HTTP/1.1 408 Request Timeout\r\n', sok.recv(999))
+        self.reactor.step()
+        self.assertEquals('\r\n', sok.recv(999))
+        sok.close()
+        stat = getNetStat(self.port, localport)
+        self.assertTrue('TIME_WAIT' in stat[0], stat[0])
+        stat = getNetStat(localport, self.port)
+        self.assertEquals(0, len(stat), stat)
+
+    def testTimerWhenInvalidRequest(self):
+        sok = socket()
+        sok.connect(('localhost', self.port))
+        sok.send('GET / HTTP/1.1\r') # unterminated Request Line
+        sok.send('some garbage'*1024) # some kB garbage to trigger buffer protection
+        sok.send('\rxyz') # unterminated end of Headers
+        self.reactor.step().step().step().step()
+        self.assertEquals('HTTP/1.1 413 Request Entity Too Large\r\n\r\n', sok.recv(999))
+        #self.reactor.step()
+        #self.assertEquals('\r\n', sok.recv(999))
+        sok.close()
+
+    def testReuseAddress(self):
+        remoteport = self.port + 1
+        server = socket()
+        server.setsockopt(SOL_SOCKET, SO_REUSEADDR, 1)
+        server.bind(('127.0.0.1', remoteport))
+        server.listen(1)
+        local = socket()
+        local.connect(('127.0.0.1', remoteport))
+        server.close()
+        server = socket()
+        server.setsockopt(SOL_SOCKET, SO_REUSEADDR, 1)
+        try:
+            server.bind(('127.0.0.1', remoteport))
+        except:
+            self.fail('bind must succeed')
+
+    def testCloseStatesRemoteFirst(self):
+        remoteport = self.port+1
+        server = socket()
+        server.bind(('127.0.0.1', remoteport))
+        server.listen(1)
+        local = socket()
+        local.connect(('127.0.0.1', remoteport))
+        localport = local.getsockname()[1]
+
+        remote = server.accept()[0]
+        self.assertNetStat(remoteport, localport, 'ESTABLISHED')
+        self.assertNetStat(localport, remoteport, 'ESTABLISHED')
+
+        remote.close()
+        self.assertNetStat(remoteport, localport, 'FIN_WAIT2')
+        self.assertNetStat(localport, remoteport, 'CLOSE_WAIT')
+
+        local.close()
+        self.assertNetStat(remoteport, localport, 'TIME_WAIT')
+        self.assertNetStat(localport, remoteport, None)
+
+        server.close()
+        server = socket()
+        try:
+            server.bind(('127.0.0.1', remoteport))
+            self.fail('re-bind must raise Address Already in Use Exception')
+        except AssertionError:
+            raise
+        except Exception, e:
+            pass
+
+
+    def testCloseStatesLocalFirst(self):
+        remoteport = self.port+1
+        server = socket()
+        server.bind(('localhost', remoteport))
+        server.listen(1)
+        local = socket()
+        local.connect(('localhost', remoteport))
+        localport = local.getsockname()[1]
+
+        remote = server.accept()[0]
+        self.assertNetStat(remoteport, localport, 'ESTABLISHED')
+        self.assertNetStat(localport, remoteport, 'ESTABLISHED')
+
+        local.close()
+        self.assertNetStat(localport, remoteport, 'FIN_WAIT2')
+        self.assertNetStat(remoteport, localport, 'CLOSE_WAIT')
+
+        remote.close()
+        self.assertNetStat(localport, remoteport, 'TIME_WAIT')
+        self.assertNetStat(remoteport, localport, None)
+
+        server = socket()
+        try:
+            server.bind(('127.0.0.1', remoteport))
+        except:
+            self.fail('bind must succeed')
+
+    def testClientShutdownWithHTTP(self):
+        remoteport = self.port
+        class MyServer(object):
+            def processRequest(this, **kwargs):
+                yield http.ok()
+                yield http.noheaders()
+                yield 'Bye'
+        self.httpprotocol.addObserver(MyServer())
+        sok = socket()
+        sok.connect(('localhost', remoteport))
+        localport = sok.getsockname()[1]
+        sok.send('GET /one HTTP/1.1\r\n\r\n')
+        self.reactor.step().step().step().step().step()
+        self.assertEquals('HTTP/1.1 200 Ok\r\n\r\nBye', sok.recv(999))
+        sok.shutdown(SHUT_RDWR)     # initiate shutdown/close
+        self.assertNetStat(localport, remoteport, 'FIN_WAIT')
+        self.assertNetStat(remoteport, localport, 'CLOSE_WAIT')
+        self.reactor.step()
+        self.assertEquals('', sok.recv(999))  # empty string means 'closed' in socket land
+        self.assertNetStat(localport, remoteport, 'TIME_WAIT')
+        self.assertNetStat(remoteport, localport, None)
+
+    def XXXXXXXXXXXXXXXXXXXtestOpenHttpWithTransactionOnConnectionScopeExample(self):
+        class Transaction(Observable):
+            def __init__(self, txmanagers):
+                super(Transaction, self).__init__()
+                self._txmanagers = txmanagers
+            def unknown(self, message, *args, **kwargs):
+                txs = []
+                for txmanager in sefl._txmanagers:
+                    tx = txmanager.begin()
+                    txs.append(tx)
+                try:
+                    for response in self.all.unknown(message, *args, **kwargs):
+                        yield response
+                except:
+                    for tx in txs:
+                        tx.abort()
+                else:
+                    for tx in txs:
+                        tx.commit()
+        class MyDB(object):
+            def begin(self):
+                self._preparedData = []
+                return self
+            def store(self, data):
+                self._preparedData.append(data)
+            def commit(self):
+                self.commitedData = ''.join(self._preparedData)
+                self._preparedData = []
+        class MyHandler(Observable):
+            def upload(self, ContentLength, *args, **kwargs):
+                body = yield readBytes(ContentLength)
+                self.any.store(body)
+        mydb = MyDB()
+        reactor = Reactor()
+        server = Server(reactor, 8080)
+        pipe = be((Observable(),
+                    (server,
+                        (Transaction([mydb]), # Transaction commits when connection closes
+                            (HttpProtocol(),
+                                (MyHandler(),
+                                    (mydb,)
+                                )
+                            )
+                        )
+                    )
+                ))
+        self.fail('continue here')
diff --unidirectional-new-file '--exclude=*.so' '--exclude=*.o' '--exclude=.svn' '--exclude=*.pyc' '--exclude=deps.d' '--exclude=applied' --recursive --unified version_0/test/httpng/httpprotocoltest.py version_0-merge-trunk/test/httpng/httpprotocoltest.py
--- version_0/test/httpng/httpprotocoltest.py	1970-01-01 01:00:00.000000000 +0100
+++ version_0-merge-trunk/test/httpng/httpprotocoltest.py	2011-02-25 14:14:24.000000000 +0100
@@ -0,0 +1,216 @@
+## begin license ##
+#
+#    Weightless is a High Performance Asynchronous Networking Library
+#    Copyright (C) 2006-2009 Seek You Too (CQ2) http://www.cq2.nl
+#
+#    This file is part of Weightless
+#
+#    Weightless is free software; you can redistribute it and/or modify
+#    it under the terms of the GNU General Public License as published by
+#    the Free Software Foundation; either version 2 of the License, or
+#    (at your option) any later version.
+#
+#    Weightless is distributed in the hope that it will be useful,
+#    but WITHOUT ANY WARRANTY; without even the implied warranty of
+#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+#    GNU General Public License for more details.
+#
+#    You should have received a copy of the GNU General Public License
+#    along with Weightless; if not, write to the Free Software
+#    Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+#
+## end license ##
+from unittest import TestCase
+from weightless.core import compose, autostart
+from weightless.httpng import HttpProtocol, http
+from weightless.io import copyBytes, readAll
+
+class MockTimer(object):
+    def __init__(self, timeout):
+        pass
+    def __enter__(self):
+        pass
+    def __exit__(self, *args, **kwargs):
+        pass
+
+class HttpProtocolTest(TestCase):
+
+    def setUp(self):
+        self._timer = HttpProtocol.Timer
+        HttpProtocol.Timer = MockTimer
+        self.p = HttpProtocol()
+
+    def tearDown(self):
+        HttpProtocol.Timer = self._timer
+
+    def addHandler(self, handler):
+        self.p.addObserver(handler)
+
+    def processConnection(self):
+        stack = compose(self.p.processConnection())
+        self.assertEquals(None, stack.next()) # i.e. it starts with accepting data
+        return stack
+
+    def testRequestHandledByDifferentObservers(self):
+        class GetHandler(object):
+            def processRequest(self, Method=None, **kwargs):
+                if Method=='GET':
+                    return (x for x in ['HTTP/1.1 200 Ok\r\n', 'hello GET'])
+        class PostHandler(object):
+            def processRequest(self, Method=None, **kwargs):
+                if Method=='HEAD':
+                    return (x for x in ['HTTP/1.1 200 Ok\r\n', 'hello POST'])
+        self.addHandler(PostHandler())
+        self.addHandler(GetHandler())
+        stack = self.processConnection()
+        response = stack.send('GET / HTTP/1.1\r\n\r\n')
+        self.assertEquals('HTTP/1.1 200 Ok\r\n', response)
+        self.assertEquals('hello GET', stack.next())
+        stack.next()
+        response = stack.send('HEAD / HTTP/1.1\r\n\r\n')
+        self.assertEquals('HTTP/1.1 200 Ok\r\n', response)
+        self.assertEquals('hello POST', stack.next())
+
+    def testForwardParsedGETRequest(self):
+        args = []
+        class MyHandler(object):
+            def processRequest(self, **kwargs):
+                args.append(kwargs)
+                yield 'HTTP/1.....etc'
+        self.addHandler(MyHandler())
+        stack = self.processConnection()
+        uri = 'http://host:80/path;user=jan/show;a=all?&a=b&a=c#ref'
+        header = 'Content-Type: text/xml; encoding="utf-8"; version="1.0"'
+        message = 'GET %s HTTP/1.1\r\n%s\r\n\r\n' % (uri, header)
+        response = stack.send(message)
+        self.assertEquals('HTTP/1.....etc', response)
+        args = args[0]
+        self.assertEquals('HTTP/1.....etc', response)
+        self.assertEquals(args['fragment'], 'ref')
+        self.assertEquals(args['RequestURI'], 'http://host:80/path;user=jan/show;a=all?&a=b&a=c#ref')
+        self.assertEquals(args['netloc'], ('host', '80')),
+        headers = args['Headers']
+        self.assertEquals(headers['content-type'], {'text/xml': {'encoding':'utf-8', 'version':'1.0'}})
+        self.assertEquals(args['query'], {'a': ['b', 'c']})
+        self.assertEquals(args['path'], '/path;user=jan/show;a=all')
+        self.assertEquals(args['scheme'], 'http')
+        self.assertEquals(args['Method'], 'GET')
+        self.assertEquals(args['HTTPVersion'], '1.1')
+
+    def testForwardParsedPOSTRequest(self):
+        args = []
+        class MyHandler(object):
+            def processRequest(self, **kwargs):
+                args.append(kwargs)
+                yield 'HTTP/1.....etc'
+        self.addHandler(MyHandler())
+        stack = self.processConnection()
+        uri = 'http://ahost:8000/a/b;user=pete/a;b=any?&x=y&p=q#anchor'
+        header = 'Content-Type: text/plain; encoding="utf-16"; version="1.1"\r\nContent-Length: 20'
+        message = 'POST %s HTTP/1.0\r\n%s\r\n\r\n' % (uri, header)
+        response = stack.send(message)
+        args = args[0]
+        self.assertEquals('HTTP/1.....etc', response)
+        self.assertEquals(args['fragment'], 'anchor')
+        self.assertEquals(args['RequestURI'], 'http://ahost:8000/a/b;user=pete/a;b=any?&x=y&p=q#anchor')
+        self.assertEquals(args['netloc'], ('ahost', '8000')),
+        headers = args['Headers']
+        self.assertEquals(headers['content-length'], {'20': {}})
+        self.assertEquals(headers['content-type'], {'text/plain': {'encoding':'utf-16', 'version':'1.1'}})
+        self.assertEquals(args['ContentLength'], 20)
+        self.assertEquals(args['query'], {'x': ['y'], 'p': ['q']})
+        self.assertEquals(args['path'], '/a/b;user=pete/a;b=any')
+        self.assertEquals(args['scheme'], 'http')
+        self.assertEquals(args['Method'], 'POST')
+        self.assertEquals(args['HTTPVersion'], '1.0')
+
+    def testPOST(self):
+        class Buffer(object):
+            def __init__(self):
+                self.buff = []
+            @autostart
+            def sink(self):
+                while True:
+                    self.buff.append((yield))
+            def value(self):
+                return ''.join(self.buff)
+        buff = Buffer()
+        class MyHandler(object):
+            def processRequest(self, ContentLength=None, **kwargs):
+                yield copyBytes(ContentLength, buff.sink())
+                yield 'HTTP/1.1 2'
+                yield '00 Ok\r\n'
+        self.addHandler(MyHandler())
+        stack = self.processConnection()
+        response = stack.send('POST / HTTP/1.1\r')
+        self.assertEquals(None, response)
+        response = stack.send('\nContent-Length: 5\r\n\r\n12345')
+        self.assertEquals('HTTP/1.1 2', response)
+        response = stack.next()
+        self.assertEquals('00 Ok\r\n', response)
+        self.assertEquals('12345', buff.value())
+
+    def testPostWith100Continue(self):
+        class Buffer(object):
+            def __init__(self):
+                self.buff = []
+            @autostart
+            def sink(self):
+                while True:
+                    self.buff.append((yield))
+            def value(self):
+                return ''.join(self.buff)
+        buff = Buffer()
+        class MyHandler(object):
+            def processRequest(self, ContentLength=None, **kwargs):
+                yield copyBytes(ContentLength, buff.sink())
+                yield 'HTTP/1.1 200 Ok\r\n'
+        self.addHandler(MyHandler())
+        stack = self.processConnection()
+        response = stack.send('POST / HTTP/1.1\r\nContent-Length: 5\r\nExpect: 100-continue\r\n\r\n')
+        self.assertEquals('HTTP/1.1 100 Continue\r\n', response)
+        response = stack.send(None)
+        self.assertEquals(None, response)
+        response = stack.send('12345')
+        self.assertEquals('HTTP/1.1 200 Ok\r\n', response)
+        self.assertEquals('12345', buff.value())
+
+    def testPostWith100ContinueNOT(self):
+        class MyHandler(object):
+            def processRequest(self, ContentLength=None, **kwargs):
+                return
+        self.addHandler(MyHandler())
+        stack = self.processConnection()
+        response = stack.send('POST / HTTP/1.1\r\nContent-Length: 5\r\nExpect: 100-continue\r\n\r\n')
+        self.assertEquals('HTTP/1.1 417 Expectation failed\r\n', response)
+
+    def testNotImplemented(self):
+        stack = self.processConnection()
+        response = stack.send('POST / HTTP/1.1\r\nContent-Length: 5\r\n\r\n')
+        self.assertEquals('HTTP/1.1 501 Not Implemented\r\n', response)
+
+    def testReadChunkEncoded(self):
+        parts = []
+        class MyHandler(object):
+            def processRequest(self, **kwargs):
+                while True:
+                    try:
+                        part = yield
+                    except StopIteration:
+                        break
+                    else:
+                        parts.append(part)
+                yield 'HTTP/1.1 200 Ok\r\n'
+                yield ''.join(parts)
+
+        self.addHandler(MyHandler())
+        stack = self.processConnection()
+        response = stack.send('POST / HTTP/1.1\r\nTransfer-Encoding: chunked\r\n\r\n5\r\n12345\r\n0')
+        self.assertEquals(None, response)
+        response = stack.send('\r\n')
+        self.assertEquals('HTTP/1.1 200 Ok\r\n', response)
+        response = stack.next()
+        self.assertEquals('12345', response)
+        self.assertEquals('12345', ''.join(parts))
+
+    #Client
diff --unidirectional-new-file '--exclude=*.so' '--exclude=*.o' '--exclude=.svn' '--exclude=*.pyc' '--exclude=deps.d' '--exclude=applied' --recursive --unified version_0/test/io/giotest.py version_0-merge-trunk/test/io/giotest.py
--- version_0/test/io/giotest.py	1970-01-01 01:00:00.000000000 +0100
+++ version_0-merge-trunk/test/io/giotest.py	2011-02-28 16:16:47.000000000 +0100
@@ -0,0 +1,268 @@
+from __future__ import with_statement
+## begin license ##
+#
+#    Weightless is a High Performance Asynchronous Networking Library
+#    Copyright (C) 2006-2009 Seek You Too (CQ2) http://www.cq2.nl
+#
+#    This file is part of Weightless
+#
+#    Weightless is free software; you can redistribute it and/or modify
+#    it under the terms of the GNU General Public License as published by
+#    the Free Software Foundation; either version 2 of the License, or
+#    (at your option) any later version.
+#
+#    Weightless is distributed in the hope that it will be useful,
+#    but WITHOUT ANY WARRANTY; without even the implied warranty of
+#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+#    GNU General Public License for more details.
+#
+#    You should have received a copy of the GNU General Public License
+#    along with Weightless; if not, write to the Free Software
+#    Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+#
+## end license ##
+from socket import socketpair, socket
+from socket import socket, SOL_SOCKET, SO_REUSEADDR, SO_LINGER, SOL_TCP, TCP_CORK, TCP_NODELAY
+from struct import pack
+from time import sleep
+from random import randint
+
+from weightlesstestcase import WeightlessTestCase
+
+from weightless.io import Reactor, Acceptor, Gio, giopen
+from weightless.io._gio import Context, SocketContext, Timer, TimeoutException
+
+class GioTest(WeightlessTestCase):
+
+    def testOpenReturnsContextManager(self):
+        result = giopen('http/data/testdata5kb')
+        self.assertTrue(hasattr(result, '__enter__'))
+        self.assertTrue(hasattr(result, '__exit__'))
+
+    def testYieldWithoutContext(self):
+        done = []
+        def handler():
+            yield
+            yield 'a'
+            done.append(True)
+        try:
+            g = Gio(self.mockreactor, handler())
+            self.fail('must not come here')
+        except AssertionError, e:
+            self.assertEquals('Gio: No context available.', str(e))
+
+    def testNeverExittedContextIsForcedToExitByGeneratorExitWhileWriting(self):
+        context =  giopen(self.tempfile, 'rw')
+        def neverExit():
+            with context:
+                while True: # never exit context, unless with exception
+                    yield 'ape'
+        proc = neverExit()
+        g = Gio(self.reactor, proc)
+        self.reactor.step()
+        try:
+            proc.throw(GeneratorExit()) # force exit outside Gio()
+            self.fail('Must not come here')
+        except StopIteration:
+            pass
+        self.assertEquals([], g._contextstack)
+
+    def testNeverExittedContextIsForcedToExitByGeneratorExitWhileReading(self):
+        context =  giopen(self.tempfile, 'rw')
+        def neverExit():
+            with context:
+                while True: # never exit context, unless with exception
+                    yield
+        proc = neverExit()
+        g = Gio(self.reactor, proc)
+        self.reactor.step()
+        try:
+            proc.throw(GeneratorExit()) # force exit outside Gio()
+            self.fail('Must not come here')
+        except GeneratorExit:
+            pass
+        self.assertEquals([], g._contextstack)
+
+    def testGioAsContext(self):
+        open(self.tempfile, 'w').write('read this!')
+        def myProcessor():
+            with giopen(self.tempfile, 'rw') as datastream:
+                self.assertTrue(isinstance(datastream, Context))
+                self.dataIn = yield
+                yield 'write this!'
+        Gio(self.reactor, myProcessor())
+        self.reactor.step()
+        self.assertEquals('read this!', self.dataIn[:19])
+        self.reactor.step()
+        self.assertEquals('read this!write this!', open(self.tempfile).read()[:21])
+        self.assertEquals({}, self.reactor._readers)
+        self.assertEquals({}, self.reactor._writers)
+
+    def testAlternate(self):
+        done = []
+        open(self.tempdir+'/1', 'w').write('1234')
+        open(self.tempdir+'/2', 'w').write('abcd')
+        def swapContents():
+            numbersStream = giopen(self.tempdir+'/1', 'rw')
+            lettersStream = giopen(self.tempdir+'/2', 'rw')
+            with numbersStream:
+                numbers = yield
+            with lettersStream:
+                letters = yield
+                yield numbers
+            with numbersStream:
+                yield letters
+            done.append(True)
+        Gio(self.reactor, swapContents())
+        with self.loopingReactor():
+            while not done:
+                pass
+        self.assertEquals('1234abcd', open(self.tempdir+'/1').read())
+        self.assertEquals('abcd1234', open(self.tempdir+'/2').read())
+
+    def testNesting(self):
+        done = []
+        open(self.tempdir+'/1', 'w').write('1234')
+        open(self.tempdir+'/2', 'w').write('abcd')
+        def swapContents():
+            numbersStream = giopen(self.tempdir+'/1', 'rw')
+            lettersStream = giopen(self.tempdir+'/2', 'rw')
+            with numbersStream:
+                numbers = yield
+                with lettersStream:
+                    letters = yield
+                    yield numbers
+                yield letters
+            done.append(True)
+        Gio(self.reactor, swapContents())
+        while not done:
+            self.reactor.step()
+        self.assertEquals('1234abcd', open(self.tempdir+'/1').read())
+        self.assertEquals('abcd1234', open(self.tempdir+'/2').read())
+
+    def testSocketHandshake(self):
+        reactor = Reactor()
+        lhs, rhs = socketpair()
+        def peter(channel):
+            with channel:
+                message = yield
+                yield 'Hello ' + message[-4:]
+        def jack(channel):
+            with channel:
+                x = yield 'My name is Jack'
+                self.assertEquals(None, x)
+                self.response = yield
+        Gio(reactor, jack(SocketContext(lhs)))
+        Gio(reactor, peter(SocketContext(rhs)))
+        reactor.step().step().step().step()
+        self.assertEquals('Hello Jack', self.response)
+
+    def testLargeBuffers(self):
+        reactor = Reactor()
+        lhs, rhs = socketpair()
+        messages = []
+        messageSize = 1024*128
+        def peter(channel):
+            with channel:
+                while True:
+                    messages.append((yield))
+        def jack(channel):
+            with channel:
+                yield 'X' * messageSize
+        Gio(reactor, jack(SocketContext(lhs)))
+        Gio(reactor, peter(SocketContext(rhs)))
+        while sum(len(message) for message in messages) < messageSize:
+            reactor.step()
+        self.assertTrue(len(messages) > 1) # test is only sensible when multiple parts are sent
+        self.assertEquals(messageSize, len(''.join(messages)))
+
+    def testHowToCreateAHttpServer(self):
+        port = randint(1024, 64000)
+        # SERVER
+        class HttpServer:
+            def __init__(self, reactor, port):
+                ear = socket()
+                ear.bind(('0.0.0.0', port))
+                ear.listen(127)
+                ear.setsockopt(SOL_SOCKET, SO_REUSEADDR, 1)
+                reactor.addReader(ear, self)
+                self._ear = ear
+                self._reactor = reactor
+            def __call__(self):
+                connection, address = self._ear.accept()
+                Gio(self._reactor, self.handleConnection(SocketContext(connection)))
+            def handleConnection(self, connection):
+                with connection:
+                    yield self.handleRequest()
+            def handleRequest(self):
+                msg = yield
+                yield 'HTTP/1.1 200 Ok\r\n\r\nGoodbye'
+            def stop(self):
+                self._reactor.removeReader(self._ear)
+        server = HttpServer(self.reactor, port)
+        #CLIENT
+        responses = []
+        def connection(host, port):
+            connection = socket()
+            connection.connect((host, port))
+            return SocketContext(connection)
+        def httpClient():
+            with connection('localhost', port):
+                yield 'GET %s HTTP/1.0\r\n\r\n' % '/'
+                response = yield
+                responses.append(response)
+        Gio(self.reactor, httpClient())
+        while not responses:
+            self.reactor.step()
+        self.assertEquals(['HTTP/1.1 200 Ok\r\n\r\nGoodbye'], responses)
+        server.stop()
+
+    def testTimerDoesNotFire(self):
+        done = []
+        def handler():
+            with giopen(self.tempfile, 'rw'):
+                with Timer(0.1):
+                    yield 'a'
+                yield 'b'
+            done.append(True)
+        g = Gio(self.mockreactor, handler())
+        self.mockreactor.step().step()
+        self.assertEquals([True], done)
+        self.assertEquals([], self.mockreactor._timers)
+        self.assertEquals([], g._contextstack)
+
+    def testTimerTimesOutOutsideBlock(self):
+        done = []
+        def handler():
+            try:
+                with giopen(self.tempfile, 'rw'):
+                    with Timer(0.1):
+                        for i in xrange(999999):
+                            yield 'a'
+            except TimeoutException:
+                done.append(False)
+            yield
+        g = Gio(self.mockreactor, handler())
+        while not done:
+            self.mockreactor.step()
+        self.assertEquals([False], done)
+        self.assertEquals([], self.mockreactor._timers)
+        self.assertEquals([], g._contextstack)
+
+    def testTimerTimesOutWithinBlock(self):
+        done = []
+        def handler():
+            with giopen(self.tempfile, 'rw'):
+                with Timer(0.1):
+                    try:
+                        for i in xrange(999999):
+                            yield 'a'
+                    except TimeoutException:
+                        done.append(False)
+            yield
+        g = Gio(self.reactor, handler())
+        while done != [False]:
+            self.reactor.step()
+        self.assertEquals([False], done)
+        self.assertEquals([], self.mockreactor._timers)
+        self.assertEquals([], g._contextstack)
diff --unidirectional-new-file '--exclude=*.so' '--exclude=*.o' '--exclude=.svn' '--exclude=*.pyc' '--exclude=deps.d' '--exclude=applied' --recursive --unified version_0/test/io/gutilstest.py version_0-merge-trunk/test/io/gutilstest.py
--- version_0/test/io/gutilstest.py	1970-01-01 01:00:00.000000000 +0100
+++ version_0-merge-trunk/test/io/gutilstest.py	2011-02-28 16:16:55.000000000 +0100
@@ -0,0 +1,193 @@
+## begin license ##
+#
+#    Weightless is a High Performance Asynchronous Networking Library
+#    Copyright (C) 2006-2008 Seek You Too (CQ2) http://www.cq2.nl
+#
+#    This file is part of Weightless
+#
+#    Weightless is free software; you can redistribute it and/or modify
+#    it under the terms of the GNU General Public License as published by
+#    the Free Software Foundation; either version 2 of the License, or
+#    (at your option) any later version.
+#
+#    Weightless is distributed in the hope that it will be useful,
+#    but WITHOUT ANY WARRANTY; without even the implied warranty of
+#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+#    GNU General Public License for more details.
+#
+#    You should have received a copy of the GNU General Public License
+#    along with Weightless; if not, write to the Free Software
+#    Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+#
+## end license ##
+from unittest import TestCase
+from random import choice, randint
+from string import ascii_letters
+from weightless.core import compose
+from weightless.io import copyBytes, readAll, readRe
+from re import compile
+
+def collector(basket, responses):
+    responses = iter(responses)
+    try:
+        while True:
+            basket.append((yield responses.next()))
+    except StopIteration:
+        pass
+    yield
+
+def feed(data, generator):
+    responses = []
+    for item in data:
+        responses.append(generator.send(item))
+    return responses
+
+class GutilsTest(TestCase):
+
+    def assertCopy(self, bytes, messages, responses, slice, remainder):
+        basket = []
+        restbasket = []
+        def helper():
+            c1 = collector(basket, responses); c1.next()
+            yield copyBytes(bytes, c1)
+            while True:
+                restbasket.append((yield))
+        responsesResult = feed([None]+messages, compose(helper()))
+        self.assertEquals(responses, responsesResult) # I still don't know if this is relevant and how it must work
+        self.assertEquals(slice, basket)
+        self.assertEquals(remainder, restbasket)
+
+    def testMessagesOfSizeOne(self):
+        self.assertCopy(bytes=10, messages=['a','b','c'], responses=[None,None,None,None], slice=['a','b','c'], remainder=[])
+        self.assertCopy(bytes= 3, messages=['a','b','c'], responses=[None,None,None,None], slice=['a','b','c'], remainder=[])
+        self.assertCopy(bytes= 2, messages=['a','b','c'], responses=[None,None,None,None], slice=['a','b'], remainder=['c'])
+        self.assertCopy(bytes= 1, messages=['a','b','c'], responses=[None,None,None,None], slice=['a'], remainder=['b','c'])
+        self.assertCopy(bytes= 0, messages=['a','b','c'], responses=[None,None,None,None], slice=[], remainder=['a', 'b','c'])
+
+    def testMessagesOfSizeTwo(self):
+        self.assertCopy(bytes=10, messages=['ab','cd','ef'], responses=[None,None,None,None], slice=['ab','cd','ef'], remainder=[])
+        self.assertCopy(bytes= 3, messages=['ab','cd','ef'], responses=[None,None,None,None], slice=['ab','c'], remainder=['d','ef'])
+        self.assertCopy(bytes= 2, messages=['ab','cd','ef'], responses=[None,None,None,None], slice=['ab'], remainder=['cd','ef'])
+        self.assertCopy(bytes= 1, messages=['ab','cd','ef'], responses=[None,None,None,None], slice=['a'], remainder=['b','cd','ef'])
+        self.assertCopy(bytes= 0, messages=['ab','cd','ef'], responses=[None,None,None,None], slice=[], remainder=['ab', 'cd','ef'])
+
+    def testRandom(self):
+        for i in range(100):
+            sliceLen = randint(0,100)
+            basket = []
+            restbasket = []
+            def helper():
+                c1 = collector(basket,[None for x in range(99999)]); c1.next()
+                yield copyBytes(sliceLen, c1)
+                while True:
+                    restbasket.append((yield))
+            g = compose(helper())
+            g.next()
+            totalLen = 0
+            while totalLen < sliceLen:
+                s = ''.join(choice(ascii_letters) for i in range(randint(0,100)))
+                g.send(s)
+                totalLen += len(s)
+            self.assertEquals(sliceLen, len(''.join(basket)))
+            self.assertEquals(totalLen-sliceLen, len(''.join(restbasket)))
+
+    def testStopIterationBoundariesCollide(self):
+        data = []
+        def target():
+            try:
+                while True:
+                    data.append((yield))
+            except StopIteration:
+                data.append('done')
+        def helper():
+            t = target(); t.next()
+            yield copyBytes(2, t)
+            try:
+                yield t.throw(StopIteration)
+            except:
+                pass
+            while True: yield
+        g = compose(helper()); g.next()
+        feed(['a','b','c'], g)
+        self.assertEquals(['a','b', 'done'], data)
+
+    def testStopIteration(self):
+        data = []
+        def target():
+            try:
+                while True:
+                    data.append((yield))
+            except StopIteration:
+                data.append('done')
+        def helper():
+            t = target(); t.next()
+            yield copyBytes(2, t)
+            try:
+                yield t.throw(StopIteration)
+            except StopIteration:
+                pass
+            while True: yield
+        g = compose(helper()); g.next()
+        feed(['a','bc','d'], g)
+        self.assertEquals(['a','b', 'done'], data)
+
+    def testDoNotDitchResponse(self):
+        def application():
+            data = yield readAll()
+            self.assertEquals('a', data)
+            yield 'A'
+        appl = compose(application()); appl.next()
+        def protocol():
+            yield copyBytes(1, appl)
+            yield appl.throw(StopIteration)
+            yield 'B'
+            b = yield
+            yield b
+        g = compose(protocol()); 
+        self.assertEquals(None, g.next())
+        self.assertEquals('A', g.send('a'))
+        self.assertEquals('B', g.send(None))
+        self.assertEquals(None, g.send(None))
+        self.assertEquals('b', g.send('b'))
+
+    def testDoNotDitchResponseInCaseOfSplitMessages(self):
+        def application():
+            data = yield readAll()
+            self.assertEquals('a', data)
+            yield 'A'
+        appl = compose(application()); appl.next()
+        def protocol():
+            yield copyBytes(1, appl)
+            try:
+                yield appl.throw(StopIteration)
+            except StopIteration:
+                pass
+            yield 'B'
+            yield 'C'
+            b = yield
+            yield b
+        g = compose(protocol()); g.next()
+        self.assertEquals('A', g.send('ab'))
+        self.assertEquals('B', g.send(None))
+        self.assertEquals('C', g.send(None))
+        self.assertEquals('b', g.send(None))
+
+    def testReadRe(self):
+        x = readRe(compile('(?P<ape>xyz)'))
+        x.next()
+        try:
+            x.send('xyz') # fail
+            self.fail('must not come here')
+        except StopIteration, s:
+            self.assertEquals(({'ape': 'xyz'},), s.args)
+
+    def testReadReWithMaximumBytes(self):
+        x = readRe(compile('xyz'), 5)
+        x.next()
+        x.send('abc')
+        try:
+            x.send('abc') # fail
+            self.fail('must not come here')
+        except OverflowError, e:
+            self.assertEquals('no match after 6 bytes', str(e))
+
diff --unidirectional-new-file '--exclude=*.so' '--exclude=*.o' '--exclude=.svn' '--exclude=*.pyc' '--exclude=deps.d' '--exclude=applied' --recursive --unified version_0/test/io/reactortest.py version_0-merge-trunk/test/io/reactortest.py
--- version_0/test/io/reactortest.py	1970-01-01 01:00:00.000000000 +0100
+++ version_0-merge-trunk/test/io/reactortest.py	2011-06-21 10:24:37.000000000 +0200
@@ -0,0 +1,434 @@
+## begin license ##
+#
+#    Weightless is a High Performance Asynchronous Networking Library
+#    See http://weightless.io
+#    Copyright (C) 2006-2011 Seek You Too (CQ2) http://www.cq2.nl
+#
+#    This file is part of Weightless
+#
+#    Weightless is free software; you can redistribute it and/or modify
+#    it under the terms of the GNU General Public License as published by
+#    the Free Software Foundation; either version 2 of the License, or
+#    (at your option) any later version.
+#
+#    Weightless is distributed in the hope that it will be useful,
+#    but WITHOUT ANY WARRANTY; without even the implied warranty of
+#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+#    GNU General Public License for more details.
+#
+#    You should have received a copy of the GNU General Public License
+#    along with Weightless; if not, write to the Free Software
+#    Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+#
+## end license ##
+#
+from __future__ import with_statement
+
+from time import time, sleep
+from signal import signal, SIGALRM, alarm, pause
+from select import error as ioerror
+import os, sys
+from tempfile import mkstemp
+from StringIO import StringIO
+
+from weightlesstestcase import WeightlessTestCase
+from weightless.io import Reactor
+from socket import socketpair, error
+
+class ReactorTest(WeightlessTestCase):
+
+    def testAddSocketReading(self):
+        class Sok:
+            def __hash__(self): return 1
+        reactor = Reactor()
+        mockSok = Sok()
+        self.assertTrue(mockSok not in reactor._readers)
+        reactor.addReader(mockSok, lambda: None)
+        self.assertTrue(mockSok in reactor._readers)
+        reactor.removeReader(mockSok)
+        self.assertFalse(mockSok in reactor._readers)
+
+    def testAddSocketWriting(self):
+        class Sok:
+            def __hash__(self): return 1
+        reactor = Reactor()
+        mockSok = Sok()
+        self.assertTrue(mockSok not in reactor._writers)
+        reactor.addWriter(mockSok, None)
+        self.assertTrue(mockSok in reactor._writers)
+        reactor.removeWriter(mockSok)
+        self.assertFalse(mockSok in reactor._writers)
+
+    def testAddSocketRaisesException(self):
+        class Sok: # raise exception when put into set
+            def __hash__(self): raise Exception('aap')
+        reactor = Reactor()
+        try:
+            reactor.addReader(Sok(), None)
+            self.fail()
+        except Exception, e:
+            self.assertEquals('aap', str(e))
+
+    def testReadFile(self):
+        reactor = Reactor()
+        fd, path = mkstemp()
+        os.write(fd, 'some data')
+        os.close(fd)
+        try:
+            f = open(path)
+            def readable():
+                self.readable = True
+            reactor.addReader(f, readable)
+            reactor.step()
+            self.assertTrue(self.readable)
+        finally:
+            f.close()
+            os.remove(path)
+
+    def testTimer(self):
+        reactor = Reactor()
+        def itsTime():
+            itstime.append(True)
+        reactor.addTimer(0.05, itsTime)
+        reactor.addTimer(0.5, itsTime)
+        reactor.addTimer(0.25, itsTime)
+        start = time()
+        itstime = []
+        while not itstime:
+            reactor.step()
+        self.assertTrue(0.04 < time() - start < 0.06, time() - start)
+        itstime = []
+        while not itstime:
+            reactor.step()
+        self.assertTrue(0.20 < time() - start < 0.30, time()-start)
+        itstime = []
+        while not itstime:
+            reactor.step()
+        self.assertTrue(0.45 < time() - start < 0.55, time()-start)
+        itstime = []
+
+    def testInvalidTime(self):
+        reactor = Reactor()
+        try:
+            reactor.addTimer(-1, None)
+            self.fail('should raise exeption')
+        except Exception, e:
+            self.assertEquals('Timeout must be >= 0. It was -1.', str(e))
+
+    def testDuplicateTimerDoesNotCauseZeroTimeout(self):
+        itstime = []
+        def itsTime():
+            itstime.append(True)
+        reactor = Reactor()
+        reactor.addTimer(0.05, itsTime)
+        reactor.addTimer(0.05, itsTime)
+        reactor.addTimer(0.05, itsTime)
+        reactor.addTimer(0.05, itsTime)
+        reactor.addTimer(0.05, itsTime)
+        while itstime != [True, True, True, True, True]:
+            reactor.step()
+        self.assertEquals([True, True, True, True, True], itstime)
+
+    def testRemoveTimer(self):
+        def itsTime(): pass
+        reactor = Reactor()
+        token1 = reactor.addTimer(0.05, itsTime)
+        token2 = reactor.addTimer(0.051, itsTime)
+        reactor.removeTimer(token1)
+        self.assertEquals(1, len(reactor._timers))
+
+    def testExceptionInTimeoutCallback(self):
+        sys.stderr = StringIO()
+        try:
+            def itsTime(): raise Exception('here is the exception')
+            reactor = Reactor()
+            token1 = reactor.addTimer(0.001, itsTime)
+            try:
+                reactor.step()
+            except:
+                self.fail('must not raise exception')
+        finally:
+            sys.stderr = sys.__stderr__
+
+    def testSelfModifyingLoopSkipsEverySecondTimerAndDeletesTheWrongOneBUG(self):
+        done = []
+        reactor = Reactor()
+        def callback1():
+            self.assertEquals([], done)
+            done.append(1)
+            self.assertEquals([timer1, timer2, timer3], reactor._timers)
+        def callback2():
+            self.assertEquals([1], done)
+            done.append(2)
+            self.assertEquals([timer2, timer3], reactor._timers)
+        def callback3():
+            self.assertEquals([1,2], done)
+            done.append(3)
+            self.assertEquals([timer3], reactor._timers)
+        timer1 = reactor.addTimer(0.0001, callback1)
+        timer2 = reactor.addTimer(0.0002, callback2)
+        timer3 = reactor.addTimer(0.0003, callback3)
+        self.assertEquals([timer1, timer2, timer3], reactor._timers)
+        sleep(0.004)
+        reactor.step()
+        self.assertEquals([1,2,3], done)
+        self.assertEquals([], reactor._timers)
+
+    def testAssertionErrorInReadCallback(self):
+        sys.stderr = StringIO()
+        try:
+            def callback(): raise AssertionError('here is the assertion')
+            reactor = Reactor(lambda r, w, o, t: (r,w,o))
+            reactor.addReader(9, callback)
+            try:
+                reactor.step()
+                self.fail('must raise exception')
+            except AssertionError, e:
+                self.assertEquals('here is the assertion', str(e))
+        finally:
+            sys.stderr = sys.__stderr__
+
+    def testAssertionErrorInWRITECallback(self):
+        sys.stderr = StringIO()
+        try:
+            def callback(): raise AssertionError('here is the assertion')
+            reactor = Reactor(lambda r, w, o, t: (r,w,o))
+            reactor.addWriter(9, callback)
+            try:
+                reactor.step()
+                self.fail('must raise exception')
+            except AssertionError, e:
+                self.assertEquals('here is the assertion', str(e))
+        finally:
+            sys.stderr = sys.__stderr__
+
+    def testWriteFollowsRead(self):
+        reactor = Reactor(lambda r,w,o,t: (r,w,o))
+        t = []
+        def read():
+            t.append('t1')
+        def write():
+            t.append('t2')
+        reactor.addWriter('sok1', write)
+        reactor.addReader('sok1', read)
+        reactor.step()
+        self.assertEquals(['t1', 't2'], t)
+
+    def testReadDeletesWrite(self):
+        reactor = Reactor(lambda r,w,o,t: (r,w,o))
+        self.read = self.write = False
+        def read():
+            self.read = True
+            reactor.removeWriter('sok1')
+        def write():
+            self.write = True
+        reactor.addWriter('sok1', write)
+        reactor.addReader('sok1', read)
+        reactor.step()
+        self.assertTrue(self.read)
+        self.assertFalse(self.write)
+
+    def testReadFollowsTimer(self):
+        reactor = Reactor(lambda r,w,o,t: (r,w,o))
+        t = []
+        def timer():
+            t.append('t1')
+        def read():
+            t.append('t2')
+        reactor.addTimer(0, timer)
+        reactor.addReader('sok1', read)
+        reactor.step()
+        self.assertEquals(['t1', 't2'], t)
+
+    def testTimerDeletesRead(self):
+        reactor = Reactor(lambda r,w,o,t: (r,w,o))
+        self.read = self.timer = False
+        def read():
+            self.read = True
+        def timer():
+            self.timer = True
+            reactor.removeReader('sok1')
+        reactor.addTimer(0, timer)
+        reactor.addReader('sok1', read)
+        reactor.step()
+        self.assertTrue(self.timer)
+        self.assertFalse(self.read)
+
+    def testInterruptedSelectDoesNotDisturbTimer(self):
+        reactor = Reactor()
+        self.time = False
+        def signalHandler(signum, frame):
+            self.alarm = True
+        def timeout():
+            self.time = time()
+        signal(SIGALRM, signalHandler)
+        targetTime = time() + 1.1
+        reactor.addTimer(1.1, timeout)
+        alarm(1) # alarm only accept ints....
+        try:
+            with self.stderr_replaced() as s:
+                while not self.time:
+                    reactor.step()
+                self.assertTrue("4, 'Interrupted system call'" in s.getvalue(), s.getvalue())
+            self.assertTrue(self.alarm)
+            self.assertTrue(targetTime - 0.01 < self.time, targetTime + 0.01)
+        except ioerror:
+            self.fail('must not fail on Interrupted system call')
+
+    def testGetRidOfBadFileDescriptors(self):
+        reactor = Reactor()
+        class BadSocket(object):
+            def fileno(self): return 88
+            def close(self): raise Exception('hell breaks loose')
+        self.timeout = False
+        def timeout():
+            self.timeout = True
+        reactor.addReader(99, None) # broken
+        reactor.addWriter(99, None) # broken
+        reactor.addReader(BadSocket(), None) # even more broken
+        reactor.addTimer(0.01, timeout)
+        with self.stderr_replaced() as s:
+            for i in range(10):
+                if self.timeout:
+                    break
+                reactor.step()
+            self.assertTrue("Bad file descriptor" in s.getvalue(), s.getvalue())
+        self.assertTrue(self.timeout)
+        self.assertEquals({}, reactor._readers)
+        self.assertEquals({}, reactor._writers)
+        self.assertEquals([], reactor._timers)
+
+    def testDoNotDieButLogOnProgrammingErrors(self):
+        reactor = Reactor()
+        reactor.addReader('not a sok', None)
+        try:
+            sys.stderr = StringIO()
+            reactor.step()
+            sys.stderr.seek(0)
+            self.assertTrue('TypeError: argument must be an int' in sys.stderr.getvalue())
+            sys.stderr = sys.__stderr__
+        except TypeError:
+            self.fail('must not fail')
+
+    def testDoNotMaskOtherErrors(self):
+        def raiser(*args): raise Exception('oops')
+        reactor = Reactor(raiser)
+        try:
+            reactor.step()
+            self.fail('must raise oops')
+        except Exception, e:
+            self.assertEquals('oops', str(e))
+
+    def testTimerDoesNotMaskAssertionErrors(self):
+        reactor = Reactor()
+        reactor.addTimer(0, lambda: self.fail("Assertion Error"))
+        try:
+            reactor.step()
+            raise Exception('step() must raise AssertionError')
+        except AssertionError:
+            self.assertEquals([], reactor._timers)
+
+    def testGlobalReactor(self):
+        from weightless.io import reactor
+        thereactor = Reactor()
+        def handler():
+            self.assertEquals(thereactor, reactor())
+        thereactor.addTimer(0, handler)
+        thereactor.step()
+
+    def testReadPriorities(self):
+        reactor = Reactor()
+        local0, remote0 = socketpair()
+        local1, remote1 = socketpair()
+        data0 = []
+        def remoteHandler0():
+            data0.append(remote0.recv(999))
+        data1 = []
+        def remoteHandler1():
+            data1.append(remote1.recv(999))
+        reactor.addReader(remote0, remoteHandler0, 0)
+        reactor.addReader(remote1, remoteHandler1, 3)
+        local0.send('ape')
+        local1.send('nut')
+        reactor.step() #1
+        self.assertEquals(['ape'], data0)
+        self.assertEquals([], data1)
+        reactor.step() #2
+        self.assertEquals([], data1)
+        reactor.step() #3
+        self.assertEquals(['nut'], data1)
+
+    def testMinandMaxPrio(self):
+        reactor = Reactor()
+        try:
+            reactor.addReader('', '', -1)
+            self.fail()
+        except ValueError, e:
+            self.assertEquals('Invalid priority: -1', str(e))
+        try:
+            reactor.addReader('', '', Reactor.MAXPRIO)
+            self.fail()
+        except ValueError, e:
+            self.assertEquals('Invalid priority: 10', str(e))
+        try:
+            reactor.addWriter('', '', -1)
+            self.fail()
+        except ValueError, e:
+            self.assertEquals('Invalid priority: -1', str(e))
+        try:
+            reactor.addWriter('', '', Reactor.MAXPRIO)
+            self.fail()
+        except ValueError, e:
+            self.assertEquals('Invalid priority: 10', str(e))
+
+    def testDefaultPrio(self):
+        reactor = Reactor()
+        reactor.addReader('', '')
+        self.assertEquals(Reactor.DEFAULTPRIO, reactor._readers[''].prio)
+        reactor.addWriter('', '')
+        self.assertEquals(Reactor.DEFAULTPRIO, reactor._writers[''].prio)
+
+
+    def testWritePrio(self):
+        reactor = Reactor()
+        local0, remote0 = socketpair()
+        local1, remote1 = socketpair()
+        local1.setblocking(0)
+        def remoteHandler0():
+            remote0.send('ape')
+        def remoteHandler1():
+            remote1.send('nut')
+        reactor.addWriter(remote0, remoteHandler0, 0)
+        reactor.addWriter(remote1, remoteHandler1, 3)
+        reactor.step() #1
+        self.assertEquals('ape', local0.recv(999))
+        try:
+            local1.recv(999)
+            self.fail('must be no data on the socket yet')
+        except error:
+            pass
+        reactor.step() #2
+        try:
+            local1.recv(999)
+            self.fail('must be no data on the socket yet')
+        except error:
+            pass
+        reactor.step() #3
+        self.assertEquals('nut', local1.recv(999))
+
+    def testGetOpenConnections(self):
+        reactor = Reactor()
+        self.assertEquals(0, reactor.getOpenConnections())
+        reactor.addReader('', '')
+        self.assertEquals(1, reactor.getOpenConnections())
+        reactor.addWriter('', '')
+        self.assertEquals(2, reactor.getOpenConnections())
+
+        reactor.removeReader('')
+        self.assertEquals(1, reactor.getOpenConnections())
+        reactor.removeWriter('')
+        self.assertEquals(0, reactor.getOpenConnections())
+
+
+
+
diff --unidirectional-new-file '--exclude=*.so' '--exclude=*.o' '--exclude=.svn' '--exclude=*.pyc' '--exclude=deps.d' '--exclude=applied' --recursive --unified version_0/test/io/servertest.py version_0-merge-trunk/test/io/servertest.py
--- version_0/test/io/servertest.py	1970-01-01 01:00:00.000000000 +0100
+++ version_0-merge-trunk/test/io/servertest.py	2011-06-22 15:40:11.000000000 +0200
@@ -0,0 +1,129 @@
+## begin license ##
+#
+#    Weightless is a High Performance Asynchronous Networking Library
+#    Copyright (C) 2006-2009 Seek You Too (CQ2) http://www.cq2.nl
+#
+#    This file is part of Weightless
+#
+#    Weightless is free software; you can redistribute it and/or modify
+#    it under the terms of the GNU General Public License as published by
+#    the Free Software Foundation; either version 2 of the License, or
+#    (at your option) any later version.
+#
+#    Weightless is distributed in the hope that it will be useful,
+#    but WITHOUT ANY WARRANTY; without even the implied warranty of
+#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+#    GNU General Public License for more details.
+#
+#    You should have received a copy of the GNU General Public License
+#    along with Weightless; if not, write to the Free Software
+#    Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+#
+## end license ##
+from __future__ import with_statement
+from urllib2 import urlopen
+from StringIO import StringIO
+import socket
+import sys
+from select import select
+
+from weightlesstestcase import WeightlessTestCase
+
+from weightless.io import Server
+
+class ServerTest(WeightlessTestCase):
+
+    def testListen(self):
+        server = Server(self.reactor, self.port)
+        self.send('localhost', self.port, 'are you listening?')
+        server.stop()
+
+    def testConnect(self):
+        messages = []
+        class Interceptor(object):
+            def processConnection(self):
+                messages.append((yield))
+        server = Server(self.reactor, self.port)
+        server.addObserver(Interceptor())
+        sok = self.send('localhost', self.port, 'a message')
+        self.reactor.step().step()
+        self.assertEquals(['a message'], messages)
+        sok.close()
+        server.stop()
+
+    def testConnectionNotProcessedRaisesError(self):
+        server = Server(self.reactor, self.port)
+        sok = self.send('localhost', self.port, 'a message')
+        sys.stderr = StringIO()
+        try:
+            self.reactor.step()
+            self.assertTrue('None of the 0 observers responds to any.processConnection(...)' in sys.stderr.getvalue())
+        finally:
+            sys.stderr = sys.__stderr__
+        sok.close()
+        server.stop()
+
+    def testShutdownAndClose(self):
+        class Interceptor(object):
+            def processConnection(self):
+                yield 'over en uit'
+        server = Server(self.reactor, self.port)
+        server.addObserver(Interceptor())
+        connection = self.send('localhost', self.port, 'a message')
+        while connection not in select([connection],[],[],0)[0]:
+            self.reactor.step()
+        self.assertEquals('over en uit', connection.recv(99))
+        try:
+            connection.send('aap')
+            self.fail('connection is closed, this must raise an io error')
+        except socket.error, e:
+            pass
+        connection.close()
+        server.stop()
+
+    def testShutdownAndCloseInCaseOfException(self):
+        class Interceptor(object):
+            def processConnection(self):
+                raise Exception('oops')
+                yield 'over en uit'
+        server = Server(self.reactor, self.port)
+        server.addObserver(Interceptor())
+        connection = self.send('localhost', self.port, 'a message')
+        sys.stderr = StringIO()
+        try:
+            self.reactor.step()
+        finally:
+            sys.stderr = sys.__stderr__
+        try:
+            connection.send('aap')
+            self.fail('connection is closed, this must raise an io error')
+        except socket.error, e:
+            pass
+        connection.close()
+        server.stop()
+
+    def XXXXXXXXXXXXXXXXtestMultipleConnectionsAndSomeShortConversation(self):
+        class MyHandler(object):
+            def processConnection(self):
+                message = yield
+                yield 'Goodbye ' + message
+        server = Server(self.reactor, self.port)
+        server.addObserver(MyHandler())
+        conn3 = self.send('localhost', self.port, 'Klaas')
+        conn1 = self.send('localhost', self.port, 'Thijs')
+        conn2 = self.send('localhost', self.port, 'Johan')
+        readable = []
+        while conn1 not in readable or conn2 not in readable or conn3 not in readable:
+            self.reactor.step()
+            readable = select([conn1, conn2, conn3],[],[],0)[0]
+        self.assertEquals('Goodbye Thijs', conn1.recv(99))
+        self.assertEquals('Goodbye Johan', conn2.recv(99))
+        self.assertEquals('Goodbye Klaas', conn3.recv(99))
+        conn1.close()
+        conn2.close()
+        conn3.close()
+        server.stop()
+
+#TOTEST:
+# - error in processConnection
+# - leave connection open if ..... for ... seconds (apache keeps it open for approx 5)
Binary files version_0/test/io/.servertest.py.swp and version_0-merge-trunk/test/io/.servertest.py.swp differ
Only in version_0/test: localtest.py
Only in version_0/test: reactortest.py
Only in version_0/test: servertestcase.py
Only in version_0/test: servertestcasetest.py
Only in version_0/test: sidekicktest.py
Only in version_0/test: speedComparisonCallVsCurryVsGeneratorVsClass.py
diff --unidirectional-new-file '--exclude=*.so' '--exclude=*.o' '--exclude=.svn' '--exclude=*.pyc' '--exclude=deps.d' '--exclude=applied' --recursive --unified version_0/test/weightlesstestcase.py version_0-merge-trunk/test/weightlesstestcase.py
--- version_0/test/weightlesstestcase.py	1970-01-01 01:00:00.000000000 +0100
+++ version_0-merge-trunk/test/weightlesstestcase.py	2011-06-21 11:36:04.000000000 +0200
@@ -0,0 +1,157 @@
+#!/usr/bin/env python2.5
+# encoding: utf-8
+## begin license ##
+#
+#    Weightless is a High Performance Asynchronous Networking Library
+#    Copyright (C) 2006-2009 Seek You Too (CQ2) http://www.cq2.nl
+#
+#    This file is part of Weightless
+#
+#    Weightless is free software; you can redistribute it and/or modify
+#    it under the terms of the GNU General Public License as published by
+#    the Free Software Foundation; either version 2 of the License, or
+#    (at your option) any later version.
+#
+#    Weightless is distributed in the hope that it will be useful,
+#    but WITHOUT ANY WARRANTY; without even the implied warranty of
+#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+#    GNU General Public License for more details.
+#
+#    You should have received a copy of the GNU General Public License
+#    along with Weightless; if not, write to the Free Software
+#    Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+#
+## end license ##
+from __future__ import with_statement
+from contextlib import contextmanager
+from socket import socket
+from random import randint
+from time import time
+from StringIO import StringIO
+import sys, string, os
+from tempfile import mkdtemp, mkstemp
+from shutil import rmtree
+
+from unittest import TestCase
+from threading import Thread
+from weightless.io import Reactor
+
+class WeightlessTestCase(TestCase):
+
+    def setUp(self):
+        self.tempdir = mkdtemp()
+        fd, self.tempfile = mkstemp()
+        os.close(fd)
+        self.reactor = Reactor()
+        self.mockreactor = Reactor(lambda r, w, o, t: (r, w, o))
+        self.port = randint(2**15, 2**16)
+
+    def tearDown(self):
+        t0 = time()
+        self.assertEquals({}, self.reactor._readers)
+        self.assertEquals({}, self.reactor._writers)
+        self.assertEquals({}, self.reactor._suspended)
+        for t in self.reactor._timers:
+            cb = t.callback
+            code = cb.func_code
+            print 'WARNING: dangling timer in reactor. Remaining timout: %s with callback to %s() in %s at line %s.' \
+                % (t.time-t0, cb.func_name, code.co_filename, code.co_firstlineno)
+        self.assertEquals([], self.reactor._timers)
+        self.reactor.shutdown()
+        rmtree(self.tempdir)
+        os.remove(self.tempfile)
+
+    def select(self, aString, index):
+        while index < len(aString):
+            char = aString[index]
+            index = index + 1
+            if not char in string.whitespace:
+                return char, index
+        return '', index
+
+    def cursor(self, aString, index):
+        return aString[:index - 1] + "---->" + aString[index - 1:]
+
+    def assertEqualsWS(self, s1, s2):
+        index1 = 0
+        index2 = 0
+        while True:
+            char1, index1 = self.select(s1, index1)
+            char2, index2 = self.select(s2, index2)
+            if char1 != char2:
+                self.fail('%s != %s' % (self.cursor(s1, index1), self.cursor(s2, index2)))
+            if not char1 or not char2:
+                break
+
+
+    def send(self, host, port, message):
+        sok = socket()
+        sok.connect((host, port))
+        sok.sendall(message)
+        return sok
+
+    def httpGet(self, host, port, path):
+        return self.send(host, port, 'GET %(path)s HTTP/1.0\r\n\r\n' % locals())
+
+    def httpPost(self, host='localhost', port=None, path='/', data='', contentType='text/plain'):
+        return self.send(host, port or self.port,
+            'POST %s HTTP/1.0\r\n' % path +
+            'Content-Type: %s; charset=\"utf-8\"\r\n' % contentType +
+            'Content-Length: %s\r\n' % len(data) +
+            '\r\n' +
+            data)
+
+    @contextmanager
+    def loopingReactor(self, timeOutInSec = 3):
+        blockEnd = False
+        timerHasFired = []
+        def timeOut():
+            timerHasFired.append(True)
+        timer = self.reactor.addTimer(timeOutInSec, timeOut)
+        def loop():
+            while not(timerHasFired or blockEnd):
+                t = self.reactor.addTimer(0.01, lambda: None)
+                try:
+                    self.reactor.step()
+                finally:
+                    try: self.reactor.removeTimer(t)
+                    except ValueError: pass
+        thread = Thread(None, loop)
+        thread.start()
+        try:
+            yield
+        finally:
+            blockEnd = True
+            assert not timerHasFired
+            self.reactor.removeTimer(timer)
+            thread.join()
+
+    @contextmanager
+    def stderr_replaced(self):
+        oldstderr = sys.stderr
+        mockStderr = StringIO()
+        sys.stderr = mockStderr
+        try:
+            yield mockStderr
+        finally:
+            sys.stderr = oldstderr
+
+    @contextmanager
+    def stdout_replaced(self):
+        oldstdout = sys.stdout
+        mockStdout = StringIO()
+        sys.stdout = mockStdout
+        try:
+            yield mockStdout
+        finally:
+            sys.stdout = oldstdout
+
+class MatchAll(object):
+    def __eq__(self, other):
+        return True
+    def __ne__(self, other):
+        return False
+    def __repr__(self):
+        return '*MatchAll*'
+
+MATCHALL = MatchAll()
diff --unidirectional-new-file '--exclude=*.so' '--exclude=*.o' '--exclude=.svn' '--exclude=*.pyc' '--exclude=deps.d' '--exclude=applied' --recursive --unified version_0/weightless/core/compose/_compose.c version_0-merge-trunk/weightless/core/compose/_compose.c
--- version_0/weightless/core/compose/_compose.c	2011-06-21 09:47:06.000000000 +0200
+++ version_0-merge-trunk/weightless/core/compose/_compose.c	2011-06-21 09:50:48.000000000 +0200
@@ -384,7 +384,20 @@
         return NULL;
     }
 
-    PyErr_SetNone(PyExc_StopIteration);
+    // if any messages are left, 'return' them by StopIteration
+    int n = _messages_size(self);
+    if (n) {
+        PyObject* args = PyTuple_New(n); // new ref
+        int i;
+        for (i = 0; i < n; i++) {
+            PyTuple_SetItem(args, i, messages_next(self)); // steals ref
+        }
+        PyObject* sie = PyObject_Call(PyExc_StopIteration, args, NULL); // new ref
+        PyErr_SetObject(PyExc_StopIteration, sie);
+        Py_DECREF(sie);
+        Py_DECREF(args);
+    } else
+        PyErr_SetNone(PyExc_StopIteration);
     return NULL;
 }
 
@@ -410,10 +423,7 @@
         return NULL;
     }
 
-    messages_append(self, message);
-
-    if(!self->expect_data && self->messages_start[0] != Py_None)
-        messages_insert(self, Py_None);
+    messages_insert(self, message);
 
     return _compose_go_with_frame(self, NULL, NULL, NULL);
 }
diff --unidirectional-new-file '--exclude=*.so' '--exclude=*.o' '--exclude=.svn' '--exclude=*.pyc' '--exclude=deps.d' '--exclude=applied' --recursive --unified version_0/weightless/core/compose/_compose_py.py version_0-merge-trunk/weightless/core/compose/_compose_py.py
--- version_0/weightless/core/compose/_compose_py.py	2011-06-21 09:47:06.000000000 +0200
+++ version_0-merge-trunk/weightless/core/compose/_compose_py.py	2011-06-21 09:51:00.000000000 +0200
@@ -109,9 +109,7 @@
                 try:
                     message = yield response
                     assert not (message and response), 'Cannot accept data. First send None.'
-                    messages.append(message)
-                    if response and messages[0] is not None:
-                        messages.insert(0, None)
+                    messages.insert(0,message)
                 except BaseException:
                     exception = exc_info()
         except StopIteration, returnValue:
diff --unidirectional-new-file '--exclude=*.so' '--exclude=*.o' '--exclude=.svn' '--exclude=*.pyc' '--exclude=deps.d' '--exclude=applied' --recursive --unified version_0/weightless/core/__init__.py version_0-merge-trunk/weightless/core/__init__.py
--- version_0/weightless/core/__init__.py	2011-06-21 09:47:06.000000000 +0200
+++ version_0-merge-trunk/weightless/core/__init__.py	2011-06-21 10:45:09.000000000 +0200
@@ -22,7 +22,9 @@
 #
 ## end license ##
 
-VERSION='$Version: 0.4.x$'[9:-1].strip() # Modified by package scripts
+VERSION='$Version: 0.5.x$'[9:-1].strip() # Modified by package scripts
 
 from compose import compose, local, tostring
 from utils import identify, autostart
+
+from _observable import Observable, Transparant, be
diff --unidirectional-new-file '--exclude=*.so' '--exclude=*.o' '--exclude=.svn' '--exclude=*.pyc' '--exclude=deps.d' '--exclude=applied' --recursive --unified version_0/weightless/core/_observable.py version_0-merge-trunk/weightless/core/_observable.py
--- version_0/weightless/core/_observable.py	1970-01-01 01:00:00.000000000 +0100
+++ version_0-merge-trunk/weightless/core/_observable.py	2011-06-18 10:54:42.000000000 +0200
@@ -0,0 +1,210 @@
+# -*- coding: utf-8 -*-
+## begin license ##
+#
+#    Weightless is a High Performance Asynchronous Networking Library
+#    Copyright (C) 2006-2009 Seek You Too (CQ2) http://www.cq2.nl
+#
+#    This file is part of Weightless
+#
+#    Weightless is free software; you can redistribute it and/or modify
+#    it under the terms of the GNU General Public License as published by
+#    the Free Software Foundation; either version 2 of the License, or
+#    (at your option) any later version.
+#
+#    Weightless is distributed in the hope that it will be useful,
+#    but WITHOUT ANY WARRANTY; without even the implied warranty of
+#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+#    GNU General Public License for more details.
+#
+#    You should have received a copy of the GNU General Public License
+#    along with Weightless; if not, write to the Free Software
+#    Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+#
+## end license ##
+
+from sys import exc_info
+from weightless.core import local, compose
+
+class Defer(object):
+    def __init__(self, observers, defereeType):
+        self._observers = observers
+        self._defereeType = defereeType
+
+    def __getattr__(self, attr):
+        return self._defereeType(self._observers, attr)
+
+    def __getitem__(self, target):
+        return Defer([o for o in self._observers if hasattr(o, "observable_name") and o.observable_name() == target], self._defereeType)
+
+    def unknown(self, message, *args, **kwargs):
+        try:
+            return getattr(self, message)(*args, **kwargs)
+        except:
+            exType, exValue, exTraceback = exc_info()
+            raise exType, exValue, exTraceback.tb_next # skip myself from traceback
+
+class DeferredMessage(object):
+    def __init__(self, observers, message):
+        self._observers = observers
+        self._message = message
+
+    def __call__(self, *args, **kwargs):
+        return self._gatherResponses(*args, **kwargs)
+
+    def _gatherResponses(self, *args, **kwargs):
+        try:
+            for observer in self._observers:
+                if hasattr(observer, self._message):
+                    try:
+                        yield getattr(observer, self._message)(*args, **kwargs)
+                    except:
+                        exType, exValue, exTraceback = exc_info()
+                        raise exType, exValue, exTraceback.tb_next # skip myself from traceback
+                elif hasattr(observer, 'unknown'):
+                    try:
+                        responses = getattr(observer, 'unknown')(self._message, *args, **kwargs)
+                    except TypeError, e:
+                        raise TypeError(str(e) + ' on ' + str(observer))
+                    if responses:
+                        try:
+                            __callstack__ = [responses] # for finding locals
+                            for response in responses:
+                                yield response
+                        except:
+                            exType, exValue, exTraceback = exc_info()
+                            raise exType, exValue, exTraceback.tb_next # skip myself from traceback
+        finally: # avoid cycles, see http://www.python.org/dev/peps/pep-0342/
+            del self, args, kwargs # really, there's tests for it!
+
+class AllMessage(DeferredMessage):
+    def __call__(self, *args, **kwargs):
+        return self._gatherResponses(*args, **kwargs)
+
+class AnyMessage(DeferredMessage):
+    def __call__(self, *args, **kwargs):
+        g = DeferredMessage.__call__(self, *args, **kwargs)
+        try:
+            for answer in g:
+                if answer != None:
+                    return answer
+            else:
+                raise AttributeError('None of the %d observers responds to any.%s(...)' % (len(self._observers), self._message))
+        except:
+            exType, exValue, exTraceback = exc_info()
+            raise exType, exValue, exTraceback.tb_next # skip myself from traceback
+        finally:
+            del g
+            g = None
+
+class DoMessage(DeferredMessage):
+    def __call__(self, *args, **kwargs):
+        try:
+            for ignore in DeferredMessage.__call__(self, *args, **kwargs):
+                pass
+        except:
+            exType, exValue, exTraceback = exc_info()
+            raise exType, exValue, exTraceback.tb_next # skip myself from traceback
+
+class AsyncdoMessage(DeferredMessage):
+    def __call__(self, *args, **kwargs):
+        try:
+            for value in compose(DeferredMessage.__call__(self, *args, **kwargs)):
+                if callable(value):
+                    yield value
+        except:
+            exType, exValue, exTraceback = exc_info()
+            raise exType, exValue, exTraceback.tb_next # skip myself from traceback
+
+class AsyncanyMessage(DeferredMessage):
+    def __call__(self, *args, **kwargs):
+        try:
+            result = DeferredMessage.__call__(self, *args, **kwargs)
+            m = None
+            while True:
+                r = result.send(m) 
+                m = yield r
+                if not callable(m):
+                    raise StopIteration(m)
+        except StopIteration, e:
+            if e.args:
+                raise
+            raise AttributeError('None of the %d observers responds to asyncany.%s(...)' % (len(self._observers), self._message))
+
+class OnceMessage(DeferredMessage):
+    def __call__(self, *args, **kwargs):
+        done = set()
+        return self._callonce(self._observers, args, kwargs, done)
+
+    def _callonce(self, observers, args, kwargs, done):
+        for observer in observers:
+            if observer not in done:
+                done.add(observer)
+                if hasattr(observer, self._message):
+                    getattr(observer, self._message)(*args, **kwargs)
+                if isinstance(observer, Observable):
+                    self._callonce(observer._observers, args, kwargs, done)
+
+def be(strand):
+    helicesDone = set()
+    return _beRecursive(strand, helicesDone)
+
+def _beRecursive(helix, helicesDone):
+    if callable(helix):
+        helix = helix(helicesDone)
+    component = helix[0]
+    strand = helix[1:]
+    if not helix in helicesDone and strand:
+        component.addStrand(strand, helicesDone)
+        helicesDone.add(helix)
+    return component
+
+class Context(object):
+    def __getattr__(self, name):
+        try:
+            return local('__callstack_var_%s__' % name)
+        except AttributeError:
+            raise AttributeError("'%s' has no attribute '%s'" % (self, name))
+
+class Observable(object):
+    def __init__(self, name = None):
+        self._observers = []
+        self.all = Defer(self._observers, AllMessage)
+        self.any = Defer(self._observers, AnyMessage)
+        self.do = Defer(self._observers, DoMessage)
+        self.asyncdo = Defer(self._observers, AsyncdoMessage)
+        self.asyncany = Defer(self._observers, AsyncanyMessage)
+        self.once = Defer(self._observers, OnceMessage)
+        self._name = name
+
+        self.ctx = Context()
+    
+    def observable_name(self):
+        return self._name
+
+    def observable_setName(self, name):
+        self._name = name
+        return self
+
+    def addObserver(self, observer):
+        self._observers.append(observer)
+
+    def addStrand(self, strand, helicesDone):
+        for helix in strand:
+            self.addObserver(_beRecursive(helix, helicesDone))
+
+    def printTree(self, depth=0):
+        def printInColor(ident, color, text):
+            print ' '*ident, chr(27)+"[0;" + str(color) + "m", text, chr(27)+"[0m"
+        print ' ' * depth, self.__repr__()
+        for observer in self._observers:
+            if hasattr(observer, 'printTree'):
+                observer.printTree(depth=depth+1)
+            else:
+                printInColor(depth+1, 31, observer)
+
+    def __repr__(self):
+        return "%s(name=%s)" % (self.__class__.__name__, repr(self._name))
+
+class Transparant(Observable):
+    def unknown(self, message, *args, **kwargs):
+        return self.all.unknown(message, *args, **kwargs)
diff --unidirectional-new-file '--exclude=*.so' '--exclude=*.o' '--exclude=.svn' '--exclude=*.pyc' '--exclude=deps.d' '--exclude=applied' --recursive --unified version_0/weightless/examples/callbacksvsgenerator.py version_0-merge-trunk/weightless/examples/callbacksvsgenerator.py
--- version_0/weightless/examples/callbacksvsgenerator.py	1970-01-01 01:00:00.000000000 +0100
+++ version_0-merge-trunk/weightless/examples/callbacksvsgenerator.py	2011-06-23 18:24:38.000000000 +0200
@@ -0,0 +1,104 @@
+from unittest import TestCase, main
+from weightless.core import compose
+from weightless.core.utils import autostart
+
+""" This code demonstrated the difficulties with callbacks and showed a simpler implementation with a generator.  Most of the value is in the dynamics of writing the code, not in staring at the end-result.  If you want to get the full value of it, throw away the code, start with implementing the first test, see how relatively simple the code is, then watch what you need to do in order to let the second test (which breaks the header in two messages) succeed: how complicated the callback based handler becomes.
+Then proceed to the generatorBasedHTTPHandler() and see how this is a simple lineair piece of code, and how it remains lineair and simple while fixing it for making the second test (with a broken-up heade) succeed.
+As a third step, the code for joining multiple network buffers into one buffer (readUntilEOL) is extracted into a separate generator, which can only be 'included' if you use @compose.
+
+The example deals with data from a network and turn it into a simple HTTP call such as handle(method, type, body)"""
+
+class CallBackBasedHTTPHandler(object):
+
+    def __init__(self, handler):
+        self._handler = handler
+        self._method = None
+        self._fragment = ''
+        self._expected = 'POST'
+
+    def send(self, data):
+        if data.startswith(self._expected) and not self._method:
+            self._method = data[:4]
+            self._expected = 'Content-Type'
+        elif data.startswith(self._expected) and self._method:
+            self._fragment += data
+            while not self._fragment.endswith('\r\n'):
+                self._expected = ''
+                return
+            self._contenttype = self._fragment.split(': ')[1].strip()
+            self._expected = '\r\n'
+        elif data.startswith('\r\n'):
+            self._expected = ''
+        else:
+            self._body = data
+            self._handler(self._method, self._contenttype, self._body)
+
+@autostart
+@compose
+def generatorBasedHTTPHandler(handler):
+    request = yield
+    method = request[:4]
+    header = yield readUntilEOL()
+    contenttype = header.split(': ')[1].strip()
+    eoh = yield
+    body = yield
+    handler(method, contenttype, body)
+    yield
+
+def readUntilEOL():
+    fragment = yield
+    while not fragment.endswith('\r\n'):
+        fragment += (yield)
+    raise StopIteration(fragment)
+
+
+class CallbackTest(TestCase):
+    """ the tests are in reverse order """
+
+    def testGeneratorWithBrokenUpHeader(self):
+        result = []
+        def httphandler(*args):
+            result.extend(args)
+        handler = generatorBasedHTTPHandler(httphandler)
+        handler.send('POST / HTTP/1.0\r\n')
+        handler.send('Content-Type: te')  # break header
+        handler.send('xt/plain\r\n')
+        handler.send('\r\n')
+        handler.send('Hello Pythons!')
+        self.assertEquals(['POST', 'text/plain', 'Hello Pythons!'], result)
+
+    def testGenerator(self):
+        result = []
+        def httphandler(*args):
+            result.extend(args)
+        handler = generatorBasedHTTPHandler(httphandler)
+        handler.send('POST / HTTP/1.0\r\n')
+        handler.send('Content-Type: text/plain\r\n')
+        handler.send('\r\n')
+        handler.send('Hello Pythons!')
+        self.assertEquals(['POST', 'text/plain', 'Hello Pythons!'], result)
+
+    def testCallbacksWithBrokenUpHeader(self):
+        result = []
+        def httphandler(*args):
+            result.extend(args)
+        handler = CallBackBasedHTTPHandler(httphandler)
+        handler.send('POST / HTTP/1.0\r\n')
+        handler.send('Content-Type: te')  # break header
+        handler.send('xt/plain\r\n')
+        handler.send('\r\n')
+        handler.send('Hello Pythons!')
+        self.assertEquals(['POST', 'text/plain', 'Hello Pythons!'], result)
+
+    def testCallbacks(self):
+        result = []
+        def httphandler(*args):
+            result.extend(args)
+        handler = CallBackBasedHTTPHandler(httphandler)
+        handler.send('POST / HTTP/1.0\r\n')
+        handler.send('Content-Type: text/plain\r\n')
+        handler.send('\r\n')
+        handler.send('Hello Pythons!')
+        self.assertEquals(['POST', 'text/plain', 'Hello Pythons!'], result)
+
+main()
diff --unidirectional-new-file '--exclude=*.so' '--exclude=*.o' '--exclude=.svn' '--exclude=*.pyc' '--exclude=deps.d' '--exclude=applied' --recursive --unified version_0/weightless/examples/decomposition.py version_0-merge-trunk/weightless/examples/decomposition.py
--- version_0/weightless/examples/decomposition.py	1970-01-01 01:00:00.000000000 +0100
+++ version_0-merge-trunk/weightless/examples/decomposition.py	2011-06-23 18:24:54.000000000 +0200
@@ -0,0 +1,73 @@
+from weightless.core import compose
+
+print """ 1. calling generators """
+def f():
+    yield 'No'
+    yield g()
+    yield 'here'
+
+def g():
+    yield 'PUN'
+
+
+p = f()
+
+print p.next()
+print p.next() #?
+print p.next()
+
+p = compose(f())
+
+print p.next()
+print p.next()
+print p.next()
+
+
+print """ 2. Catching exceptions """
+
+def f():
+    try:
+        yield g()
+    except ZeroDivisionError:
+        yield 'Oops'
+
+def g():
+    yield 1/0 # oops
+
+p = f()
+
+print p.next()
+
+p = compose(f())
+
+print p.next()
+
+
+print """ 3. fixing Stack Traces """
+
+def f():
+    yield g()
+def g():
+    yield h()
+def h():
+    yield 1/0 # Oops
+
+# Trace: main -> f() -> g() -> h()
+
+# Without tbtools: remove the tbtools symlink
+p = compose(f())
+
+print p.next()
+def f():
+    yield g()
+
+def g():
+    yield h()
+
+def h():
+    yield 1/0
+
+
+p = compose(f())
+
+p.next()
diff --unidirectional-new-file '--exclude=*.so' '--exclude=*.o' '--exclude=.svn' '--exclude=*.pyc' '--exclude=deps.d' '--exclude=applied' --recursive --unified version_0/weightless/examples/ep2011.py version_0-merge-trunk/weightless/examples/ep2011.py
--- version_0/weightless/examples/ep2011.py	1970-01-01 01:00:00.000000000 +0100
+++ version_0-merge-trunk/weightless/examples/ep2011.py	2011-06-23 10:54:42.000000000 +0200
@@ -0,0 +1,751 @@
+#!/usr/bin/env python
+# -*- coding: utf-8 -*-
+import sys
+sys.path.insert(0, "./weightless-trunk")
+from os import environ, system
+from traceback import print_exc
+from inspect import isfunction
+#environ['WEIGHTLESS_COMPOSE_TEST'] = 'PYTHON'
+from weightless.core import compose, local
+ok = lambda *args, **kwargs: True
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+#1
+
+
+
+
+
+
+
+def Beyond_Python_Enhanced_Generators():
+    conference  = "EuroPython"
+    date        = 2011-06-23
+    location    = "Florence, Italy"
+    presenter   = "Erik J. Groeneveld"
+    affiliation = "Seecr"
+    email       = "erik@seecr.nl"
+    moreinfo    = "weightless.io/compose"
+
+    while True:
+        listen()
+        speak()
+
+
+
+
+
+
+#2
+
+def pep342():
+    """Enhanced Generator"""
+    msg = yield "response"
+    print msg
+    yield
+
+
+def demo_driver():
+    """the most profound change ever"""
+    g = pep342()
+    response = g.next()   #1
+    g.send("msg")         #2
+
+
+
+
+
+
+
+
+
+
+
+
+#3
+
+def pep380():
+    """Delegating to Subgenerator"""
+    def f():
+        yield "response"
+    def g():
+        yield from_f()
+    for r in g():
+        print r
+
+
+def demo_ala_compose():
+    """Delegation with Compose"""
+    def f():
+        yield "Hello"
+        msg = yield None
+    def g():
+        yield f()         #1
+    for r in compose(g()):#2
+        print r
+
+
+
+
+
+#4
+
+def demo_compose_decorator():
+    """Compose as decorator"""
+    def f():
+        yield "Hello"
+        msg = yield
+    @compose              #1
+    def g():
+        yield f()         #2
+    for r in g():         #3
+        print r
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+#5
+
+def demo_propagation():
+    """Compose at top level only"""
+    def f():
+        yield "I am f"
+    def g():
+        yield f()
+    def h():
+        yield g()
+    for m in compose(h()):
+        print m
+
+
+
+
+
+"""
+    yielded generator
+        replaces it parent
+"""
+
+
+
+
+
+#6
+
+def demo_two_way():
+    """Communicate both ways"""
+    def f():              #2
+        msg = yield       #4
+        yield msg
+    def g():
+        yield f()
+    p = compose(g())
+    print p.next()        #1
+    print p.send("hello") #3
+
+
+
+
+"""
+    At #3 the message returns 
+    immediately, as if #4 were:
+
+    def f(msg):
+        return msg
+"""        
+
+
+
+#7
+
+def demo_alternative():
+    """Use of None"""
+    def f():
+        msg = None
+        while True:
+           msg = yield msg #1
+    def g():
+        yield f()
+    p = compose(g())
+    print p.send(None)     #2
+    print p.send("Hello")
+
+
+
+
+
+
+
+
+
+
+
+
+
+#8
+
+def demo_handle_exceptions():
+    """Exceptions in subgenerators"""
+    def f():
+        raise Exception("8-;")
+        yield
+    @compose
+    def g():
+        try:                    
+            yield f()           #1
+        except Exception, e:    #2
+            yield e
+    print g().next()
+
+
+
+
+
+
+
+
+
+
+
+
+#9
+
+def demo_tb():
+    """Show generators on Trace"""
+    def f():
+        raise Exception(";-(")
+        yield
+    def g():
+        yield f()
+    @compose
+    def h():
+        yield g()
+    try: h().next()
+    except: print_exc()
+"""
+Traceback (most recent call last):
+  File "./ep.py", line 246, in demo_tb
+    try: h().next()
+  File "./ep.py", line 245, in h
+    yield g()
+  File "./ep.py", line 242, in g
+    yield f()
+  File "./ep.py", line 239, in f
+    raise Exception(";-(")
+Exception: ;-(
+"""
+#10
+
+def demo_return_value():
+    """'call' a generator"""
+    def f():
+        raise StopIteration("val") #1
+        #return "retval"           #2 
+        yield
+    @compose
+    def g():
+        v = yield f()
+        yield v
+    print g().next()
+
+
+#Jackson Structured Programming
+#Program structure = Data structure
+#Interleaving clashes
+#Ordering clashes
+#Boundary clashes
+#Recognition difficulties
+#Program inversion
+#Avoid buffering
+#Web-servers
+
+
+#11
+
+def demo_coroutine():
+    """coroutine a la COBOL"""
+    def coroutine_a(n = 0):
+        while n < 10:
+            n = yield b, n + 1
+            print ">", n
+    def coroutine_b(n = 0):
+        while n < 10:
+            n = yield a, n + 1
+            print "<", n
+    a = coroutine_a()
+    b = coroutine_b()
+    a.next(); b.next()
+    g = (a, 0)
+    while True: # trampoline
+       try: g = g[0].send(g[1])
+       except: break
+
+
+
+
+
+
+
+#12
+
+def demo_coroutine_with_inversion():
+    """Limited scope/lifetime"""
+    def coroutine_a(n = 0):
+        yield                       #1
+        print ">", n
+        raise StopIteration(n + 1)
+    def coroutine_b(n = 0):
+        while n < 10:
+            n = yield coroutine_a(n + 1)
+            print "<", n
+    g = compose(coroutine_b())
+    list(g)
+
+
+
+
+
+
+
+
+
+
+
+
+#13
+
+def socket_driver1(sok, gen):
+    """Naive Socket Driver"""
+    msg = None
+    while True:
+        res = gen.send(msg)
+        sok.send(resp)
+        msg = sok.recv()
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+#14
+
+def socket_driver(sok, prot):
+    """Protocol controls flow"""
+    res = prot.next()               #1
+    while True:
+        if res:                     #2
+            sok.send(res)
+            res = prot.next()
+        else:
+            msg = sok.recv()        #3
+            res = prot.send(msg)
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+#15
+
+def http_protocol():
+    """naive protocol"""
+    request = yield
+    yield "HTTP/1.1 200 Ok\r\n\r\n"
+    yield "<table><tr>"
+    for i in range(3):
+        yield "<td>%d></td>" % i
+    yield "</tr></table"
+
+
+def demo_http_protocol():
+    """Test naive http implementation"""
+    p = http_protocol()
+    p.next()
+    p.send("HTTP/1.0 GET /\r\n\r\n")
+    for l in p:
+        print l
+
+
+
+
+
+
+
+#16
+
+@compose
+def http_protocol2(handler):
+    """Separation of concerns"""
+    req, hdrs = yield readRequest() #1
+    yield handler(req, hdrs)        #2
+
+
+def readRequest():
+    """More refactoring (parsing)"""
+    reql = yield read_req_line()
+    hdrs = yield read_headers()
+    raise StopIteration([reql, hdrs])
+
+
+
+
+
+
+
+
+
+
+
+
+#17
+
+def read_req_line():
+    """Push back superfluous data"""
+    msg = ''
+    while not '\r\n' in msg:
+        msg += yield
+    req, tail = msg.split('\r\n',1)    #1
+    raise StopIteration(req, tail)     #2
+
+
+def demo_read_request_line():
+    """Demo Boundary Clash"""
+    r = compose(read_req_line())
+    try:
+      r.next()
+      print r.send("GET /docs HT")
+      print r.send("TP/1.0\r\nHost: pyt")
+      print r.send("hon.org\r\n\r\n")
+    except StopIteration, e:
+      print e.args
+
+
+
+
+
+#18
+
+"""
+    Boundary Clashes
+    TCP packets 
+        != HTTP chunks
+            != XML tags
+
+    What happens with 'tail'?
+
+    General case:
+    raise StopIteration(
+        retval, token0, ..., tokenn)
+"""
+
+
+
+
+
+
+
+
+
+
+
+
+#19
+
+def read_headers():
+    msg = ''
+    while not '\r\n\r\n' in msg:
+        msg += yield
+    result = msg.split('\r\n\r\n')
+    raise StopIteration(*result)
+
+
+def demo_read_request():
+    """a real world example"""
+    r = compose(readRequest())
+    r.next()
+    try:
+        r.send("GET /docs HT")
+        r.send("TP/1.0\r\nHost: pytho")
+        r.send("n.org\r\n\r\nFORM data")
+    except StopIteration, e:
+        print e.args # nested tuple
+
+
+
+
+
+
+#20
+
+def handleRequest(req, headers):
+    msg = ''
+    try:
+        while True:
+            msg += yield
+    except StopIteration:
+        print "BODY:", msg
+        yield 'HTTP/1.0 200 Ok\r\n\r\n'
+
+
+def demo_complete_protocol():
+    """three levels of delegation"""
+    p = http_protocol2(handleRequest)
+    p.next()
+    p.send("GET /docs HT")
+    p.send("TP/1.0\r\nHost: pytho")
+    p.send("n.org\r\n\r\nFORM data")
+    print p.throw(StopIteration)
+
+
+
+
+
+
+#21
+
+"""
+    It would be highly unpractical
+    to have to deal with push backs
+    at every delegation.
+
+    ==> let compose do it
+"""
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+#22
+
+def handler_rev(req, headers):
+    """Flow control"""
+    yield 'HTTP/1.0 200 Ok\r\n\r\n'    #1
+    msg = ''
+    try:
+        while True:
+            msg += yield               #2
+    except StopIteration:
+        print "BODY:", msg
+
+def demo_complete_protocol_2():
+    """A handler with different flow"""
+    p = http_protocol2(handler_rev)
+    print 1, p.send(None)
+    print 2, p.send("GET /docs HT")
+    print 3, p.send("TP/1.0\r\nHost: pyt")
+    print 4, p.send("hon.org\r\n\r\nFORM")
+    print 5, p.next()
+    print 6, p.send("data")
+    try: print 7, p.throw(StopIteration)
+    except StopIteration: pass
+
+
+
+#23
+
+def Fragment_from_compose():
+    if response or not messages:
+      message = yield response
+      assert not (message and response),\
+            'Cannot accept data.' + \
+            'First send None.'
+      messages.insert(0,message)
+    #...
+    try:
+      pass # ...
+    except StopIteration, retval:
+      generators.pop()
+      if retval.args:
+        messages = list(retval.args) \
+                 + messages
+      else:
+        messages.insert(0, None)
+
+
+
+
+
+
+
+#24
+
+def a_template():
+    yield """
+        <html><body>
+            <table><tr>"""
+    for i in range(3):
+        yield """
+                <td>%d></td>""" % i
+    yield """
+            </tr></table>
+        <html><body>"""
+
+
+def demo_flow_control():
+    """a driver with flow control"""
+    msgs = iter(['GET /','GET /en'])
+    template = a_template()
+    m = None
+    try:
+        while True:
+            r = template.send(m)
+            m = None if r else msgs.next()
+            print r,
+    except StopIteration: pass
+
+#25
+
+def a_template_2():
+    print (yield """
+        <html><body>
+          <table><tr>""")
+    for i in range(3):
+        print (yield """
+            <td>%d></td>""" % i)
+    print (yield """
+          </tr></table>
+        <html><body>
+        """)
+
+
+def demo_flow_control_2():
+    """driver without flow control"""
+    msgs = iter([None,'GET /','GET /en'])
+    template = a_template()
+    while True:
+        print template.send(msgs.next())
+
+
+
+
+
+#26
+
+def demo_what_about_thread_local():
+    """Cross cutting concerns:
+        Transactions, security, logging"""
+    def f():
+        tx_id = "ID:392123"     #1
+        yield g()
+    def g():
+        yield h()
+    def h():
+        tx_id = local("tx_id")  #2
+        print tx_id
+    list(compose(f()))
+
+
+
+
+
+
+
+
+
+
+
+
+#27
+
+"""
+    Topics for discussion:
+    1. back traces?
+    2. flow control?
+    3. look ahead, push back?
+    4. generator locals
+"""
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+#28
+
+funcs = (f for f in locals().values() if 
+        isfunction(f) and f.__code__.co_name.startswith("demo"))
+
+if len(sys.argv) > 1:
+    funcs = (f for f in funcs if f.__code__.co_name in sys.argv)
+
+system('clear')
+
+for f in sorted(funcs, key=lambda k: k.__code__.co_firstlineno):
+    print "\n* %s()\n* %s" % (f.__code__.co_name, f.func_doc)
+    try: f() # run def demo_*():
+    except: print_exc()
+
+
+
+
+
+
+
+
+
+#end
diff --unidirectional-new-file '--exclude=*.so' '--exclude=*.o' '--exclude=.svn' '--exclude=*.pyc' '--exclude=deps.d' '--exclude=applied' --recursive --unified version_0/weightless/examples/fixtraceback.py version_0-merge-trunk/weightless/examples/fixtraceback.py
--- version_0/weightless/examples/fixtraceback.py	1970-01-01 01:00:00.000000000 +0100
+++ version_0-merge-trunk/weightless/examples/fixtraceback.py	2011-06-23 18:25:04.000000000 +0200
@@ -0,0 +1,35 @@
+## begin license ##
+#
+#    Weightless is a High Performance Asynchronous Networking Library
+#    Copyright (C) 2006-2008 Seek You Too (CQ2) http://www.cq2.nl
+#
+#    This file is part of Weightless
+#
+#    Weightless is free software; you can redistribute it and/or modify
+#    it under the terms of the GNU General Public License as published by
+#    the Free Software Foundation; either version 2 of the License, or
+#    (at your option) any later version.
+#
+#    Weightless is distributed in the hope that it will be useful,
+#    but WITHOUT ANY WARRANTY; without even the implied warranty of
+#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+#    GNU General Public License for more details.
+#
+#    You should have received a copy of the GNU General Public License
+#    along with Weightless; if not, write to the Free Software
+#    Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+#
+## end license ##
+
+from weightless.core import compose
+
+def a():
+	yield b()
+def b():
+	yield c()
+def c():
+	yield 'a'
+	raise Exception('b')
+
+list(compose(a()))
+
diff --unidirectional-new-file '--exclude=*.so' '--exclude=*.o' '--exclude=.svn' '--exclude=*.pyc' '--exclude=deps.d' '--exclude=applied' --recursive --unified version_0/weightless/examples/httpserver.py version_0-merge-trunk/weightless/examples/httpserver.py
--- version_0/weightless/examples/httpserver.py	1970-01-01 01:00:00.000000000 +0100
+++ version_0-merge-trunk/weightless/examples/httpserver.py	2011-06-23 18:25:13.000000000 +0200
@@ -0,0 +1,23 @@
+#!/usr/bin/env python
+
+from weightless.core import be 
+from weightless.io import Reactor, Server
+from weightless.httpng import HttpProtocol, http
+
+class HelloWorld(object):
+    def processRequest(self, *args, **kwargs):
+        yield http.ok()
+        yield http.headers('Content-Length', 6)
+        yield 'Hello!'
+
+reactor = Reactor()
+
+dna = \
+    (Server(reactor, 8080),
+        (HttpProtocol(),
+            (HelloWorld(),)
+        )
+    )
+
+server = be(dna)
+reactor.loop()
diff --unidirectional-new-file '--exclude=*.so' '--exclude=*.o' '--exclude=.svn' '--exclude=*.pyc' '--exclude=deps.d' '--exclude=applied' --recursive --unified version_0/weightless/examples/postform.html version_0-merge-trunk/weightless/examples/postform.html
--- version_0/weightless/examples/postform.html	1970-01-01 01:00:00.000000000 +0100
+++ version_0-merge-trunk/weightless/examples/postform.html	2011-02-12 11:50:46.000000000 +0100
@@ -0,0 +1,6 @@
+<form action="http://localhost:8080" method="post">
+
+    <input type="text" value="avalue"/>
+    <input type="submit" value="submit"/>
+
+</form>
\ No newline at end of file
diff --unidirectional-new-file '--exclude=*.so' '--exclude=*.o' '--exclude=.svn' '--exclude=*.pyc' '--exclude=deps.d' '--exclude=applied' --recursive --unified version_0/weightless/examples/testautodecorate.py version_0-merge-trunk/weightless/examples/testautodecorate.py
--- version_0/weightless/examples/testautodecorate.py	1970-01-01 01:00:00.000000000 +0100
+++ version_0-merge-trunk/weightless/examples/testautodecorate.py	2011-02-12 11:50:46.000000000 +0100
@@ -0,0 +1,21 @@
+from types import GeneratorType, FunctionType
+
+def decorator(generatorOrFunction):
+    if type(generatorOrFunction) == GeneratorType:
+        print "composing"
+        return generatorOrFunction
+    elif type(generatorOrFunction) == FunctionType:
+        print "decorating"
+        return generatorOrFunction
+    else:
+        print "error"
+
+class A(object):
+    @decorator
+    def f(self):
+        yield
+
+g0 = A().f()
+g1 = decorator(A().f())
+
+
diff --unidirectional-new-file '--exclude=*.so' '--exclude=*.o' '--exclude=.svn' '--exclude=*.pyc' '--exclude=deps.d' '--exclude=applied' --recursive --unified version_0/weightless/examples/util.py version_0-merge-trunk/weightless/examples/util.py
--- version_0/weightless/examples/util.py	1970-01-01 01:00:00.000000000 +0100
+++ version_0-merge-trunk/weightless/examples/util.py	2011-06-23 18:30:06.000000000 +0200
@@ -0,0 +1,15 @@
+from _compose import compose as compose_raw
+
+""" some decorators for dealing with generators"""
+
+def compose(generator):
+    def helper(*args, **kwargs):
+        return compose_raw(generator(*args, **kwargs))
+    return helper
+
+def autostart(generator):
+    def helper(*args, **kwargs):
+        g = generator(*args, **kwargs)
+        g.next()
+        return g
+    return helper
diff --unidirectional-new-file '--exclude=*.so' '--exclude=*.o' '--exclude=.svn' '--exclude=*.pyc' '--exclude=deps.d' '--exclude=applied' --recursive --unified version_0/weightless/examples/wordlengthstest.py version_0-merge-trunk/weightless/examples/wordlengthstest.py
--- version_0/weightless/examples/wordlengthstest.py	1970-01-01 01:00:00.000000000 +0100
+++ version_0-merge-trunk/weightless/examples/wordlengthstest.py	2011-06-23 18:25:24.000000000 +0200
@@ -0,0 +1,135 @@
+from unittest import TestCase, main
+
+from weightless.core.utils import autostart
+
+""" This code demonstrates the use of generators in Python.
+It has been life coded on conferences SPA2008, AgileOpen2008 and the
+Dutch Python day on October 4th, 2008.  The implementations below are in
+order of increasing complexity, the tests are in reverse order!"""
+
+def wordLengths1(words):
+    """ implementation with lists for both input and output """
+    result = []
+    for word in words:
+        result.append(len(word))
+    return result
+
+def wordLengths1_alternative(words):
+    """ one could use list comprehension as well """
+    return [len(word) for word in words]
+
+def wordLengths2(words):
+    """ implementation with list as input and generator as output """
+    for word in words:
+        yield len(word)
+
+def wordLengths2_alternative(words):
+    """ one could use a generator expression as well """
+    return (len(word) for word in words)
+
+@autostart
+def wordLengths3():
+    """ implementation with generator for both input and output """
+    length = None
+    while True:
+        word = yield length
+        length = len(word)
+
+@autostart
+def wordLengths4():
+    """ a generator stops with StopIteration exception, which can be catched """
+    length = None
+    while True:
+        try:
+            word = yield length
+        except StopIteration:
+            yield 'done'
+            return
+        length = len(word)
+
+@autostart
+def explicitReturn():
+    yield
+    return
+
+@autostart
+def raiseStopIteration():
+    yield
+    raise StopIteration()
+
+@autostart
+def endOfFunction():
+    yield
+
+def withoutAutoStart():
+    message = yield
+    yield message
+
+@autostart
+def withAutoStart():
+    message = yield
+    yield message
+
+class PythonTest(TestCase):
+    """ last test on top """
+
+    def testWhyAutoStart(self):
+        firstTry = withoutAutoStart()
+        try:
+            firstTry.send('hello')
+            self.fail()
+        except TypeError, e:
+            self.assertEquals("can't send non-None value to a just-started generator", str(e))
+        secondTry = withoutAutoStart()
+        secondTry.next() # 'start'
+        message = secondTry.send('hello')
+        self.assertEquals('hello', message)
+        thirdTry = withAutoStart()
+        message = thirdTry.send('hello')
+        self.assertEquals('hello', message)
+
+    def testThreeWaysOfStoping(self):
+        f1 = explicitReturn()
+        f2 = raiseStopIteration()
+        f3 = endOfFunction()
+        try:
+            f1.next()
+            self.fail()
+        except StopIteration:
+            pass
+        try:
+            f2.next()
+            self.fail()
+        except StopIteration:
+            pass
+        try:
+            f3.next()
+            self.fail()
+        except StopIteration:
+            pass
+
+    def testStop(self):
+        c = wordLengths4()
+        c.send('python')
+        c.send('day')
+        k = c.throw(StopIteration())
+        self.assertEquals('done', k)
+
+    def testLineLengthsCoroutine(self):
+        c = wordLengths3()
+        self.assertEquals(6, c.send('python'))
+        self.assertEquals(3, c.send('day'))
+
+    def testLineLengthsWithGeneratorForOutput(self):
+        g = wordLengths2(['python', 'day'])
+        self.assertEquals([6,3], list(g))
+        g = wordLengths2_alternative(['python', 'day'])
+        self.assertEquals([6,3], list(g))
+
+    def testLineLengths1(self):
+        l = wordLengths1(['python', 'day'])
+        self.assertEquals([6, 3], l)
+        l = wordLengths1_alternative(['python', 'day'])
+        self.assertEquals([6, 3], l)
+
+main()
diff --unidirectional-new-file '--exclude=*.so' '--exclude=*.o' '--exclude=.svn' '--exclude=*.pyc' '--exclude=deps.d' '--exclude=applied' --recursive --unified version_0/weightless/http/_acceptor.py version_0-merge-trunk/weightless/http/_acceptor.py
--- version_0/weightless/http/_acceptor.py	2011-06-21 09:47:06.000000000 +0200
+++ version_0-merge-trunk/weightless/http/_acceptor.py	2011-06-21 09:53:52.000000000 +0200
@@ -57,3 +57,7 @@
 
     def close(self):
         self._sok.close()
+
+    def shutdown(self):
+        self._reactor.removeReader(self._sok)
+        self.close()
diff --unidirectional-new-file '--exclude=*.so' '--exclude=*.o' '--exclude=.svn' '--exclude=*.pyc' '--exclude=deps.d' '--exclude=applied' --recursive --unified version_0/weightless/http/_httpget.py version_0-merge-trunk/weightless/http/_httpget.py
--- version_0/weightless/http/_httpget.py	2011-06-21 09:47:06.000000000 +0200
+++ version_0-merge-trunk/weightless/http/_httpget.py	2011-06-21 10:30:11.000000000 +0200
@@ -23,7 +23,7 @@
 ## end license ##
 
 from sys import exc_info
-from weightless.http import Suspend
+from weightless.io import Suspend
 from weightless.core import identify
 from socket import socket, error as SocketError, SOL_SOCKET, SO_ERROR, SHUT_WR, SHUT_RD
 from errno import EINPROGRESS
diff --unidirectional-new-file '--exclude=*.so' '--exclude=*.o' '--exclude=.svn' '--exclude=*.pyc' '--exclude=deps.d' '--exclude=applied' --recursive --unified version_0/weightless/http/_httpserver.py version_0-merge-trunk/weightless/http/_httpserver.py
--- version_0/weightless/http/_httpserver.py	2011-06-21 09:47:06.000000000 +0200
+++ version_0-merge-trunk/weightless/http/_httpserver.py	2011-06-21 09:55:30.000000000 +0200
@@ -64,6 +64,9 @@
     def setMaxConnections(self, m):
         self._maxConnections = m
 
+    def shutdown(self):
+        self._acceptor.shutdown()
+
 def HttpsServer(reactor, port, generatorFactory, timeout=1, recvSize=RECVSIZE, prio=None, sok=None, maxConnections=None, errorHandler=None, certfile='', keyfile=''):
     """Factory that creates a HTTP server listening on port, calling generatorFactory for each new connection.  When a client does not send a valid HTTP request, it is disconnected after timeout seconds. The generatorFactory is called with the HTTP Status and Headers as arguments.  It is expected to return a generator that produces the response -- including the Status line and Headers -- to be send to the client."""
     if sok == None:
diff --unidirectional-new-file '--exclude=*.so' '--exclude=*.o' '--exclude=.svn' '--exclude=*.pyc' '--exclude=deps.d' '--exclude=applied' --recursive --unified version_0/weightless/http/httpspec.py version_0-merge-trunk/weightless/http/httpspec.py
--- version_0/weightless/http/httpspec.py	2011-06-21 09:47:06.000000000 +0200
+++ version_0-merge-trunk/weightless/http/httpspec.py	2011-06-21 09:54:42.000000000 +0200
@@ -100,4 +100,5 @@
     HostHeader = 'Host: %(Host)s' + HTTP.CRLF
     Header = '%s: %s' + HTTP.CRLF
     UserAgentHeader = 'User-Agent: Weightless/v' + VERSION + HTTP.CRLF
+    StatusLine = 'HTTP/%(version)s %(status)s %(reason)s' + HTTP.CRLF
 
diff --unidirectional-new-file '--exclude=*.so' '--exclude=*.o' '--exclude=.svn' '--exclude=*.pyc' '--exclude=deps.d' '--exclude=applied' --recursive --unified version_0/weightless/http/__init__.py version_0-merge-trunk/weightless/http/__init__.py
--- version_0/weightless/http/__init__.py	2011-06-21 09:47:06.000000000 +0200
+++ version_0-merge-trunk/weightless/http/__init__.py	2011-06-22 15:06:17.000000000 +0200
@@ -23,7 +23,6 @@
 ## end license ##
 from httpspec import parseHeaders, parseHeader, HTTP, REGEXP, FORMAT
 
-from _suspend import Suspend
 from _httpreader import HttpReader
 from _httpserver import HttpServer, HttpsServer
 from _acceptor import Acceptor
Only in version_0/weightless/http: _suspend.py
diff --unidirectional-new-file '--exclude=*.so' '--exclude=*.o' '--exclude=.svn' '--exclude=*.pyc' '--exclude=deps.d' '--exclude=applied' --recursive --unified version_0/weightless/httpng/_httpprotocol.py version_0-merge-trunk/weightless/httpng/_httpprotocol.py
--- version_0/weightless/httpng/_httpprotocol.py	1970-01-01 01:00:00.000000000 +0100
+++ version_0-merge-trunk/weightless/httpng/_httpprotocol.py	2011-02-28 12:00:38.000000000 +0100
@@ -0,0 +1,150 @@
+## begin license ##
+#
+#    Weightless is a High Performance Asynchronous Networking Library
+#    Copyright (C) 2006-2009 Seek You Too (CQ2) http://www.cq2.nl
+#
+#    This file is part of Weightless
+#
+#    Weightless is free software; you can redistribute it and/or modify
+#    it under the terms of the GNU General Public License as published by
+#    the Free Software Foundation; either version 2 of the License, or
+#    (at your option) any later version.
+#
+#    Weightless is distributed in the hope that it will be useful,
+#    but WITHOUT ANY WARRANTY; without even the implied warranty of
+#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+#    GNU General Public License for more details.
+#
+#    You should have received a copy of the GNU General Public License
+#    along with Weightless; if not, write to the Free Software
+#    Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+#
+## end license ##
+from __future__ import with_statement
+from cgi import parse_qs, parse_header
+from urlparse import urlsplit, urlparse
+
+from weightless.core import compose, Observable
+from weightless.io import readRe, readAll, copyBytes, Timer, TimeoutException
+from weightless.http import HTTP, FORMAT, REGEXP
+
+MAXREQUESTSIZE = 10*1024 # max size of RequestLine (including URI) and Headers
+REQUESTTIMEOUT = 1
+
+class HeaderDict(dict):
+    def __missing__(self, key):
+        return {}
+
+def splitNameAndValue(nameAndValue):
+    name, value = nameAndValue.split(':',1)
+    return name.strip().lower(), value.strip()
+
+def parseHeaders(kwargs):
+    headers = HeaderDict(
+        (name, {value: parms})
+            for ((name, value), parms) in ((splitNameAndValue(nameAndValue), parms)
+                for nameAndValue, parms in (parse_header(headerline)
+                    for headerline in kwargs['_headers'].split(HTTP.CRLF)[:-1]
+                )
+            ))
+    kwargs['Headers'] = headers
+    del kwargs['_headers']
+    return headers
+
+class HttpProtocol(Observable):
+
+    Timer = Timer
+
+    def processConnection(self):
+        while True:
+            try:
+                with HttpProtocol.Timer(REQUESTTIMEOUT):
+                    reqArgs = yield readRe(REGEXP.REQUEST, MAXREQUESTSIZE)
+            except OverflowError:
+                yield requestEntityTooLarge()
+                yield HTTP.CRLF
+                return
+            except TimeoutException, e:
+                yield requestTimeout()
+                yield HTTP.CRLF
+                return
+            headers = parseHeaders(reqArgs)
+            scheme, netloc, path, query, fragment = urlsplit(reqArgs['RequestURI'])
+            netloc = tuple(netloc.split(':'))
+            query = parse_qs(query)
+            if 'content-length' in headers:
+                length = int(headers['content-length'].keys()[0])
+                reqArgs['ContentLength'] = length
+            chunked = 'transfer-encoding' in headers and headers['transfer-encoding'].keys()[0] == 'chunked'
+            try:
+                handler = self.any.processRequest(
+                    scheme=scheme, netloc=netloc, path=path, query=query, fragment=fragment, **reqArgs)
+            except AttributeError:
+                if 'expect' in headers:
+                    yield expectationFailed()
+                else:
+                    yield notImplemented()
+            else:
+                if 'expect' in headers:
+                    yield hundredContinue()
+                if chunked:
+                    handler = feedChunks(handler)
+                yield handler
+            if 'close' in headers['connection'] or reqArgs['HTTPVersion'] == '1.0':
+                break
+
+
+def feedChunks(handler):
+    handler.next()
+    while True:
+        chunkSizeLine = yield readRe(REGEXP.CHUNK_SIZE_LINE, MAXREQUESTSIZE)
+        size = int(chunkSizeLine['ChunkSize'], 16)
+        if size == 0:
+            yield handler.throw(StopIteration())
+            break
+        yield copyBytes(size, handler)
+        yield readRe(REGEXP.CRLF, 2)
+    for partialResponse in handler:
+        yield partialResponse
+
+def ok():
+    version = 1.1
+    status = 200
+    reason = 'Ok'
+    return FORMAT.StatusLine % locals()
+
+def notImplemented():
+    version = 1.1
+    status = 501
+    reason = 'Not Implemented'
+    return FORMAT.StatusLine % locals()
+
+def requestEntityTooLarge():
+    version = 1.1
+    status = 413
+    reason = 'Request Entity Too Large'
+    return FORMAT.StatusLine % locals()
+
+def requestTimeout():
+    version = 1.1
+    status = 408
+    reason = 'Request Timeout'
+    return FORMAT.StatusLine % locals()
+
+def hundredContinue():
+    version = 1.1
+    status = 100
+    reason = 'Continue'
+    return FORMAT.StatusLine % locals()
+
+def expectationFailed():
+    version = 1.1
+    status = 417
+    reason = 'Expectation failed'
+    return FORMAT.StatusLine % locals()
+
+def headers(key, value):
+    return FORMAT.Header % (key, value) + HTTP.CRLF
+
+def noheaders():
+    return HTTP.CRLF
diff --unidirectional-new-file '--exclude=*.so' '--exclude=*.o' '--exclude=.svn' '--exclude=*.pyc' '--exclude=deps.d' '--exclude=applied' --recursive --unified version_0/weightless/httpng/__init__.py version_0-merge-trunk/weightless/httpng/__init__.py
--- version_0/weightless/httpng/__init__.py	1970-01-01 01:00:00.000000000 +0100
+++ version_0-merge-trunk/weightless/httpng/__init__.py	2011-02-25 13:02:11.000000000 +0100
@@ -0,0 +1,2 @@
+import _httpprotocol as http
+from _httpprotocol import HttpProtocol
diff --unidirectional-new-file '--exclude=*.so' '--exclude=*.o' '--exclude=.svn' '--exclude=*.pyc' '--exclude=deps.d' '--exclude=applied' --recursive --unified version_0/weightless/__init__.py version_0-merge-trunk/weightless/__init__.py
--- version_0/weightless/__init__.py	2011-06-21 09:47:06.000000000 +0200
+++ version_0-merge-trunk/weightless/__init__.py	2011-06-21 10:31:28.000000000 +0200
@@ -26,4 +26,3 @@
 
 from sys import getdefaultencoding as _getdefaultencoding
 assert _getdefaultencoding() == 'utf-8', 'Please ensure that the default encoding is utf-8'
-
diff --unidirectional-new-file '--exclude=*.so' '--exclude=*.o' '--exclude=.svn' '--exclude=*.pyc' '--exclude=deps.d' '--exclude=applied' --recursive --unified version_0/weightless/io/_acceptor.py version_0-merge-trunk/weightless/io/_acceptor.py
--- version_0/weightless/io/_acceptor.py	1970-01-01 01:00:00.000000000 +0100
+++ version_0-merge-trunk/weightless/io/_acceptor.py	2011-02-25 13:08:41.000000000 +0100
@@ -0,0 +1,57 @@
+# -*- coding: utf-8 -*-
+## begin license ##
+#
+#    Weightless is a High Performance Asynchronous Networking Library
+#    See http://weightless.io
+#    Copyright (C) 2006-2011 Seek You Too (CQ2) http://www.cq2.nl
+#
+#    This file is part of Weightless
+#
+#    Weightless is free software; you can redistribute it and/or modify
+#    it under the terms of the GNU General Public License as published by
+#    the Free Software Foundation; either version 2 of the License, or
+#    (at your option) any later version.
+#
+#    Weightless is distributed in the hope that it will be useful,
+#    but WITHOUT ANY WARRANTY; without even the implied warranty of
+#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+#    GNU General Public License for more details.
+#
+#    You should have received a copy of the GNU General Public License
+#    along with Weightless; if not, write to the Free Software
+#    Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+#
+## end license ##
+from socket import socket, SOL_SOCKET, SO_REUSEADDR, SO_LINGER, SOL_TCP, TCP_CORK, TCP_NODELAY
+from struct import pack
+
+def createSocket(port):
+    sok = socket()
+    sok.setsockopt(SOL_SOCKET, SO_REUSEADDR, 1)
+    sok.setsockopt(SOL_SOCKET, SO_LINGER, pack('ii', 0, 0))
+    sok.bind(('0.0.0.0', port))
+    sok.listen(127)
+    return sok
+
+class Acceptor(object):
+    """Listens on a port for incoming internet (TCP/IP) connections and calls a factory to create a handler for the new connection.  It does not use threads but a asynchronous reactor instead."""
+
+    def __init__(self, reactor, port, sinkFactory, prio=None, sok=None):
+        """The reactor is a user specified reactor for dispatching I/O events asynchronously. The sinkFactory is called with the newly created socket as its single argument. It is supposed to return a callable callback function that is called by the reactor when data is available."""
+
+        if sok == None:
+            sok = createSocket(port)
+
+        reactor.addReader(sok, self._accept, prio=prio)
+        self._sinkFactory = sinkFactory
+        self._sok = sok
+        self._reactor = reactor
+
+    def _accept(self):
+        newConnection, address = self._sok.accept()
+        newConnection.setsockopt(SOL_TCP, TCP_CORK, 1)
+        #newConnection.setsockopt(SOL_TCP, TCP_NODELAY, 1)
+        self._sinkFactory(newConnection)
+
+    def close(self):
+        self._sok.close()
diff --unidirectional-new-file '--exclude=*.so' '--exclude=*.o' '--exclude=.svn' '--exclude=*.pyc' '--exclude=deps.d' '--exclude=applied' --recursive --unified version_0/weightless/io/_gio.py version_0-merge-trunk/weightless/io/_gio.py
--- version_0/weightless/io/_gio.py	1970-01-01 01:00:00.000000000 +0100
+++ version_0-merge-trunk/weightless/io/_gio.py	2011-06-22 15:06:34.000000000 +0200
@@ -0,0 +1,203 @@
+## begin license ##
+#
+#    Weightless is a High Performance Asynchronous Networking Library
+#    Copyright (C) 2006-2009 Seek You Too (CQ2) http://www.cq2.nl
+#
+#    This file is part of Weightless
+#
+#    Weightless is free software; you can redistribute it and/or modify
+#    it under the terms of the GNU General Public License as published by
+#    the Free Software Foundation; either version 2 of the License, or
+#    (at your option) any later version.
+#
+#    Weightless is distributed in the hope that it will be useful,
+#    but WITHOUT ANY WARRANTY; without even the implied warranty of
+#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+#    GNU General Public License for more details.
+#
+#    You should have received a copy of the GNU General Public License
+#    along with Weightless; if not, write to the Free Software
+#    Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+#
+## end license ##
+from functools import partial as curry
+import os
+from socket import SOL_SOCKET, SO_RCVBUF, SHUT_RDWR
+from weightless.core import compose, local
+
+class Gio(object):
+    def __init__(self, reactor, generator):
+        self._reactor = reactor
+        self._generator = compose(generator)
+        self._contextstack = []
+        self._callback2generator = compose(self.callback2generator())
+        self._callback2generator.next()
+
+    def __repr__(self):
+        return repr(self._generator)
+
+    def close(self):
+        #self._generator.throw(Exception('premature close'))
+        pass
+
+    def callback2generator(self):
+        __gio__ = self
+        message = None
+        response = None
+        while True:
+            if not response:
+                try:
+                    response = self._generator.send(message)
+                except StopIteration:
+                    yield #'return' without StopIteration
+            try:
+                assert self._contextstack, 'Gio: No context available.'
+                context = self._contextstack[-1]
+                if response:
+                    yield context.write(response)
+                    message = None
+                else:
+                    message = yield context.read()
+                    if message == '': # peer closed connection
+                        try:
+                            response = self._generator.throw(CloseException())
+                        except CloseException:
+                            yield
+                        finally:
+                            context.close()
+                response = None
+            except TimeoutException, e:
+                response = self._generator.throw(e)
+
+    def throw(self, exception):
+        try:
+            return self._callback2generator.throw(exception)
+        except exception.__class__:
+            pass
+
+    def pushContext(self, context):
+        self._contextstack.append(context)
+
+    def popContext(self):
+        self._contextstack.pop()
+
+    def addWriter(self, context):
+        self._reactor.addWriter(context, self._callback2generator.next)
+
+    def removeWriter(self, context):
+        self._reactor.removeWriter(context)
+
+    def addReader(self, context):
+        self._reactor.addReader(context, self._callback2generator.next)
+
+    def removeReader(self, context):
+        self._reactor.removeReader(context)
+
+    def addTimer(self, time, timeout):
+        return self._reactor.addTimer(time, timeout)
+
+    def removeTimer(self, timer):
+        self._reactor.removeTimer(timer)
+
+class Context(object):
+
+    def __enter__(self):
+        self.gio = local('__gio__')
+        self.gio.pushContext(self)
+        return self
+
+    def __exit__(self, type, value, traceback):
+        self.gio.popContext()
+        if type == GeneratorExit:
+            self._onExit()
+            return True
+
+    def onExit(self, method):
+        self._onExit = method
+
+    def __repr__(self):
+        return 'Context (most recent call last):' + repr(self.gio)
+
+    def close(self):
+        self.gio.close()
+
+class FdContext(Context):
+
+    def __init__(self, fd):
+        Context.__init__(self)
+        assert type(fd) == int
+        self._fd = fd
+
+    def fileno(self):
+        return self._fd
+
+    def close(self):
+        Context.close(self)
+        os.close(self._fd)
+
+    def write(self,response):
+        self.gio.addWriter(self)
+        self.onExit(curry(self.gio.removeWriter, self))
+        buff = response
+        try:
+            while len(buff) > 0:
+                yield
+                written = os.write(self._fd, buff)
+                buff = buffer(buff, written)
+        finally:
+            self.gio.removeWriter(self)
+
+    def read(self):
+        self.gio.addReader(self)
+        self.onExit(curry(self.gio.removeReader, self))
+        try:
+            yield
+            message = os.read(self._fd, self.readBufSize)
+        finally:
+            self.gio.removeReader(self)
+        raise StopIteration(message)
+
+class SocketContext(FdContext):
+
+    def __init__(self, sok):
+        self.readBufSize = sok.getsockopt(SOL_SOCKET, SO_RCVBUF) / 2
+        sok.setblocking(0)
+        FdContext.__init__(self, sok.fileno())
+        self._save_sok_from_gc = sok
+        self.shutdown = sok.shutdown
+
+class FileContext(FdContext):
+
+    def __init__(self, uri, mode='r'):
+        flags = 'w' in mode and os.O_RDWR or os.O_RDONLY
+        f = os.open(uri, flags | os.O_NONBLOCK)
+        self.readBufSize = os.fstat(f).st_blksize
+        FdContext.__init__(self, f)
+
+def open(*args, **kwargs):
+    return FileContext(*args, **kwargs)
+
+class TimeoutException(Exception):
+    pass
+
+class CloseException(Exception):
+    pass
+
+class Timer(object):
+
+    def __init__(self, timeout):
+        self.gio = local('__gio__')
+        self._timeout = timeout
+        self._timer = None
+
+    def __enter__(self):
+        self._timer = self.gio.addTimer(self._timeout, self._timedOut)
+
+    def __exit__(self, *args, **kwargs):
+        if self._timer:
+            self.gio.removeTimer(self._timer)
+            self._timer = None
+
+    def _timedOut(self):
+        self._timer = None
+        self.gio.throw(TimeoutException())
diff --unidirectional-new-file '--exclude=*.so' '--exclude=*.o' '--exclude=.svn' '--exclude=*.pyc' '--exclude=deps.d' '--exclude=applied' --recursive --unified version_0/weightless/io/_gutils.py version_0-merge-trunk/weightless/io/_gutils.py
--- version_0/weightless/io/_gutils.py	1970-01-01 01:00:00.000000000 +0100
+++ version_0-merge-trunk/weightless/io/_gutils.py	2011-02-25 11:38:53.000000000 +0100
@@ -0,0 +1,105 @@
+## begin license ##
+#
+#    Weightless is a High Performance Asynchronous Networking Library
+#    Copyright (C) 2006-2011 Seek You Too (CQ2) http://www.cq2.nl
+#
+#    This file is part of Weightless
+#
+#    Weightless is free software; you can redistribute it and/or modify
+#    it under the terms of the GNU General Public License as published by
+#    the Free Software Foundation; either version 2 of the License, or
+#    (at your option) any later version.
+#
+#    Weightless is distributed in the hope that it will be useful,
+#    but WITHOUT ANY WARRANTY; without even the implied warranty of
+#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+#    GNU General Public License for more details.
+#
+#    You should have received a copy of the GNU General Public License
+#    along with Weightless; if not, write to the Free Software
+#    Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+#
+## end license ##
+from linecache import getline
+from re import compile
+from types import GeneratorType
+
+def tostring(generator):
+    if type(generator) != GeneratorType:
+        raise TypeError("tostring() expects generator")
+    frame = generator.gi_frame
+    glocals = frame.f_locals
+    lineno = frame.f_lineno
+    code = frame.f_code
+    name = code.co_name
+    if name == "_compose":
+        if 'generators' in glocals:
+            return '\n'.join(tostring(g) for g in glocals['generators'])
+        else:
+            return tostring(glocals['initial'])
+    filename = code.co_filename
+    codeline = getline(filename, lineno).strip()
+    return '  File "%(filename)s", line %(lineno)d, in %(name)s\n    %(codeline)s' % locals()
+
+def identify(generator):
+    def helper(*args, **kwargs):
+        g = generator(*args, **kwargs)
+        g.next()
+        g.send(g)
+        return g
+    return helper
+
+def autostart(generator):
+    def helper(*args, **kwargs):
+        g = generator(*args, **kwargs)
+        g.next()
+        return g
+    return helper
+
+def readRe(regexp, maximum=None):
+    if isinstance(regexp, basestring):
+        regexp = compile(regexp)
+    match = None
+    message = ''
+    while not match:
+        if maximum and len(message) > maximum:
+            raise OverflowError('no match after %s bytes' % len(message))
+        message += yield
+        match = regexp.match(message)
+    args = match.groupdict()
+    rest = message[match.end():]
+    if rest:
+        raise StopIteration(args, rest)
+    raise StopIteration(args)
+
+def readAll():
+    data = []
+    try:
+        while True:
+            data.append((yield))
+    except StopIteration:
+        raise StopIteration(''.join(data))
+
+def copyBytes(tosend, target):
+    response, message, tail = None, None, None
+    while tosend > 0:
+        message = yield response
+        head, tail = message[:tosend], message[tosend:]
+        response = target.send(head)
+        tosend -= len(head)
+    #try:
+    #    response = target.throw(StopIteration())
+    #except StopIteration:
+    #    pass
+    if response:
+        message = yield response
+        if message and tail:
+            raise StopIteration(None, tail, message)
+        if message and not tail:
+            raise StopIteration(None, message)
+        if tail and not message:
+            raise StopIteration(None, tail)
+        raise StopIteration()
+    if tail:
+        raise StopIteration(None, tail)
+
diff --unidirectional-new-file '--exclude=*.so' '--exclude=*.o' '--exclude=.svn' '--exclude=*.pyc' '--exclude=deps.d' '--exclude=applied' --recursive --unified version_0/weightless/io/__init__.py version_0-merge-trunk/weightless/io/__init__.py
--- version_0/weightless/io/__init__.py	2011-06-21 09:47:06.000000000 +0200
+++ version_0-merge-trunk/weightless/io/__init__.py	2011-06-21 10:31:04.000000000 +0200
@@ -23,4 +23,9 @@
 ## end license ##
 
 from _reactor import Reactor, reactor
+from _suspend import Suspend
 
+from _acceptor import Acceptor
+from _gio import Gio, open as giopen, SocketContext, TimeoutException, Timer
+from _server import Server
+from _gutils import readRe, readAll, copyBytes
diff --unidirectional-new-file '--exclude=*.so' '--exclude=*.o' '--exclude=.svn' '--exclude=*.pyc' '--exclude=deps.d' '--exclude=applied' --recursive --unified version_0/weightless/io/_reactor.py version_0-merge-trunk/weightless/io/_reactor.py
--- version_0/weightless/io/_reactor.py	2011-06-21 09:47:06.000000000 +0200
+++ version_0-merge-trunk/weightless/io/_reactor.py	2011-06-21 09:57:58.000000000 +0200
@@ -123,9 +123,15 @@
         self._writers[handle] = self._suspended.pop(handle)
 
     def shutdown(self):
-        for sok in self._readers: sok.close()
-        for sok in self._writers: sok.close()
-        for sok in self._suspended: sok.close()
+        for sok in self._readers.keys():
+            print 'Reactor shutdown: closing', sok
+            sok.close()
+        for sok in self._writers.keys():
+            print 'Reactor shutdown: closing', sok
+            sok.close()
+        for sok in self._suspended.keys():
+            print 'Reactor shutdown: closing', sok
+            sok.close()
 
     def loop(self):
         try:
@@ -151,6 +157,7 @@
             self._findAndRemoveBadFd()
             return self
         except error, (errno, description):
+            print_exc()
             if errno == EBADF:
                 self._findAndRemoveBadFd()
             elif errno == EINTR:
diff --unidirectional-new-file '--exclude=*.so' '--exclude=*.o' '--exclude=.svn' '--exclude=*.pyc' '--exclude=deps.d' '--exclude=applied' --recursive --unified version_0/weightless/io/_server.py version_0-merge-trunk/weightless/io/_server.py
--- version_0/weightless/io/_server.py	1970-01-01 01:00:00.000000000 +0100
+++ version_0-merge-trunk/weightless/io/_server.py	2011-06-22 15:04:06.000000000 +0200
@@ -0,0 +1,63 @@
+## begin license ##
+#
+#    Weightless is a High Performance Asynchronous Networking Library
+#    Copyright (C) 2006-2009 Seek You Too (CQ2) http://www.cq2.nl
+#
+#    This file is part of Weightless
+#
+#    Weightless is free software; you can redistribute it and/or modify
+#    it under the terms of the GNU General Public License as published by
+#    the Free Software Foundation; either version 2 of the License, or
+#    (at your option) any later version.
+#
+#    Weightless is distributed in the hope that it will be useful,
+#    but WITHOUT ANY WARRANTY; without even the implied warranty of
+#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+#    GNU General Public License for more details.
+#
+#    You should have received a copy of the GNU General Public License
+#    along with Weightless; if not, write to the Free Software
+#    Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+#
+## end license ##
+from __future__ import with_statement
+from socket import socket, SHUT_RDWR, SOL_SOCKET, SOL_TCP, SO_REUSEADDR, SO_LINGER, TCP_CORK, SO_ERROR
+from struct import pack
+from weightless.core import Observable
+from weightless.io import Gio, SocketContext
+
+class Server(Observable):
+    def __init__(self, reactor, port):
+        Observable.__init__(self)
+        ear = socket()
+        err = ear.getsockopt(SOL_SOCKET, SO_ERROR)
+        if err != 0:    # connection created succesfully?
+            raise IOError(err)
+        ear.setsockopt(SOL_SOCKET, SO_REUSEADDR, 1)
+        ear.setsockopt(SOL_SOCKET, SO_LINGER, pack('ii', 0, 0))
+        ear.bind(('0.0.0.0', port))
+        ear.listen(127)
+        reactor.addReader(ear, self.connect)
+        self._ear = ear
+        self._reactor = reactor
+
+    def connect(self):
+        connection, address = self._ear.accept()
+        connection.setsockopt(SOL_TCP, TCP_CORK, 1)
+        Gio(self._reactor, self.processConnection(SocketContext(connection)))
+
+    def processConnection(self, connection):
+        try:
+            with connection:
+                yield self.any.processConnection()
+        finally:
+            connection.shutdown(SHUT_RDWR)
+            connection.close()
+
+    def stop(self):
+        try:
+            self._reactor.removeReader(self._ear)
+        except KeyError:
+            pass
+        self._ear.close()
+        self._reactor = None
diff --unidirectional-new-file '--exclude=*.so' '--exclude=*.o' '--exclude=.svn' '--exclude=*.pyc' '--exclude=deps.d' '--exclude=applied' --recursive --unified version_0/weightless/io/_suspend.py version_0-merge-trunk/weightless/io/_suspend.py
--- version_0/weightless/io/_suspend.py	1970-01-01 01:00:00.000000000 +0100
+++ version_0-merge-trunk/weightless/io/_suspend.py	2011-02-28 14:53:23.000000000 +0100
@@ -0,0 +1,63 @@
+## begin license ##
+#
+#    Weightless is a High Performance Asynchronous Networking Library
+#    See http://weightless.io
+#    Copyright (C) 2010-2011 Seek You Too (CQ2) http://www.cq2.nl
+#
+#    This file is part of Weightless
+#
+#    Weightless is free software; you can redistribute it and/or modify
+#    it under the terms of the GNU General Public License as published by
+#    the Free Software Foundation; either version 2 of the License, or
+#    (at your option) any later version.
+#
+#    Weightless is distributed in the hope that it will be useful,
+#    but WITHOUT ANY WARRANTY; without even the implied warranty of
+#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+#    GNU General Public License for more details.
+#
+#    You should have received a copy of the GNU General Public License
+#    along with Weightless; if not, write to the Free Software
+#    Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+#
+## end license ##
+from traceback import print_exc
+from sys import exc_info
+
+class Suspend(object):
+    def __init__(self, doNext=lambda this: None):
+        self._doNext = doNext
+        self._exception = None
+
+    def __call__(self, reactor, whenDone):
+        self._reactor = reactor
+        try:
+            self._doNext(self)
+        except Exception:
+            self._exception = exc_info()
+            print_exc()
+        else:
+            self._whenDone = whenDone
+            self._handle = reactor.suspend()
+
+    def resume(self, response=None):
+        self._response = response
+        self._whenDone()
+
+    def throw(self, exc_type, exc_value=None, exc_traceback=None):
+        """Accepts either a full exception triple or only a single exception instance (not encouraged as it loses traceback information)."""
+        if exc_value is None and exc_traceback is None:
+            self._exception = type(exc_type), exc_type, None
+        else:
+            self._exception = (exc_type, exc_value, exc_traceback)
+        self._whenDone()
+
+    def resumeWriter(self):
+        if hasattr(self, "_handle"):
+            self._reactor.resumeWriter(self._handle)
+
+    def getResult(self):
+        if self._exception:
+            raise self._exception[0], self._exception[1], self._exception[2]
+        return self._response
+
