Changeset created on Tue Feb 22 14:19:28 CET 2011 by Seek You Too

Description: Refactored and well-tested C-extension for compose() ready for production.

    This changeset add many tests for making sure compose doesn't leak memory.  It is made independent of CQ2-utils and the setup and alltests are refactored for better Python 2.6 support.  This version passes all tests, and also passes all tests in Meresco Components that depend on compose.

Baseline version: https://weightless.svn.sourceforge.net/svnroot/weightless/weightless-core/workingsets/0.5-CQ2/version_1

diff --unidirectional-new-file '--exclude=*.so' '--exclude=*.o' '--exclude=.svn' '--exclude=*.pyc' '--exclude=deps.d' '--exclude=applied' --recursive --unified version_1/setup.py version_1-sidekick/setup.py
--- version_1/setup.py	2011-02-15 08:48:32.000000000 +0100
+++ version_1-sidekick/setup.py	2011-02-21 11:12:39.000000000 +0100
@@ -1,4 +1,4 @@
-#!/usr/bin/env python2.5
+#!/usr/bin/env python
 ## begin license ##
 #
 #    Weightless is a High Performance Asynchronous Networking Library
@@ -46,7 +46,7 @@
     ext_modules=[
         Extension("weightless.core.compose._compose_c", [
             "weightless/core/compose/_compose.c"
-            ]
+            ],
         )
     ]
 )
diff --unidirectional-new-file '--exclude=*.so' '--exclude=*.o' '--exclude=.svn' '--exclude=*.pyc' '--exclude=deps.d' '--exclude=applied' --recursive --unified version_1/test/_alltests.py version_1-sidekick/test/_alltests.py
--- version_1/test/_alltests.py	2011-02-15 08:48:29.000000000 +0100
+++ version_1-sidekick/test/_alltests.py	2011-02-21 11:07:12.000000000 +0100
@@ -1,4 +1,3 @@
-#!/usr/bin/env python2.5
 ## begin license ##
 #
 #    Weightless is a High Performance Asynchronous Networking Library
@@ -36,14 +35,16 @@
 sysPath.insert(0,'..')                            #DO_NOT_DISTRIBUTE
 
 from unittest import main
-
-from composetest import ComposePyTest
-from composetest import ComposeCTest
+from types import GeneratorType
+from weightless.core.compose import ComposeType
+if ComposeType == GeneratorType:
+    from composetest import ComposePyTest
+else:
+    from composetest import ComposeCTest
 from localtest import LocalTest
 from sidekicktest import SidekickTest
 from reactortest import ReactorTest
 from servertestcasetest import ServerTestCaseTest
-from snaketest import SnakeTest
 
 from http.acceptortest import AcceptorTest
 from http.httpreadertest import HttpReaderTest
diff --unidirectional-new-file '--exclude=*.so' '--exclude=*.o' '--exclude=.svn' '--exclude=*.pyc' '--exclude=deps.d' '--exclude=applied' --recursive --unified version_1/test/alltests.sh version_1-sidekick/test/alltests.sh
--- version_1/test/alltests.sh	2011-02-15 08:48:29.000000000 +0100
+++ version_1-sidekick/test/alltests.sh	2011-02-21 11:09:30.000000000 +0100
@@ -25,14 +25,22 @@
 
 export LANG=en_US.UTF-8
 export PYTHONPATH=.:"$PYTHONPATH"
-option=$1                                                  #DO_NOT_DISTRIBUTE
-if [ "$option" == "--python" ]; then                       #DO_NOT_DISTRIBUTE
-    shift                                                  #DO_NOT_DISTRIBUTE
-WEIGHTLESS_COMPOSE_TEST=PYTHON python2.5 _alltests.py "$@" #DO_NOT_DISTRIBUTE
-elif [ "$option" == "--c" ]; then                          #DO_NOT_DISTRIBUTE
-    shift                                                  #DO_NOT_DISTRIBUTE
-python2.5 _alltests.py "$@"                                #DO_NOT_DISTRIBUTE
-else                                                       #DO_NOT_DISTRIBUTE
-WEIGHTLESS_COMPOSE_TEST=PYTHON python2.5 _alltests.py "$@" #DO_NOT_DISTRIBUTE
-python2.5 _alltests.py "$@"
-fi                                                         #DO_NOT_DISTRIBUTE
+option=$1
+pyversions="$(pyversions --installed)"
+if [ "${option:0:10}" == "--python2." ]; then
+    shift
+    pyversions="${option:2}"
+fi
+test=
+option=$1
+if [ "$option" == "--python" ]; then
+        shift
+        test=PYTHON
+elif [ "$option" == "--c" ]; then
+        shift
+        test=C
+fi
+for pycmd in $pyversions; do
+    echo "================ $pycmd _alltests.py $@ ================"
+    WEIGHTLESS_COMPOSE_TEST=$test $pycmd _alltests.py "$@"
+done
diff --unidirectional-new-file '--exclude=*.so' '--exclude=*.o' '--exclude=.svn' '--exclude=*.pyc' '--exclude=deps.d' '--exclude=applied' --recursive --unified version_1/test/basetestcase.py version_1-sidekick/test/basetestcase.py
--- version_1/test/basetestcase.py	1970-01-01 01:00:00.000000000 +0100
+++ version_1-sidekick/test/basetestcase.py	2011-02-20 18:59:55.000000000 +0100
@@ -0,0 +1,71 @@
+## begin license ##
+#
+#    "CQ2 Utils" (cq2utils) is a package with a wide range of valuable tools.
+#    Copyright (C) 2005-2008 Seek You Too (CQ2) http://www.cq2.nl
+#
+#    This file is part of "CQ2 Utils".
+#
+#    "CQ2 Utils" is free software; you can redistribute it and/or modify
+#    it under the terms of the GNU General Public License as published by
+#    the Free Software Foundation; either version 2 of the License, or
+#    (at your option) any later version.
+#
+#    "CQ2 Utils" is distributed in the hope that it will be useful,
+#    but WITHOUT ANY WARRANTY; without even the implied warranty of
+#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+#    GNU General Public License for more details.
+#
+#    You should have received a copy of the GNU General Public License
+#    along with "CQ2 Utils"; if not, write to the Free Software
+#    Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+#
+## end license ##
+
+import sys, unittest, string
+from tempfile import mkdtemp, mkstemp
+from shutil import rmtree
+import os
+
+
+class BaseTestCase(unittest.TestCase):
+
+    def setUp(self):
+        self.tempdir = mkdtemp()
+        fd, self.tempfile = mkstemp()
+        os.close(fd)
+
+    def tearDown(self):
+        rmtree(self.tempdir)
+        os.remove(self.tempfile)
+
+    def select(self, aString, index):
+        while index < len(aString):
+            char = aString[index]
+            index = index + 1
+            if not char in string.whitespace:
+                return char, index
+        return '', index
+
+    def cursor(self, aString, index):
+        return aString[:index - 1] + "---->" + aString[index - 1:]
+
+    def assertEqualsWS(self, s1, s2):
+        index1 = 0
+        index2 = 0
+        while True:
+            char1, index1 = self.select(s1, index1)
+            char2, index2 = self.select(s2, index2)
+            if char1 != char2:
+                self.fail('%s != %s' % (self.cursor(s1, index1), self.cursor(s2, index2)))
+            if not char1 or not char2:
+                break
+
+class MatchAll(object):
+    def __eq__(self, other):
+        return True
+    def __ne__(self, other):
+        return False
+    def __repr__(self):
+        return '*MatchAll*'
+
+MATCHALL = MatchAll()
diff --unidirectional-new-file '--exclude=*.so' '--exclude=*.o' '--exclude=.svn' '--exclude=*.pyc' '--exclude=deps.d' '--exclude=applied' --recursive --unified version_1/test/calltrace.py version_1-sidekick/test/calltrace.py
--- version_1/test/calltrace.py	1970-01-01 01:00:00.000000000 +0100
+++ version_1-sidekick/test/calltrace.py	2011-02-20 18:59:55.000000000 +0100
@@ -0,0 +1,114 @@
+## begin license ##
+#
+#    "CQ2 Utils" (cq2utils) is a package with a wide range of valuable tools.
+#    Copyright (C) 2005-2008 Seek You Too (CQ2) http://www.cq2.nl
+#
+#    This file is part of "CQ2 Utils".
+#
+#    "CQ2 Utils" is free software; you can redistribute it and/or modify
+#    it under the terms of the GNU General Public License as published by
+#    the Free Software Foundation; either version 2 of the License, or
+#    (at your option) any later version.
+#
+#    "CQ2 Utils" is distributed in the hope that it will be useful,
+#    but WITHOUT ANY WARRANTY; without even the implied warranty of
+#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+#    GNU General Public License for more details.
+#
+#    You should have received a copy of the GNU General Public License
+#    along with "CQ2 Utils"; if not, write to the Free Software
+#    Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+#
+## end license ##
+
+from types import InstanceType, ClassType
+
+class CallTrace:
+    def __init__(self, name = "CallTrace", verbose = False, returnValues = None, ignoredAttributes=[]):
+        self.calledMethods = []
+        self.returnValues = returnValues or {}
+        self.exceptions = {}
+        self._verbose = verbose
+        self._name = name
+        self.ignoredAttributes = ignoredAttributes or []
+
+    def __getattr__(self, attrname):
+        if attrname.startswith('__') and attrname.endswith('__') and not attrname in self.returnValues:
+            return object.__getattr__(self, attrname)
+        if attrname in self.ignoredAttributes:
+            raise AttributeError("'CallTrace' is instructed to not have an attribute called '%s'" % attrname)
+        return TracedCall(attrname, self)
+
+    def __calltrace__(self):
+        return map(str, self.calledMethods)
+
+    def __nonzero__(self):
+        return 1
+
+    def __repr__(self):
+        #TODO: __repr__ ook terug laten komen in calltrace
+        return "<CallTrace: %s>" % self._name
+
+    def __str__(self):
+        #TODO: __str__ ook terug laten komen in calltrace
+        return self.__repr__()
+
+class TracedCall:
+    def __init__(self, methodName, callTrace):
+        self.name = methodName
+        self._callTrace = callTrace
+        #inits are necessary to make __repr__ calls before __call__ calls possible
+        self.arguments = []
+        self.kwargs = {}
+
+    def __call__(self, *args, **kwargs):
+        self._callTrace.calledMethods.append(self)
+        self.arguments = list(args)
+        self.args = args #??! is not used?
+        self.kwargs = kwargs
+        if self._callTrace._verbose:
+            print '%s.%s -> %s' % (
+                self._callTrace._name,
+                self.__repr__(),
+                self.represent(self._callTrace.returnValues.get(self.name, None)))
+        if self._callTrace.exceptions.has_key(self.name):
+            raise self._callTrace.exceptions[self.name]
+        return self._callTrace.returnValues.get(self.name, None)
+
+    def represent(self, something):
+        """
+        <calltracetest.NonObject instance at 0x2b02ba1075a8>
+        <calltracetest.IsObject object at 0x2b02ba0f3510>
+        <class 'calltracetest.IsObject'>
+        calltracetest.NonObject
+        """
+        from re import compile
+        objectOnlyRe = r'((?:\w+\.)*\w+)'
+        instanceRe = r'<%s instance at .*>' % objectOnlyRe
+        objectRe = r'<%s object at .*>' % objectOnlyRe
+        classRe = r"<class '%s'>" % objectOnlyRe
+        objectsRe = compile(r'|'.join([instanceRe, objectRe]))
+        classesRe = compile(r'|'.join([classRe, objectOnlyRe]))
+
+        if something == None:
+            return 'None'
+
+        if type(something) == str:
+            return "'%s'" % something
+        if type(something) == int or type(something) == float:
+            return str(something)
+
+        typeName = str(something)
+        match = objectsRe.match(typeName)
+        if match:
+            return "<%s>" % filter(None, match.groups())[0]
+
+        match = classesRe.match(typeName)
+        if match:
+            return "<class %s>" % filter(None, match.groups())[0]
+
+        return typeName
+
+    def __repr__(self):
+        return '%s(%s)' % (self.name, ", ".join(map(self.represent, self.arguments)+['%s=%s' % (key, self.represent(value)) for key, value in self.kwargs.items()]))
+
diff --unidirectional-new-file '--exclude=*.so' '--exclude=*.o' '--exclude=.svn' '--exclude=*.pyc' '--exclude=deps.d' '--exclude=applied' --recursive --unified version_1/test/composetest.py version_1-sidekick/test/composetest.py
--- version_1/test/composetest.py	2011-02-15 08:48:29.000000000 +0100
+++ version_1-sidekick/test/composetest.py	2011-02-21 14:21:47.000000000 +0100
@@ -23,17 +23,21 @@
 ## end license ##
 
 from unittest import TestCase
-from sys import stdout, exc_info, getrecursionlimit
-
+from sys import stdout, exc_info, getrecursionlimit, version_info
+import gc
+from weakref import ref
+from types import GeneratorType
 from weightless.core import autostart
 from weightless.core.compose._local_py import local as pyLocal
 from weightless.core.compose._compose_py import compose as pyCompose
 from weightless.core.compose._tostring_py import tostring as pyTostring
-from weightless.core.compose._compose_c import local as cLocal
-from weightless.core.compose._compose_c import compose as cCompose
+from weightless.core.compose._compose_c import local as cLocal, compose as cCompose
 from weightless.core.compose._compose_c import tostring as cTostring
-from gc import collect
 
+class ATrackedObj(object):
+    def __init__(self):
+        self.l = []
+        
 class _ComposeTest(TestCase):
 
     def testCallCompose(self):
@@ -41,15 +45,18 @@
             compose()
             self.fail()
         except TypeError, e:
-            self.assertEquals('compose() takes at least 1 argument (0 given)', str(e))
+            self.assertTrue(
+                    "compose() takes at least 1 argument (0 given)" in str(e)
+                    or # (python 2.5/2.6 C-API differences)
+                    "Required argument 'initial' (pos 1) not found" in str(e))
         self.assertRaises(TypeError, compose, 's')
         self.assertRaises(TypeError, compose, 0)
 
     def testGC(self):
         c = compose((x for x in []))
-        collect()
+        gc.collect()
         del c
-        collect()
+        gc.collect()
 
     def assertComposeImpl(self, impl):
         self.assertEquals(impl, compose)
@@ -286,7 +293,7 @@
         def f():
             try:
                 yield None
-            except Exception, e:
+            except BaseException, e:
                 r.append(e)
                 raise
         g = compose(f())
@@ -453,7 +460,7 @@
         def g():
             try:
                 yield f()
-            except Exception, e:
+            except BaseException, e:
                 raise Exception(e)
         c = compose(g())
         r = c.next()
@@ -579,7 +586,7 @@
         c = compose(g())
         c.next()
         try:
-            c.throw(Exception('ABC'))
+            c.throw(Exception, Exception('ABC'))
             self.fail()
         except Exception:
             exType, exValue, exTraceback = exc_info()
@@ -591,11 +598,11 @@
         def f():
             yield
         g = f()
-        soll = """  File "%s", line 591, in f
+        soll = """  File "%s", line 598, in f
     def f():""" % __file__.replace('pyc', 'py')
         self.assertEquals(soll, tostring(g))
         g.next()
-        soll = """  File "%s", line 592, in f
+        soll = """  File "%s", line 599, in f
     yield""" % __file__.replace('pyc', 'py')
         self.assertEquals(soll, tostring(g))
 
@@ -606,9 +613,9 @@
         def f2():
             yield f1()
         c = compose(f2())
-        result = """  File "%s", line 607, in f2
+        result = """  File "%s", line 614, in f2
     yield f1()
-  File "%s", line 605, in f1
+  File "%s", line 612, in f1
     yield""" % (2*(__file__.replace('pyc', 'py'),))
         c.next()
         self.assertEquals(result, tostring(c), "\n%s\n!=\n%s\n" % (result, tostring(c)))
@@ -619,7 +626,7 @@
         def f2():
             yield f1()
         c = compose(f2())
-        result = """  File "%s", line 619, in f2
+        result = """  File "%s", line 626, in f2
     def f2():""" % __file__.replace('pyc', 'py')
         self.assertEquals(result, tostring(c))
 
@@ -783,7 +790,7 @@
                 yield
             except GeneratorExit:
                 msg.append('GeneratorExit turned into StopIteration')
-                raise StopIteration()  # <= this is the clue, see next test
+                raise StopIteration  # <= this is the clue, see next test
         g5 = compose(f5())
         g5.next()
         try:
@@ -805,7 +812,7 @@
         g7 = compose(f7())
         g7.next()
         try:
-            g7.throw(GeneratorExit())
+            g7.throw(GeneratorExit)
             self.fail('must reraise RuntimeError(generator ignored GeneratorExit)')
         except RuntimeError:
             pass
@@ -866,22 +873,84 @@
         self.assertEquals(84, c.throw(Exception()))
         self.assertEquals(None, c.close())
 
+    def testMessagesAndResponseAreFreed(self):
+        def f():
+            v = yield ATrackedObj() # some that is tracked
+        self.assertTrue('ATrackedObj' in str(compose(f()).next()))
+
+    def testDecorator(self):
+        from weightless.core import compose
+        @compose
+        def f():
+            yield "a"
+        self.assertEquals(["a"], list(f()))
+
+    def testEmptyArgsInStopIteration(self):
+        def f1():
+            si = StopIteration()
+            si.args = () # empty tuple
+            raise si
+            yield
+        def f2():
+            x = yield f1()
+            yield x
+        g = compose(f2())
+        self.assertEquals([None], list(g))
+
+    def testArgsIsNoIterable(self):
+        # because the Python VM checks this, we test the assumtion only
+        si = StopIteration()
+        try:
+            si.args = 9 # not a tuple. Actually checked by StopIteration itself!
+        except TypeError, e:
+            self.assertEquals("'int' object is not iterable", str(e))
+
+    def testArgsIsNoTuple(self):
+        # because the Python VM turns the args into a tuple, we only test this
+        si = StopIteration()
+        si.args = [2] # not a tuple. VM turns this into tuple
+        self.assertEquals((2,), si.args)
+
+    def get_tracked_objects(self):
+        return [o for o in gc.get_objects() if type(o) in 
+                (compose, GeneratorType, Exception, ATrackedObj)]
+
+    def testComposeType(self):
+        from weightless.core.compose import ComposeType
+        self.assertEquals(type, type(ComposeType))
+        self.assertEquals(ComposeType, type(compose((n for n in []))))
+
+    def setUp(self):
+        gc.collect()
+        self._baseline = self.get_tracked_objects()
+
+    def tearDown(self):
+        def tostr(o):
+            try:
+                return tostring(o)
+            except:
+                return repr(o)
+        gc.collect()
+        for obj in self.get_tracked_objects():
+            self.assertTrue(obj in self._baseline, obj) #tostr(obj))
+        del self._baseline
+        gc.collect()
 
 class ComposePyTest(_ComposeTest):
     def setUp(self):
-        _ComposeTest.setUp(self)
         global local, tostring, compose
         local = pyLocal
         tostring = pyTostring
         compose = pyCompose
+        _ComposeTest.setUp(self)
 
 class ComposeCTest(_ComposeTest):
     def setUp(self):
-        _ComposeTest.setUp(self)
         global local, tostring, compose
         local = cLocal
         tostring = cTostring
         compose = cCompose
+        _ComposeTest.setUp(self)
 
     def testQueueSize(self):
         testrange = 9 #QUEUE SIZE = 10
@@ -924,8 +993,17 @@
             list(c)
             self.fail('must raise runtimeerror')
         except RuntimeError, e:
-            self.assertEquals('maximum recursion depth exceeded (compose)', e.message)
+            self.assertEquals('maximum recursion depth exceeded (compose)', str(e))
 
     def testSelftest(self):
         from weightless.core.compose._compose_c import _selftest
         _selftest()
+
+
+def gettypeerrormsg():
+    def compose(initial, arg1 = None): pass
+    try:
+        compose()
+    except TypeError, e:
+        return str(e)
+ 
diff --unidirectional-new-file '--exclude=*.so' '--exclude=*.o' '--exclude=.svn' '--exclude=*.pyc' '--exclude=deps.d' '--exclude=applied' --recursive --unified version_1/test/http/acceptortest.py version_1-sidekick/test/http/acceptortest.py
--- version_1/test/http/acceptortest.py	2011-02-15 08:48:27.000000000 +0100
+++ version_1-sidekick/test/http/acceptortest.py	2011-02-20 18:59:54.000000000 +0100
@@ -23,7 +23,7 @@
 ## end license ##
 from unittest import TestCase
 from socket import socket
-from cq2utils import CallTrace
+from calltrace import CallTrace
 from random import randint
 from os import system
 from subprocess import Popen, PIPE
diff --unidirectional-new-file '--exclude=*.so' '--exclude=*.o' '--exclude=.svn' '--exclude=*.pyc' '--exclude=deps.d' '--exclude=applied' --recursive --unified version_1/test/http/asyncreadertest.py version_1-sidekick/test/http/asyncreadertest.py
--- version_1/test/http/asyncreadertest.py	2011-02-15 08:48:27.000000000 +0100
+++ version_1-sidekick/test/http/asyncreadertest.py	2011-02-20 18:59:54.000000000 +0100
@@ -22,8 +22,7 @@
 #
 ## end license ##
 
-from cq2utils import CQ2TestCase
-
+from basetestcase import BaseTestCase
 from re import sub
 from sys import exc_info
 import sys
@@ -51,13 +50,13 @@
     'httpget.py': httpget.func_code.co_filename,
 }
  
-class AsyncReaderTest(CQ2TestCase):
+class AsyncReaderTest(BaseTestCase):
 
     def dispatch(self, *args, **kwargs):
         return compose(self.handler(*args, **kwargs))
 
     def setUp(self):
-        CQ2TestCase.setUp(self)
+        BaseTestCase.setUp(self)
         self.reactor = Reactor()
         self.port = randint(2**10, 2**16)
         self.httpserver = HttpServer(self.reactor, self.port, self.dispatch)
@@ -155,7 +154,7 @@
             finally:
                 sys.stderr = orgout
         self.assertEquals(IOError, exceptions[0][0])
-        self.assertEquals(111, exceptions[0][1].message)
+        self.assertEquals('111', str(exceptions[0][1]))
 
     def testTracebackPreservedAcrossSuspend(self):
         backofficeport = self.port + 1
diff --unidirectional-new-file '--exclude=*.so' '--exclude=*.o' '--exclude=.svn' '--exclude=*.pyc' '--exclude=deps.d' '--exclude=applied' --recursive --unified version_1/test/http/httpreadertest.py version_1-sidekick/test/http/httpreadertest.py
--- version_1/test/http/httpreadertest.py	2011-02-15 08:48:27.000000000 +0100
+++ version_1-sidekick/test/http/httpreadertest.py	2011-02-20 18:59:55.000000000 +0100
@@ -34,8 +34,8 @@
 from weightless.http._httpreader import HttpReaderFacade, Connector, HandlerFacade, _httpParseUrl
 import sys
 from StringIO import StringIO
-from cq2utils import CallTrace
-from cq2utils.cq2testcase import MatchAll
+from calltrace import CallTrace
+from basetestcase import MATCHALL
 
 def server(port, response, expectedrequest, delay=0, loop=50):
     isListening = Event()
@@ -98,7 +98,7 @@
         while 'Hello World!' != "".join((x for x in dataReceived[1:] if x)):
             reactor.step()
         serverThread.join()
-        self.assertEquals({'HTTPVersion': '1.1', 'StatusCode': '200', 'ReasonPhrase': 'OK', 'Headers': {'Content-Type': 'text/html'}, 'Client': ('127.0.0.1', MatchAll())}, dataReceived[0])
+        self.assertEquals({'HTTPVersion': '1.1', 'StatusCode': '200', 'ReasonPhrase': 'OK', 'Headers': {'Content-Type': 'text/html'}, 'Client': ('127.0.0.1', MATCHALL)}, dataReceived[0])
 
     def testHttpUrlParse(self):
         host, port, path = _httpParseUrl('http://www.cq2.org')
diff --unidirectional-new-file '--exclude=*.so' '--exclude=*.o' '--exclude=.svn' '--exclude=*.pyc' '--exclude=deps.d' '--exclude=applied' --recursive --unified version_1/test/http/httpservertest.py version_1-sidekick/test/http/httpservertest.py
--- version_1/test/http/httpservertest.py	2011-02-15 08:48:27.000000000 +0100
+++ version_1-sidekick/test/http/httpservertest.py	2011-02-20 18:59:55.000000000 +0100
@@ -28,7 +28,8 @@
 from select import select
 from weightless.io import Reactor
 from time import sleep
-from cq2utils import MATCHALL, CallTrace
+from calltrace import CallTrace
+from basetestcase import MATCHALL
 from os.path import join, abspath, dirname
 
 from weightless.http import HttpServer, _httpserver
diff --unidirectional-new-file '--exclude=*.so' '--exclude=*.o' '--exclude=.svn' '--exclude=*.pyc' '--exclude=deps.d' '--exclude=applied' --recursive --unified version_1/test/http/suspendtest.py version_1-sidekick/test/http/suspendtest.py
--- version_1/test/http/suspendtest.py	2011-02-15 08:48:27.000000000 +0100
+++ version_1-sidekick/test/http/suspendtest.py	2011-02-20 18:59:54.000000000 +0100
@@ -29,7 +29,8 @@
 from re import sub
 from traceback import format_exc
 
-from cq2utils import CallTrace, CQ2TestCase
+from basetestcase import BaseTestCase
+from calltrace import CallTrace
 
 from weightless.io import Reactor
 from weightless.http import Suspend, HttpServer
@@ -47,7 +48,7 @@
 }
 
 
-class SuspendTest(CQ2TestCase):
+class SuspendTest(BaseTestCase):
 
     def testReactorSuspend(self):
         handle = ['initial value']
diff --unidirectional-new-file '--exclude=*.so' '--exclude=*.o' '--exclude=.svn' '--exclude=*.pyc' '--exclude=deps.d' '--exclude=applied' --recursive --unified version_1/test/reactortest.py version_1-sidekick/test/reactortest.py
--- version_1/test/reactortest.py	2011-02-15 08:48:29.000000000 +0100
+++ version_1-sidekick/test/reactortest.py	2011-02-20 18:59:55.000000000 +0100
@@ -23,7 +23,6 @@
 ## end license ##
 
 from unittest import TestCase
-from cq2utils.calltrace import CallTrace
 from time import time, sleep
 from signal import signal, SIGALRM, alarm, pause
 from select import error as ioerror
Only in version_1/test: snaketest.py
diff --unidirectional-new-file '--exclude=*.so' '--exclude=*.o' '--exclude=.svn' '--exclude=*.pyc' '--exclude=deps.d' '--exclude=applied' --recursive --unified version_1/testsetup.sh version_1-sidekick/testsetup.sh
--- version_1/testsetup.sh	2011-02-15 08:48:32.000000000 +0100
+++ version_1-sidekick/testsetup.sh	2011-02-20 18:59:55.000000000 +0100
@@ -24,15 +24,21 @@
 set -e
 
 rm -rf tmp build
+for pycmd in $(pyversions --installed); do
 
-python2.5 setup.py install --root tmp
+$pycmd setup.py install --root tmp
 
-export PYTHONPATH=`pwd`/tmp/usr/lib/python2.5/site-packages
+if [ "$pycmd" == "python2.5" ]; then
+    export PYTHONPATH=`pwd`/tmp/usr/lib/python2.5/site-packages
+else
+    export PYTHONPATH=`pwd`/tmp/usr/local/lib/python2.6/dist-packages
+fi
 cp -r test tmp/test
 
 (
 cd tmp/test
-./alltests.sh
+./alltests.sh --${pycmd}
 )
 
 rm -rf tmp build
+done
diff --unidirectional-new-file '--exclude=*.so' '--exclude=*.o' '--exclude=.svn' '--exclude=*.pyc' '--exclude=deps.d' '--exclude=applied' --recursive --unified version_1/weightless/core/compose/_compose.c version_1-sidekick/weightless/core/compose/_compose.c
--- version_1/weightless/core/compose/_compose.c	2011-02-15 08:48:32.000000000 +0100
+++ version_1-sidekick/weightless/core/compose/_compose.c	2011-02-21 10:48:57.000000000 +0100
@@ -107,9 +107,8 @@
     PyObject* result = *self->messages_start;
     *self->messages_start++ = NULL;
 
-    if(self->messages_start == self->messages_base + QUEUE_SIZE) {
+    if(self->messages_start == self->messages_base + QUEUE_SIZE)
         self->messages_start = self->messages_base;
-    }
 
     return result;
 }
@@ -124,9 +123,8 @@
     *self->messages_end++ = message;
     Py_INCREF(message);
 
-    if(self->messages_end == self->messages_base + QUEUE_SIZE) {
+    if(self->messages_end == self->messages_base + QUEUE_SIZE)
         self->messages_end = self->messages_base;
-    }
 
     return 1;
 }
@@ -138,27 +136,26 @@
         return 0;
     }
 
-    if(self->messages_start == self->messages_base) {
+    if(self->messages_start == self->messages_base)
         self->messages_start = self->messages_base + QUEUE_SIZE;
-    }
 
     *--self->messages_start = message;
     Py_INCREF(message);
     return 1;
 }
 
+
+
 ////////// Garbage Collector Support //////////
 
 static int compose_traverse(PyComposeObject* self, visitproc visit, void* arg) {
     PyObject** p;
 
-    for(p = self->generators_base; p < self->generators_top; p++) {
+    for(p = self->generators_base; p < self->generators_top; p++)
         Py_VISIT(*p);
-    }
 
-    for(p = self->messages_base; p < self->messages_base + QUEUE_SIZE; p++) {
+    for(p = self->messages_base; p < self->messages_base + QUEUE_SIZE; p++)
         Py_VISIT(*p);
-    }
 
     Py_VISIT(self->sidekick);
     return 0;
@@ -166,16 +163,14 @@
 
 
 static int compose_clear(PyComposeObject* self) {
-    while(self->generators_base && --self->generators_top > self->generators_base) {
+    while(self->generators_base && --self->generators_top >= self->generators_base)
         Py_CLEAR(*self->generators_top);
-    }
 
     free(self->generators_base);
     self->generators_base = NULL;
 
-    while(self->messages_base && !messages_empty(self)) {
+    while(self->messages_base && !messages_empty(self))
         Py_DECREF(messages_next(self));
-    }
 
     free(self->messages_base);
     self->messages_base = NULL;
@@ -187,9 +182,8 @@
 static void compose_dealloc(PyComposeObject* self) {
     PyObject_GC_UnTrack(self);
 
-    if(self->weakreflist != NULL) {
+    if(self->weakreflist != NULL)
         PyObject_ClearWeakRefs((PyObject*)self);
-    }
 
     compose_clear(self);
     PyObject_GC_Del(self);
@@ -218,12 +212,13 @@
 
 
 static PyObject* compose_new(PyObject* type, PyObject* args, PyObject* kwargs) {
-    char* argnames[] = {"initial", "sidekick"};
+    static char* argnames[] = {"initial", "sidekick"};
     PyObject* initial = NULL;
     PyObject* sidekick = NULL;
 
-    if(!PyArg_ParseTupleAndKeywords(args, kwargs, "O|O:compose", argnames,
-                                    &initial, &sidekick)) return NULL;
+    if(!PyArg_ParseTupleAndKeywords(                            // borrowed refs
+                args, kwargs, "O|O:compose", argnames,
+                &initial, &sidekick)) return NULL;
 
     if(!PyGen_Check(initial) && !PyCompose_Check(initial)) {
         PyErr_SetString(PyExc_TypeError, "compose() argument 1 must be generator");
@@ -232,7 +227,8 @@
 
     PyComposeObject* cmps = PyObject_GC_New(PyComposeObject, &PyCompose_Type);
 
-    if(cmps == NULL) return NULL;
+    if(cmps == NULL)
+        return NULL;
 
     _compose_initialize((PyComposeObject*) cmps);
 
@@ -248,31 +244,25 @@
 }
 
 
-static int _compose_handle_stopiteration(PyComposeObject* self) {
-    PyObject* error_type, *error_value, *error_traceback;
-    PyErr_Fetch(&error_type, &error_value, &error_traceback); // clears exc, new refs or NULLs
-    PyObject* args = error_value
-                     ? PyObject_GetAttrString(error_value, "args") // new ref
+static int _compose_handle_stopiteration(PyComposeObject* self, PyObject* exc_value) {
+    PyObject* args = exc_value
+                     ? PyObject_GetAttrString(exc_value, "args") // new ref
                      : NULL;
-    Py_XDECREF(error_type);
-    Py_XDECREF(error_value);
-    Py_XDECREF(error_traceback);
 
-    if(args && PyTuple_CheckExact(args)) {
+    if(args && PyTuple_CheckExact(args) && PyObject_IsTrue(args)) {
         int i;
 
-        for(i = PyTuple_Size(args) - 1; i >= 0; i--) {
+        for(i = PyTuple_Size(args) - 1; i >= 0; i--)
             if(!messages_insert(self, PyTuple_GET_ITEM(args, i))) {
-                Py_DECREF(args);
+                Py_CLEAR(args);
                 return 0;
             }
-        }
 
-        Py_DECREF(args);
+        Py_CLEAR(args);
 
-    } else {
+    } else
         messages_insert(self, Py_None);
-    }
+
     return 1;
 }
 
@@ -295,80 +285,91 @@
 
 
 static PyObject* _compose_go(PyComposeObject* self, PyObject* exc_type, PyObject* exc_value, PyObject* exc_tb) {
+    Py_XINCREF(exc_type);
+    Py_XINCREF(exc_value);
+    Py_XINCREF(exc_tb);
+
     while(self->generators_top > self->generators_base) {
         PyObject* generator = *(self->generators_top - 1); // take over ownership from stack
         PyObject* response = NULL;
         PyObject* message = NULL;
 
-        if(exc_type) {
+        if(exc_type) { // exception
             if(PyErr_GivenExceptionMatches(exc_type, PyExc_GeneratorExit)) {
                 PyObject* result = PyObject_CallMethod(generator, "close", NULL); // new ref
 
                 if(result) {
-                    Py_DECREF(result);
-                    Py_XINCREF(exc_type);
-                    Py_XINCREF(exc_value);
-                    Py_XINCREF(exc_tb);
+                    Py_CLEAR(result);
                     PyErr_Restore(exc_type, exc_value, exc_tb); //steals refs
                     exc_type = exc_value = exc_tb = NULL;
                 }
 
-            } else {
+            } else
                 response =
                     PyObject_CallMethod(generator, "throw", "OOO",
                                         exc_type,
                                         exc_value ? exc_value : Py_None,
                                         exc_tb ? exc_tb : Py_None); // new ref
-            }
 
-        } else {
+            Py_CLEAR(exc_type);
+            Py_CLEAR(exc_value);
+            Py_CLEAR(exc_tb);
+
+        } else { // normal message
             message = messages_next(self); // new ref
             response = PyObject_CallMethod(generator, "send", "O", message); // new ref
-            Py_DECREF(message);
+            Py_CLEAR(message);
         }
 
-        if(response) {
+        if(response) { // normal response
             if(PyGen_Check(response) || PyCompose_Check(response)) {
-                if(!generators_push(self, response)) return NULL;
+                if(!generators_push(self, response)) {
+                    Py_CLEAR(response);
+                    return NULL;
+                }
 
-                if(PyGen_Check(response) && generator_invalid(response)) return NULL;
+                if(PyGen_Check(response) && generator_invalid(response)) {
+                    Py_CLEAR(response);
+                    return NULL;
+                }
 
                 messages_insert(self, Py_None);
 
-            } else if(self->sidekick && PyCallable_Check(response)) {
-                messages_insert(self, message);
+            } else if(self->sidekick && self->sidekick != Py_None && PyCallable_Check(response)) {
+                messages_insert(self, Py_None);
                 PyObject* r = PyObject_CallFunctionObjArgs(response, self->sidekick, NULL);
 
-                if(!r) {
+                if(!r)
                     PyErr_Fetch(&exc_type, &exc_value, &exc_tb); // new refs
 
-                } else
-                    Py_XDECREF(r);
+                Py_CLEAR(r);
 
             } else if(response != Py_None || messages_empty(self)) {
                 self->expect_data = response == Py_None;
-                Py_INCREF(response);
                 return response;
             }
-        } else {
-            if(PyErr_ExceptionMatches(PyExc_StopIteration)) {
-                if(!_compose_handle_stopiteration(self)) {
+
+            Py_CLEAR(response);
+
+        } else { // exception thrown
+            PyErr_Fetch(&exc_type, &exc_value, &exc_tb); // new refs
+
+            if(PyErr_GivenExceptionMatches(exc_type, PyExc_StopIteration)) {
+                Py_CLEAR(exc_tb);
+                Py_CLEAR(exc_type);
+                int ok = _compose_handle_stopiteration(self, exc_value);
+                Py_CLEAR(exc_value);
+
+                if(!ok)
                     PyErr_Fetch(&exc_type, &exc_value, &exc_tb); // new refs
-                } else {
-                    exc_type = exc_value = exc_tb = NULL;
-                }
-            } else {
-                PyErr_Fetch(&exc_type, &exc_value, &exc_tb); // new refs
             }
-            Py_DECREF(generator);
+
+            Py_CLEAR(generator);
             *self->generators_top-- = NULL;
         }
     }
 
     if(exc_type) {
-        Py_XINCREF(exc_type);
-        Py_XINCREF(exc_value);
-        Py_XINCREF(exc_tb);
         PyErr_Restore(exc_type, exc_value, exc_tb); // steals refs
         exc_type = exc_value = exc_tb = NULL;
         return NULL;
@@ -395,19 +396,18 @@
 
 
 static PyObject* compose_throw(PyComposeObject* self, PyObject* arg) {
-    PyObject *exc_type = NULL, *exc_value = NULL, *exc_tb = NULL;
+    PyObject* exc_type = NULL, *exc_value = NULL, *exc_tb = NULL;
 
-    // borrowed refs
-    if(!PyArg_ParseTuple(arg, "O|OO", &exc_type, &exc_value, &exc_tb)) {
+    if(!PyArg_ParseTuple(arg, "O|OO", &exc_type, &exc_value, &exc_tb)) //borrowed refs
         return NULL;
-    }
 
-    if(PyExceptionInstance_Check(exc_type)) {
+    if(PyExceptionInstance_Check(exc_type)) { // e.g. throw(Exception())
         exc_value = exc_type;
         exc_type = PyExceptionInstance_Class(exc_type); // borrowed ref
     }
 
-    return _compose_go(self, exc_type, exc_value, exc_tb);
+    PyObject* r = _compose_go(self, exc_type, exc_value, exc_tb);
+    return r;
 }
 
 
@@ -424,17 +424,13 @@
 
 
 static void compose_del(PyObject* self) {
-    if(!compose_close((PyComposeObject*) self)) {
+    if(!compose_close((PyComposeObject*) self))
         PyErr_WriteUnraisable(self);
-    }
 }
 
 
 static PyObject* compose_iternext(PyComposeObject* self) {
-    Py_INCREF(Py_None);
-    PyObject* result = compose_send(self, Py_None);
-    Py_DECREF(Py_None);
-    return result;
+    return compose_send(self, Py_None);
 }
 
 
@@ -451,16 +447,14 @@
         if(PyGen_Check(*generator)) {
             PyObject* result = find_local_in_locals(((PyGenObject*) * generator)->gi_frame, name);
 
-            if(result != NULL) {
+            if(result != NULL)
                 return result;
-            }
 
         } else {
             PyObject* result = find_local_in_compose((PyComposeObject*) * generator, name);
 
-            if(result != NULL) {
+            if(result != NULL)
                 return result;
-            }
         }
     }
 
@@ -482,9 +476,8 @@
                 return localVar;
             }
 
-            if(localVar->ob_type == &PyCompose_Type) {
+            if(localVar->ob_type == &PyCompose_Type)
                 return find_local_in_compose((PyComposeObject*)localVar, name);
-            }
         }
     }
 
@@ -497,9 +490,8 @@
 
     PyObject* result = find_local_in_locals(frame, name);
 
-    if(result) {
+    if(result)
         return result;
-    }
 
     return find_local_in_frame(frame->f_back, name);
 }
@@ -526,16 +518,20 @@
 PyObject* tostring(PyObject* self, PyObject* gen) {
     if(PyGen_Check(gen)) {
         PyFrameObject* frame = ((PyGenObject*)gen)->gi_frame;
+
+        if(!frame)
+            return PyString_FromString("<no frame>");
+
         int ilineno = PyCode_Addr2Line(frame->f_code, frame->f_lasti);
         PyObject* lineno = PyInt_FromLong(ilineno); // new ref
         PyObject* codeline = PyObject_CallFunctionObjArgs(py_getline,
                              frame->f_code->co_filename, lineno, NULL); // new ref
-        Py_DECREF(lineno);
+        Py_CLEAR(lineno);
 
         if(!codeline) return NULL;
 
         PyObject* codeline_stripped = PyObject_CallMethod(codeline, "strip", NULL); // new ref
-        Py_DECREF(codeline);
+        Py_CLEAR(codeline);
 
         if(!codeline_stripped) return NULL;
 
@@ -544,7 +540,7 @@
                                 PyString_AsString(frame->f_code->co_filename),
                                 ilineno, PyString_AsString(frame->f_code->co_name),
                                 PyString_AsString(codeline_stripped)); // new ref
-        Py_DECREF(codeline_stripped);
+        Py_CLEAR(codeline_stripped);
         return result;
 
     } else if(gen->ob_type == &PyCompose_Type) {
@@ -555,10 +551,10 @@
         while(generator < cmps->generators_top) {
             PyObject* s = tostring(NULL, *generator++);
 
-            if(!result) {
+            if(!result)
                 result = s;
 
-            } else {
+            else {
                 PyString_ConcatAndDel(&result, PyString_FromString("\n"));
                 PyString_ConcatAndDel(&result, s);
             }
@@ -660,7 +656,7 @@
     PyObject* dict = PyModule_GetDict(linecache); // borrowed ref
 
     if(!dict) {
-        Py_DECREF(linecache);
+        Py_CLEAR(linecache);
         PyErr_Print();
         return;
     }
@@ -668,14 +664,14 @@
     py_getline = PyMapping_GetItemString(dict, "getline"); // new ref
 
     if(!py_getline) {
-        Py_DECREF(linecache);
+        Py_CLEAR(linecache);
         PyErr_Print();
         return;
     }
 
     if(PyType_Ready(&PyCompose_Type) < 0) {
-        Py_DECREF(linecache);
-        Py_DECREF(py_getline);
+        Py_CLEAR(linecache);
+        Py_CLEAR(py_getline);
         PyErr_Print();
         return;
     }
@@ -683,8 +679,8 @@
     PyObject* module = Py_InitModule3("_compose_c", compose_functionslist, "fast compose");
 
     if(!module) {
-        Py_DECREF(linecache);
-        Py_DECREF(py_getline);
+        Py_CLEAR(linecache);
+        Py_CLEAR(py_getline);
         PyErr_Print();
         return;
     }
@@ -699,7 +695,7 @@
 
 void assertTrue(const int condition, const char* msg) {
     if(!condition) {
-        printf("FAIL: ");
+        printf("Self-test (%s) FAIL: ", __FILE__);
         printf(msg);
         printf("\n");
     }
@@ -707,7 +703,6 @@
 
 
 static PyObject* _selftest(PyObject* self, PyObject* null) {
-    printf("\nRunning self test in " __FILE__ "\n");
     PyComposeObject c;
     _compose_initialize(&c);
     // test initial state of generator stack
@@ -798,7 +793,6 @@
     assertTrue(NULL == o, "error condition on next: empty");
     assertTrue(PyExc_RuntimeError == PyErr_Occurred(), "no runtime exception no next on empty queue");
     PyErr_Clear();
-    printf("Done with self test\n");
     compose_clear(&c);
     Py_RETURN_NONE;
 }
diff --unidirectional-new-file '--exclude=*.so' '--exclude=*.o' '--exclude=.svn' '--exclude=*.pyc' '--exclude=deps.d' '--exclude=applied' --recursive --unified version_1/weightless/core/compose/__init__.py version_1-sidekick/weightless/core/compose/__init__.py
--- version_1/weightless/core/compose/__init__.py	2011-02-15 08:48:32.000000000 +0100
+++ version_1-sidekick/weightless/core/compose/__init__.py	2011-02-21 11:10:34.000000000 +0100
@@ -22,10 +22,16 @@
 #
 ## end license ##
 
+from types import GeneratorType, FunctionType
+
 from os.path import dirname, abspath, isdir, join            #DO_NOT_DISTRIBUTE
+from sys import version_info                                 #DO_NOT_DISTRIBUTE
+pycmd = "python%s.%s" % version_info[:2]                     #DO_NOT_DISTRIBUTE
 if isdir(join(abspath(dirname(__file__)), '.svn')):          #DO_NOT_DISTRIBUTE
     from os import system                                    #DO_NOT_DISTRIBUTE
-    status = system("cd %s/../../..; ./setup.py build_ext --inplace"  % abspath(dirname(__file__)))  #DO_NOT_DISTRIBUTE
+    status = system(                                         #DO_NOT_DISTRIBUTE
+        "cd %s/../../..; %s setup.py build_ext --inplace"    #DO_NOT_DISTRIBUTE
+        % (abspath(dirname(__file__)), pycmd))               #DO_NOT_DISTRIBUTE
     if status > 0:                                           #DO_NOT_DISTRIBUTE
         import sys                                           #DO_NOT_DISTRIBUTE
         sys.exit(status)                                     #DO_NOT_DISTRIBUTE
@@ -34,10 +40,25 @@
     from os import getenv                                        #DO_NOT_DISTRIBUTE
     if getenv('WEIGHTLESS_COMPOSE_TEST') == 'PYTHON':            #DO_NOT_DISTRIBUTE
         raise ImportError('Python compose for testing purposes') #DO_NOT_DISTRIBUTE
-    from _compose_c import compose, local, tostring
+    from _compose_c import compose as _compose, local, tostring
+    ComposeType = _compose
 except ImportError:
     from warnings import warn
-    warn("You're now using the suboptimal python version of compose(), local(), tostring()")
-    from _compose_py import compose
+    warn("Using Python version of compose(), local() and tostring()", stacklevel=2)
+    from _compose_py import compose as _compose
     from _local_py import local
     from _tostring_py import tostring
+    ComposeType = GeneratorType
+
+from functools import partial as curry
+
+def compose(X, sidekick = None):
+    if type(X) == FunctionType: # compose used as decorator
+        def helper(*args, **kwargs):
+            return _compose(X(*args, **kwargs))
+        return helper
+    elif type(X) in (GeneratorType, ComposeType):
+        return _compose(X, sidekick)
+    raise TypeError("compose() expects generator, got %s" % repr(X))
+
+
